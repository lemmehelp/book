<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Homepage</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="shell/shell编程.html">shell 编程</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="C++学习/C++基础.html">C++学习</a></li><li class="chapter-item expanded affix "><a href="C++学习/C++基础带目录.html">C++基础</a></li><li class="chapter-item expanded affix "><a href="C++学习/C++进阶带目录.html">C++进阶</a></li><li class="chapter-item expanded affix "><a href="C++学习/bitvijay-IntelligenceGathering.html">C++进阶</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome-to-my-homepage"><a class="header" href="#welcome-to-my-homepage">welcome to my homepage</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shell-编程"><a class="header" href="#shell-编程">shell 编程</a></h1>
<p>使用文本编辑器建立 .sh文件</p>
<pre><code class="language-shell">#！/bin/bash
echo &quot;hello world!&quot;
</code></pre>
<p>其中==#！/bin/bash==用于表示脚本需要用什么解释器执行</p>
<p>刚建立的sh文件不能直接运行，如果希望运行则有两种方法</p>
<ol>
<li>
<h4 id="作为可执行程序"><a class="header" href="#作为可执行程序">作为可执行程序</a></h4>
<p>将上面的代码保存为 test.sh，并 cd 到相应目录</p>
<pre><code class="language-shell">chmod +x ./test.sh  #使脚本具有执行权限
./test.sh  #执行脚本
</code></pre>
<p>注意，一定要写成 <strong>./test.sh</strong>，而不是 <strong>test.sh</strong>，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p>
</li>
<li>
<h4 id="作为解释器参数"><a class="header" href="#作为解释器参数">作为解释器参数</a></h4>
<p>这种运行方式是直接运行解释器，参数就是shell脚本的文件名</p>
<pre><code class="language-shell">/bin/sh test.sh
/bin/php test.php
</code></pre>
</li>
</ol>
<p>这种方式运行的脚本，==不需要在第一行指定解释器信息==，写了也没用。</p>
<h1 id="shell-关键字"><a class="header" href="#shell-关键字">shell 关键字</a></h1>
<p>常用的关键字如下：</p>
<ol>
<li>
<p>echo：打印文字到屏幕</p>
</li>
<li>
<p>exec：执行另一个 Shell 脚本</p>
</li>
<li>
<p>read：读标准输入</p>
</li>
<li>
<p>expr：对整数型变量进行算术运算</p>
</li>
<li>
<p>test：用于测试变量是否相等、 是否为空、文件类型等</p>
</li>
<li>
<p>exit：退出</p>
</li>
</ol>
<pre><code class="language-shell">#!/bin/bash 

echo &quot;Hello Shell&quot;

# 读入变量
read VAR
echo &quot;VAR is $VAR&quot;

# 计算变量
expr $VAR - 5

# 测试字符串
test &quot;Hello&quot;=&quot;HelloWorld&quot;

# 测试整数
test $VAR -eq 10

# 测试目录
test -d ./Android

# 执行其他 Shell 脚本
exec ./othershell.sh

# 退出
exit
</code></pre>
<p>运行前，你需要新建一个 <code>othershell.sh</code> 的文件，让它输出 <code>I'm othershell</code>，并且中途需要一次输入，我这里输入的是 10：</p>
<pre><code class="language-shell">Hello Shell
10
VAR is 10
5
I'm othershell
</code></pre>
<h1 id="shell-变量"><a class="header" href="#shell-变量">shell 变量</a></h1>
<p>shell变量分为三种：</p>
<ul>
<li>用户自定义变量</li>
<li>预定义变量</li>
<li>环境变量</li>
</ul>
<p>定义变量需要注意下面2点：</p>
<ul>
<li>等号前后一定不要有空格 NUM=10</li>
<li>一般变量名用大写 M=1</li>
<li>使用 <code>$VAR</code> 调用变量，在变量名称前面添加<code>$</code>用于调用变量</li>
</ul>
<h4 id="一用户自定义变量"><a class="header" href="#一用户自定义变量">一、用户自定义变量</a></h4>
<p><strong>1、变量定义及赋值</strong></p>
<p>这种变量<strong>只支持字符串类型</strong>，不支持其他字符，浮点等类型，</p>
<p>常见有这 3 个前缀：</p>
<ol>
<li>
<p><code>unset</code>：删除变量</p>
</li>
<li>
<p><code>readonly</code>：标记只读变量</p>
</li>
<li>
<p><code>export</code>：指定全局变量</p>
</li>
</ol>
<p>一个例子：</p>
<pre><code class="language-shell">#!/bin/bash 

# 定义普通变量
CITY=SHENZHEN

# 定义全局变量
export NAME=cdeveloper

# 定义只读变量
readonly AGE=21

# 打印变量的值
echo $CITY
echo $NAME
echo $AGE

# 删除 CITY 变量
unset CITY
# 不会输出 SHENZHEN
echo $CITY
</code></pre>
<p>但是赋值的变量必须为一个整体不能有空格，要想包含空格需要用引号引用起来，类似于Python字符串定义</p>
<p><strong>2.引号的特殊用法</strong></p>
<blockquote>
<p>但是单引号‘ ’和双引号“ ”也有区别</p>
<p>从中可以看到，单引号可以保持==原样输出==，而双引号则会替换变量</p>
</blockquote>
<p>一个例子：</p>
<pre><code class="language-shell">[root@localhost ~]:~$ a=&quot;hello&quot;
[root@localhost ~]:~$ b=&quot;$a world&quot;
[root@localhost ~]:~$ echo $b
hello world
[root@localhost ~]:~$ c='$a world'
[root@localhost ~]:~$ echo $c
$a world
</code></pre>
<p><strong>3.``符号的特殊用法</strong></p>
<blockquote>
<p>除此之外，与单引号相似的号也有特殊含义，其表示其中引起来的==命令会被执行==，如果不想使用这个符号也可以使用<code>$()</code> 来代替</p>
</blockquote>
<pre><code class="language-shell">[root@localhost ~]:~$ d=`date`
[root@localhost ~]:~$ echo $d
Wed Dec 28 06:31:13 PST 2016

[root@localhost ~]:~$ e=$(date)
[root@localhost ~]:~$ echo $e
Wed Dec 28 06:31:48 PST 2016
</code></pre>
<p><strong>4、命令行交互<code>read</code></strong></p>
<p>有时候我们希望在脚本运行时能根据用户的输入决定脚本后续执行逻辑，比如在安装插件的时候经常会让用户选择输入<code>[N/Y]</code>的时候。 　　比如有一个脚本<code>script_test.sh</code></p>
<pre><code class="language-shell">read -p &quot;Please input [Y/N]: &quot; yn
if [ &quot;$yn&quot; == &quot;N&quot; -o &quot;$yn&quot; == &quot;n&quot; ]; then
  echo &quot;NO&quot;
elif [ &quot;$yn&quot; == &quot;Y&quot; -o &quot;$yn&quot; == &quot;y&quot; ]; then
  echo &quot;YES&quot;
fi
</code></pre>
<p><code>read</code>命令的使用形式为</p>
<pre><code class="language-sh">read [-pt] variable
　　参数p：后面可以接提示符
　　参数t：后面可以接秒数
例如：
read -p &quot;please input your name&quot; -t 5 name
</code></pre>
<p><strong>5、定义变量类型<code>declare</code></strong></p>
<p>默认情况下，变量的赋值内容都是字符类型的。例如下面的代码，我们期望的是输出一个求和值，但是输出的是一个求和表达式。</p>
<pre><code class="language-shell">[root@localhost ~]:~$ sum=100+300+500
[root@localhost ~]:~$ echo $sum
100+300+500

如果想要输出求和后的值，可以使用declare命令。

[root@localhost ~]:~$ declare -i sum=100+300+500
[root@localhost ~]:~$ echo $sum
900

declare [-aixr] variable
　　参数a：将variable定义为数组
　　参数i：将variable定义为整型(integer)
　　参数x：将variable设置成环境变量，类似于export的作用
　　参数r：variable为readonly类型，值不能被更改
</code></pre>
<h4 id="二shell中的集合类型"><a class="header" href="#二shell中的集合类型">二、Shell中的集合类型</a></h4>
<p><strong>1、<strong>数组</strong>(<code>array</code>)</strong></p>
<p><strong>（1）数组定义和赋值</strong></p>
<p>数组中的元素用括号包围，各元素之间用空格隔开。例如</p>
<pre><code class="language-sh">[root@localhost ~]:~$ array_name=(v0 v1 v2 v3)

#可以重新设置指定元素的内容，如下所示：
[root@localhost ~]:~$ array_name[2]=v22
[root@localhost ~]:~$ echo ${array_name[2]}
v22
</code></pre>
<p><strong>（2）数组元素访问</strong></p>
<p>输出该数组中所有元素：</p>
<pre><code class="language-sh">[root@localhost ~]:~$ echo ${array_name[*]} #此处与变量引用相似，也是用$符号,优于变成显示一组数，所以需要加{}
v0 v1 v22 v3
[root@localhost ~]:~$ echo ${array_name[@]}
v0 v1 v22 v3

#数组元素下标从0开始，想要访问指定位置的元素，使用[]指定下标值，如下所示
[root@localhost ~]:~$ echo ${array_name[0]}
v0
[root@localhost ~]:~$ echo ${array_name[1]}
v1
[root@localhost ~]:~$ echo ${array_name[3]}
v3
[root@localhost ~]:~$ echo ${array_name[2]}
v2
[root@localhost ~]:~$ echo ${array_name[4]}
</code></pre>
<p><strong>（3）获取数组长度</strong></p>
<p>获取数组长度使用如下命令</p>
<pre><code class="language-sh">[root@localhost ~]:~$ echo ${#array_name[@]}
4
[root@localhost ~]:~$ echo ${#array_name[*]}
4

#同样也可以获取单个元素的长度
[root@localhost ~]:~$ echo ${#array_name[2]}
</code></pre>
<h4 id="2map"><a class="header" href="#2map">2、map</a></h4>
<p><code>map</code>类型中存储的都是键值对。 类比与python中的字典，在Shell中定义<code>map</code>变量如下所示：</p>
<pre><code class="language-sh">declare -A m=([&quot;a&quot;]=&quot;1&quot; [&quot;b&quot;]=&quot;2&quot;)
#输出所有的key
[root@localhost ~]:~$ echo ${!m[@]}
a b
#输出所有的value
[root@localhost ~]:~$ echo ${m[@]}
1 2
#输出指定key对应的value
[root@localhost ~]:~$ echo ${m[&quot;a&quot;]}
1
[root@localhost ~]:~$ echo ${m[&quot;c&quot;]}
#添加元素
[root@localhost ~]:~$ m[&quot;c&quot;]=&quot;3&quot;
[root@localhost ~]:~$ echo ${m[&quot;c&quot;]}
3
#map中键值对的个数
[root@localhost ~]:~$ echo ${#m[@]}
3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>[TOC]</p>
<h2 id="c-简介"><a class="header" href="#c-简介">C++ 简介</a></h2>
<p>C++ 是一种静态类型的编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p>
<h2 id="标准库"><a class="header" href="#标准库">标准库</a></h2>
<p>标准的 C++ 由三个重要部分组成：</p>
<ul>
<li>核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。</li>
<li>C++ 标准库，提供了大量的函数，用于操作文件、字符串等。</li>
<li>标准模板库（STL），提供了大量的方法，用于操作数据结构等。</li>
</ul>
<h2 id="c-环境设置"><a class="header" href="#c-环境设置">C++ 环境设置</a></h2>
<p><strong>编辑 and 编译</strong></p>
<p>==编辑==：通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。</p>
<p>==编译==：它需要&quot;编译&quot;，转为机器语言，这样 CPU 可以按给定指令执行程序。</p>
<p>C++ 编译器用于把源代码编译成最终的可执行程序。大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。</p>
<p>最常用的免费可用的编译器是 GNU 的 C/C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。</p>
<h2 id="c-基本语法"><a class="header" href="#c-基本语法">C++ 基本语法</a></h2>
<p>C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。</p>
<ul>
<li><strong>对象 -</strong> 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。</li>
<li><strong>类 -</strong> 类可以定义为描述对象行为/状态的模板/蓝图。</li>
<li><strong>方法 -</strong> 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。</li>
<li><strong>即时变量 -</strong> 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

// main() 是程序开始执行的地方

int main()
{
   cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World    return 0; 
} 
</code></pre>
<ul>
<li>C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 <strong><iostream></strong>。</li>
<li>行 <strong>using namespace std;</strong> 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。</li>
<li>下一行 <strong>// main() 是程序开始执行的地方</strong> 是一个单行注释。单行注释以 // 开头，在行末结束。</li>
<li>下一行 <strong>int main()</strong> 是主函数，程序从这里开始执行。</li>
<li>下一行 <strong>cout &lt;&lt; &quot;Hello World&quot;;</strong> 会在屏幕上显示消息 &quot;Hello World&quot;。</li>
<li>下一行 <strong>return 0;</strong> 终止 main( )函数，并向调用进程返回值 0。</li>
</ul>
<h2 id="编译--执行-c-程序"><a class="header" href="#编译--执行-c-程序">编译 &amp; 执行 C++ 程序</a></h2>
<p>接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：</p>
<ul>
<li>打开一个文本编辑器，添加上述代码。</li>
<li>保存文件为 hello.cpp。</li>
<li>打开命令提示符，进入到保存文件所在的目录。</li>
<li>键入 'g++ hello.cpp '，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。</li>
<li>现在，键入 ' a.out' 来运行程序。</li>
<li>您可以看到屏幕上显示 ' Hello World '。</li>
</ul>
<h2 id="c-中的分号--块"><a class="header" href="#c-中的分号--块">C++ 中的分号 &amp; 块</a></h2>
<p>C++中默认以<strong>分号</strong>结尾才叫结束一句话，否则自然换行是不能被正确识别的</p>
<p><strong>块</strong>是一组使用大括号括起来的按逻辑连接的语句</p>
<h2 id="c-标识符"><a class="header" href="#c-标识符">C++ 标识符</a></h2>
<p>C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p>
<p>C++ 标识符内不允许出现标点字符，比如 @、$ 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，<strong>Manpower</strong> 和 <strong>manpower</strong> 是两个不同的标识符。</p>
<pre><code class="language-c++">mohd       zara    abc   move_name  a_123
myname50   _temp   j     a23b9      retVal
</code></pre>
<blockquote>
<p>类比于Python中的变量命名空间</p>
</blockquote>
<h2 id="c-关键字"><a class="header" href="#c-关键字">C++ 关键字</a></h2>
<p>下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p>
<table><thead><tr><th>asm</th><th>else</th><th>new</th><th>this</th></tr></thead><tbody>
<tr><td>auto</td><td>enum</td><td>operator</td><td>throw</td></tr>
<tr><td>bool</td><td>explicit</td><td>private</td><td>true</td></tr>
<tr><td>break</td><td>export</td><td>protected</td><td>try</td></tr>
<tr><td>case</td><td>extern</td><td>public</td><td>typedef</td></tr>
<tr><td>catch</td><td>false</td><td>register</td><td>typeid</td></tr>
<tr><td>char</td><td>float</td><td>reinterpret_cast</td><td>typename</td></tr>
<tr><td>class</td><td>for</td><td>return</td><td>union</td></tr>
<tr><td>const</td><td>friend</td><td>short</td><td>unsigned</td></tr>
<tr><td>const_cast</td><td>goto</td><td>signed</td><td>using</td></tr>
<tr><td>continue</td><td>if</td><td>sizeof</td><td>virtual</td></tr>
<tr><td>default</td><td>inline</td><td>static</td><td>void</td></tr>
<tr><td>delete</td><td>int</td><td>static_cast</td><td>volatile</td></tr>
<tr><td>do</td><td>long</td><td>struct</td><td>wchar_t</td></tr>
<tr><td>double</td><td>mutable</td><td>switch</td><td>while</td></tr>
<tr><td>dynamic_cast</td><td>namespace</td><td>template</td><td></td></tr>
</tbody></table>
<h2 id="c-中的空格"><a class="header" href="#c-中的空格">C++ 中的空格</a></h2>
<p>只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。</p>
<p>在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：</p>
<pre><code class="language-c++">int age
//为了增加代码的可读性，有时候会在变量之间增加空格
fruit = apples + oranges;   // 获取水果的总数
</code></pre>
<h2 id="c-注释"><a class="header" href="#c-注释">C++ 注释</a></h2>
<p>注释包含单行注释和多行注释两种</p>
<ul>
<li>单行注释用//表示即可，直到行末为止</li>
<li>多行注释使用/*  */包围表示，可以跨行使用</li>
</ul>
<blockquote>
<p>注意：在使用时，两者嵌套使用时不会互相干扰，谁在外层谁的优先级就更高</p>
</blockquote>
<h2 id="c-数据类型"><a class="header" href="#c-数据类型">C++ 数据类型</a></h2>
<p><strong>基本的内置类型</strong></p>
<table><thead><tr><th align="left">类型</th><th align="left">关键字</th></tr></thead><tbody>
<tr><td align="left">布尔型</td><td align="left">bool</td></tr>
<tr><td align="left">字符型</td><td align="left">char</td></tr>
<tr><td align="left">整型</td><td align="left">int</td></tr>
<tr><td align="left">浮点型</td><td align="left">float</td></tr>
<tr><td align="left">双浮点型</td><td align="left">double</td></tr>
<tr><td align="left">无类型</td><td align="left">void</td></tr>
<tr><td align="left">宽字符型</td><td align="left">wchar_t</td></tr>
</tbody></table>
<p>一些基本类型可以使用一个或多个类型修饰符进行修饰：</p>
<ul>
<li>signed</li>
<li>unsigned</li>
<li>short</li>
<li>long</li>
</ul>
<p>下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。</p>
<table><thead><tr><th align="left">类型</th><th align="left">位</th><th align="left">范围</th></tr></thead><tbody>
<tr><td align="left">char</td><td align="left">1 个字节</td><td align="left">-128 到 127 或者 0 到 255</td></tr>
<tr><td align="left">unsigned char</td><td align="left">1 个字节</td><td align="left">0 到 255</td></tr>
<tr><td align="left">signed char</td><td align="left">1 个字节</td><td align="left">-128 到 127</td></tr>
<tr><td align="left">int</td><td align="left">4 个字节</td><td align="left">-2147483648 到 2147483647</td></tr>
<tr><td align="left">unsigned int</td><td align="left">4 个字节</td><td align="left">0 到 4294967295</td></tr>
<tr><td align="left">signed int</td><td align="left">4 个字节</td><td align="left">-2147483648 到 2147483647</td></tr>
<tr><td align="left">short int</td><td align="left">2 个字节</td><td align="left">-32768 到 32767</td></tr>
<tr><td align="left">unsigned short int</td><td align="left">2 个字节</td><td align="left">0 到 65,535</td></tr>
<tr><td align="left">signed short int</td><td align="left">2 个字节</td><td align="left">-32768 到 32767</td></tr>
<tr><td align="left">long int</td><td align="left">8 个字节</td><td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr>
<tr><td align="left">signed long int</td><td align="left">8 个字节</td><td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr>
<tr><td align="left">unsigned long int</td><td align="left">8 个字节</td><td align="left">0 到 18,446,744,073,709,551,615</td></tr>
<tr><td align="left">float</td><td align="left">4 个字节</td><td align="left">精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td></tr>
<tr><td align="left">double</td><td align="left">8 个字节</td><td align="left">双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308(~15 个数字)</td></tr>
<tr><td align="left">long double</td><td align="left">16 个字节</td><td align="left">长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td></tr>
<tr><td align="left">wchar_t</td><td align="left">2 或 4 个字节</td><td align="left">1 个宽字符</td></tr>
</tbody></table>
<blockquote>
<p>类型关键字重新定义</p>
<p>例如： typedef int feet;</p>
<p>此时编译器将会认为feet就是关键词int，后续在定义时直接使用feet distance也可以定义一个名为distance的整形变量。</p>
</blockquote>
<h2 id="枚举类型迷惑"><a class="header" href="#枚举类型迷惑">枚举类型(迷惑？)</a></h2>
<p><del>枚举类型声明一个可选的类型名称和一组标识符，用来作为该类型的值。其带有零个或多个标识符可以被用来作为该类型的值。每个枚举数是一个枚举类型的常数。</del><em>看不懂</em></p>
<p><strong>枚举是C语言中的一种基本数据类型</strong>，并不是构造类型，它可以用于声明一组常数。当一个变量有几个固定的可能取值时，可以将这个变量定义为枚举类型。比如，你可以用一个枚举类型的变量来表示季节，因为季节只有4种可能的取值：春天、夏天、秋天、冬天。</p>
<p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：</p>
<pre><code class="language-c">//枚举结构
enum　枚举名　{枚举元素1,枚举元素2,……} 枚举变量;
enum enum-name { list of names } var-list;

//枚举的用法
1、赋值
enum Season {spring, summer, autumn, winter} s;
s = spring; // 等价于 s = 0;
s = 3; // 等价于 s = winter;

2、遍历元素
enum Season {spring, summer, autumn, winter} s;
// 遍历枚举元素
for (s = spring; s &lt;= winter; s++) {
    printf(&quot;枚举元素：%d \n&quot;, s);
}
</code></pre>
<h2 id="c-变量类型"><a class="header" href="#c-变量类型">C++ 变量类型</a></h2>
<p>变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p>
<p>变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的，具体的变量类型如上节中的表格所示</p>
<table><thead><tr><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody>
<tr><td align="left">bool</td><td align="left">存储值 true 或 false。</td></tr>
<tr><td align="left">char</td><td align="left">通常是一个八位字节（一个字节）。这是一个整数类型。</td></tr>
<tr><td align="left">int</td><td align="left">对机器而言，整数的最自然的大小。</td></tr>
<tr><td align="left">float</td><td align="left">单精度浮点值。</td></tr>
<tr><td align="left">double</td><td align="left">双精度浮点值。</td></tr>
<tr><td align="left">void</td><td align="left">表示类型的缺失。</td></tr>
<tr><td align="left">wchar_t</td><td align="left">宽字符类型。</td></tr>
</tbody></table>
<p>C++ 也允许定义各种其他类型的变量，比如<strong>枚举、指针、数组、引用、数据结构、类</strong>等等，这将会在后续的章节中进行讲解</p>
<h2 id="c-中的变量定义"><a class="header" href="#c-中的变量定义">C++ 中的变量定义</a></h2>
<blockquote>
<p>典型定义结构</p>
<p>type variable_list;</p>
</blockquote>
<p>在这里，<strong>type</strong> 必须是一个有效的 C++ 数据类型，可以是 char、w_char、int、float、double、bool 或任何用户自定义的对象，<strong>variable_list</strong> 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：</p>
<pre><code class="language-c++">int    i, j, k;
char   c, ch;
float  f, salary;
double d;
//额外实例
extern int d = 3, f = 5;    // d 和 f 的声明 
int d = 3, f = 5;           // 定义并初始化 d 和 f
byte z = 22;                // 定义并初始化 z
char x = 'x';               // 变量 x 的值为 'x'
</code></pre>
<p>**不带初始化的定义：**带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。</p>
<h2 id="c-中的变量声明"><a class="header" href="#c-中的变量声明">C++ 中的变量声明</a></h2>
<blockquote>
<p><strong>extern</strong>关键字</p>
<p>当两个文件需要链接使用，两个文件中同时定义了一个重名的变量时，编译时是不会出现问题的，但是当运行时就会出现重复定义的问题。为了克服这个问题可以使用extern关键字（挖坑待填）</p>
</blockquote>
<h2 id="c-中的左值lvalues和右值rvalues"><a class="header" href="#c-中的左值lvalues和右值rvalues">C++ 中的左值（Lvalues）和右值（Rvalues）</a></h2>
<p>C++ 中有两种类型的表达式：</p>
<ul>
<li>
<p><strong>左值（lvalue）：<strong>指向</strong>内存位置</strong>的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</p>
</li>
<li>
<p><strong>右值（rvalue）：<strong>术语右值（rvalue）指的是</strong>存储在内存中某些地址的数值</strong>。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</p>
<blockquote>
<p>右值是具体的数值，是在内存特定位置的一些数值，而左值则只是指示特定值在内存中位置的标签。</p>
</blockquote>
</li>
</ul>
<p>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：</p>
<pre><code>int g = 20;
</code></pre>
<p>但是下面这个就不是一个有效的语句，会生成编译时错误：</p>
<pre><code class="language-c">10 = 20;
</code></pre>
<h2 id="c-变量作用域"><a class="header" href="#c-变量作用域">C++ 变量作用域</a></h2>
<p>作用域是程序的一个区域，一般来说有三个地方可以声明变量：</p>
<ul>
<li>在函数或一个代码块内部声明的变量，称为局部变量。</li>
<li>在函数参数的定义中声明的变量，称为形式参数。</li>
<li>在所有函数外部声明的变量，称为全局变量</li>
</ul>
<h2 id="全局变量和局部变量"><a class="header" href="#全局变量和局部变量">全局变量和局部变量</a></h2>
<p>在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。</p>
<p>全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
// 全局变量声明
int g;
 
int main ()
{
  // 局部变量声明
  int a, b;
 
  // 实际初始化
  a = 10;
  b = 20;
  g = a + b;
 
  cout &lt;&lt; g;     return 0;
 } 
// g = 30

//全局变量和局部变量可以同时定义，但是如果变量名相同是，局部变量会覆盖全局变量
</code></pre>
<blockquote>
<p>值得注意的是，与python不同，变量可以单独被创建而不需要预先赋值，但是系统会默认给个值，可能会导致意外的错误，因此最好直接在定义变量的时候就直接把数值定义好。</p>
</blockquote>
<p>当<strong>局部变量</strong>被定义时，系统不会对其初始化，您必须自行对其初始化。<strong>定义全局变量时，系统会自动初始化为下列值：</strong></p>
<table><thead><tr><th align="left">数据类型</th><th align="left">初始化默认值</th></tr></thead><tbody>
<tr><td align="left">int</td><td align="left">0</td></tr>
<tr><td align="left">char</td><td align="left">'\0'</td></tr>
<tr><td align="left">float</td><td align="left">0</td></tr>
<tr><td align="left">double</td><td align="left">0</td></tr>
<tr><td align="left">pointer</td><td align="left">NULL</td></tr>
</tbody></table>
<h2 id="c-常量"><a class="header" href="#c-常量">C++ 常量</a></h2>
<h4 id="整数常量"><a class="header" href="#整数常量">整数常量</a></h4>
<p>常量是固定值，<strong>在程序执行期间不会改变</strong>。这些固定的值，又叫做<strong>字面量</strong>。</p>
<p>常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。</p>
<p>常量就像是常规的变量，只不过常量的值在定义后不能进行修改。</p>
<p><strong>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</strong></p>
<p><strong>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</strong></p>
<p>常量实例</p>
<pre><code class="language-c++">212         // 合法的
215u        // 合法的
0xFeeL      // 合法的
078         // 非法的：8 不是八进制的数字
032UU       // 非法的：不能重复后缀
✅正确常量实例
85         // 十进制
0213       // 八进制 
0x4b       // 十六进制 
30         // 整数 
30u        // 无符号整数 
30l        // 长整数 
30ul       // 无符号长整数
</code></pre>
<h4 id="浮点常量"><a class="header" href="#浮点常量">浮点常量</a></h4>
<p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p>
<p>当使用小数形式表示时，必须包含小数点、指数，或同时包含两者。当使用指数形式表示时，必须包含整数部分、小数部分，或同时包含两者。带符号的指数是用 e 或 E 引入的。</p>
<pre><code class="language-c++">3.14159       // 合法的 
314159E-5L    // 合法的 
510E          // 非法的：不完整的指数
210f          // 非法的：没有小数或指数
.e55          // 非法的：缺少整数或分数
</code></pre>
<h4 id="布尔常量"><a class="header" href="#布尔常量">布尔常量</a></h4>
<p>布尔常量共有两个，它们都是标准的 C++ 关键字：</p>
<ul>
<li><strong>true</strong> 值代表真。</li>
<li><strong>false</strong> 值代表假。</li>
</ul>
<p>我们不应把 true 的值看成 1，把 false 的值看成 0。</p>
<h4 id="字符常量"><a class="header" href="#字符常量">字符常量</a></h4>
<p>字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 <strong>wchar_t</strong> 类型的变量中。否则，它就是一个窄字符常量（例如 'x'），此时它可以存储在 <strong>char</strong> 类型的简单变量中。</p>
<p>字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。</p>
<p>在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：</p>
<table><thead><tr><th align="left">转义序列</th><th align="left">含义</th></tr></thead><tbody>
<tr><td align="left">\</td><td align="left">\ 字符</td></tr>
<tr><td align="left">'</td><td align="left">' 字符</td></tr>
<tr><td align="left">&quot;</td><td align="left">&quot; 字符</td></tr>
<tr><td align="left">?</td><td align="left">? 字符</td></tr>
<tr><td align="left">\a</td><td align="left">警报铃声</td></tr>
<tr><td align="left">\b</td><td align="left">退格键</td></tr>
<tr><td align="left">\f</td><td align="left">换页符</td></tr>
<tr><td align="left">\n</td><td align="left">换行符</td></tr>
<tr><td align="left">\r</td><td align="left">回车</td></tr>
<tr><td align="left">\t</td><td align="left">水平制表符</td></tr>
<tr><td align="left">\v</td><td align="left">垂直制表符</td></tr>
<tr><td align="left">\ooo</td><td align="left">一到三位的八进制数</td></tr>
<tr><td align="left">\xhh . . .</td><td align="left">一个或多个数字的十六进制数</td></tr>
</tbody></table>
<h4 id="字符串常量"><a class="header" href="#字符串常量">字符串常量</a></h4>
<p>字符串字面值或常量是括在双引号 &quot;&quot; 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。</p>
<p>您可以使用空格做分隔符，把一个很长的字符串常量进行分行。</p>
<h2 id="定义常量"><a class="header" href="#定义常量">定义常量</a></h2>
<p>在 C++ 中，有两种简单的定义常量的方式：</p>
<ul>
<li>使用 <strong>#define</strong> 预处理器。</li>
<li>使用 <strong>const</strong> 关键字。</li>
</ul>
<h4 id="1define预处理器"><a class="header" href="#1define预处理器">1、define预处理器</a></h4>
<p>下面是使用 #define 预处理器定义常量的形式：</p>
<pre><code class="language-c++">#define identifier value
</code></pre>
<p><strong>一个例子</strong></p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

#define LENGTH 10   
#define WIDTH  5
#define NEWLINE '\n'

int main()
{

   int area;  
   
   area = LENGTH * WIDTH;
   cout &lt;&lt; area;
   cout &lt;&lt; NEWLINE;
   return 0;
}

//输出结果 50
</code></pre>
<h4 id="2const关键字"><a class="header" href="#2const关键字">2、const关键字</a></h4>
<pre><code class="language-c++">const type variable = value;
</code></pre>
<p><strong>一个例子</strong></p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

int main()
{
   const int  LENGTH = 10;
   const int  WIDTH  = 5;
   const char NEWLINE = '\n';
   int area;  
   
   area = LENGTH * WIDTH;
   cout &lt;&lt; area;
   cout &lt;&lt; NEWLINE;
   return 0;
} 
</code></pre>
<p>==请注意，把常量定义为大写字母形式，是一个很好的编程实践。==</p>
<blockquote>
<p>此外，define和const是两种不同的定义方式，denfine的定义优先级好像要高于const，通过define方法定义后的变量就不可以再被const利用</p>
</blockquote>
<h2 id="c-修饰符类型"><a class="header" href="#c-修饰符类型">C++ 修饰符类型</a></h2>
<p>C++ 允许在 <strong>char、int 和 double</strong> 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。</p>
<p>下面列出了数据类型修饰符：</p>
<ul>
<li>signed</li>
<li>unsigned</li>
<li>long</li>
<li>short</li>
</ul>
<p>修饰符 <strong>signed、unsigned、long 和 short</strong> 可应用于整型，<strong>signed</strong> 和 <strong>unsigned</strong> 可应用于字符型，<strong>long</strong> 可应用于双精度型。</p>
<p>修饰符 <strong>signed</strong> 和 <strong>unsigned</strong> 也可以作为 <strong>long</strong> 或 <strong>short</strong> 修饰符的前缀。例如：<strong>unsigned long int</strong>。</p>
<p>C++ 允许使用速记符号来声明<strong>无符号短整数</strong>或<strong>无符号长整数</strong>。您可以不写 int，只写单词 <strong>unsigned short</strong> 或 <strong>unsigned long</strong>，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。</p>
<blockquote>
<p>例如</p>
<p>unsigned x;</p>
<p>unsigned int y;</p>
</blockquote>
<p>为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
 
/* 
 * 这个程序演示了有符号整数和无符号整数之间的差别
*/
int main()
{
   short int i;           // 有符号短整数
   short unsigned int j;  // 无符号短整数

   j = 50000;

   i = j;
   cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j;

   return 0;
} 
</code></pre>
<blockquote>
<p>输出结果为-15536 50000</p>
<p>上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。</p>
</blockquote>
<h2 id="c-中的类型限定符"><a class="header" href="#c-中的类型限定符">C++ 中的类型限定符</a></h2>
<p>类型限定符提供了变量的额外信息。</p>
<table><thead><tr><th align="left">限定符</th><th align="left">含义</th></tr></thead><tbody>
<tr><td align="left">const</td><td align="left"><strong>const</strong> 类型的对象在程序执行期间不能被修改改变。</td></tr>
<tr><td align="left">volatile</td><td align="left">修饰符 <strong>volatile</strong> 告诉编译器，变量的值可能以程序未明确指定的方式被改变。</td></tr>
<tr><td align="left">restrict</td><td align="left">由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td></tr>
</tbody></table>
<h2 id="c-存储类"><a class="header" href="#c-存储类">C++ 存储类</a></h2>
<p>存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>mutable</li>
</ul>
<h4 id="1auto-存储类"><a class="header" href="#1auto-存储类">1、auto 存储类</a></h4>
<p><strong>auto</strong> 存储类是所有局部变量默认的存储类。</p>
<pre><code class="language-c++">{
   int mount;
   auto int month;
}
</code></pre>
<p>在函数中定义局部变量时，系统默认认为其为auto储存类</p>
<h4 id="2register-存储类"><a class="header" href="#2register-存储类">2、register 存储类</a></h4>
<p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&amp;' 运算符（因为它没有内存位置）。</p>
<pre><code class="language-c++">{
   register int  miles;
}
</code></pre>
<p><strong>寄存器只用于需要快速访问的变量</strong>，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>
<!--如果把被储存的东西比作能量：-->
<!--1. 寄存器就是 ATP，可以随时拿来用，性能高，但数量有限；-->
<!--2. 内存就是葡萄糖，性能一般，但是存量可以比较多；-->
<!--3. 外存（比如硬盘）就是脂肪，容量可以非常大，性能很差，要先转化为葡萄糖（存进内存），然后转化为 ATP（放到寄存器）才能直接利用（存取）。-->
<h4 id="3static-存储类"><a class="header" href="#3static-存储类">3、static 存储类</a></h4>
<p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。<strong>因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</strong></p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。<strong>全局变量默认就是static类型。</strong></p>
<p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p>
<h4 id="4extern储存类相当于定义一个可以多个文件共享的变量"><a class="header" href="#4extern储存类相当于定义一个可以多个文件共享的变量">4、extern储存类（相当于定义一个可以多个文件共享的变量）</a></h4>
<p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p>
<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p>
<p>一个例子🌰：</p>
<p>☝🏻第一个文件：main.cpp</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
 
int count ;
extern void write_extern();
 
main()
{
   count = 5;
   write_extern();
}
</code></pre>
<p>2️⃣第二个文件：support.cpp</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
 
extern int count;
 
void write_extern(void)
{
   std::cout &lt;&lt; &quot;Count is &quot; &lt;&lt; count &lt;&lt; std::endl; 
} 
</code></pre>
<p>在这里，第二个文件中的 <em>extern</em> 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示：</p>
<blockquote>
<p>联立编译</p>
<p>$g++ main.cpp support.cpp -o write</p>
<p>然后运行输出的write文件便可以输出</p>
<p>Count is  5</p>
</blockquote>
<p><u>在这里，我的理解相当于extern类似于python中的import函数，可以跨文件声明及引用变量及函数定义，使多个文件可以联立使用</u></p>
<h4 id="5mutable储存类"><a class="header" href="#5mutable储存类">5、mutable储存类</a></h4>
<p><strong>mutable</strong> 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p>
<h2 id="c-运算符"><a class="header" href="#c-运算符">C++ 运算符</a></h2>
<p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>杂项运算符</li>
</ul>
<h4 id="1算数运算符"><a class="header" href="#1算数运算符">1、算数运算符</a></h4>
<p>也即一般的加减乘除等基本操作的符号，具体的如下表所示：</p>
<p>假设变量 A 的值为 10，变量 B 的值为 20，则：</p>
<table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody>
<tr><td align="left">+</td><td align="left">把两个操作数相加</td><td align="left">A + B 将得到 30</td></tr>
<tr><td align="left">-</td><td align="left">从第一个操作数中减去第二个操作数</td><td align="left">A - B 将得到 -10</td></tr>
<tr><td align="left">*</td><td align="left">把两个操作数相乘</td><td align="left">A * B 将得到 200</td></tr>
<tr><td align="left">/</td><td align="left">分子除以分母</td><td align="left">B / A 将得到 2</td></tr>
<tr><td align="left">%</td><td align="left">取模运算符，整除后的余数</td><td align="left">B % A 将得到 0</td></tr>
<tr><td align="left">++</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-increment-decrement-operators.html">自增运算符</a>，整数值增加 1</td><td align="left">A++ 将得到 11</td></tr>
<tr><td align="left">--</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-increment-decrement-operators.html">自减运算符</a>，整数值减少 1</td><td align="left">A-- 将得到 9</td></tr>
</tbody></table>
<h4 id="2关系运算符"><a class="header" href="#2关系运算符">2、关系运算符</a></h4>
<p>下表显示了 C++ 支持的所有关系运算符。</p>
<p>假设变量 A 的值为 10，变量 B 的值为 20，则：</p>
<table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody>
<tr><td align="left">==</td><td align="left">检查两个操作数的值是否相等，如果相等则条件为真。</td><td align="left">(A == B) 不为真。</td></tr>
<tr><td align="left">!=</td><td align="left">检查两个操作数的值是否相等，如果不相等则条件为真。</td><td align="left">(A != B) 为真。</td></tr>
<tr><td align="left">&gt;</td><td align="left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td><td align="left">(A &gt; B) 不为真。</td></tr>
<tr><td align="left">&lt;</td><td align="left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td><td align="left">(A &lt; B) 为真。</td></tr>
<tr><td align="left">&gt;=</td><td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td><td align="left">(A &gt;= B) 不为真。</td></tr>
<tr><td align="left">&lt;=</td><td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td><td align="left">(A &lt;= B) 为真。</td></tr>
</tbody></table>
<h4 id="3逻辑运算符与或非"><a class="header" href="#3逻辑运算符与或非">3、逻辑运算符（与或非）</a></h4>
<p>假设变量 A 的值为 1，变量 B 的值为 0，则：</p>
<table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody>
<tr><td align="left">&amp;&amp;</td><td align="left">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td><td align="left">(A &amp;&amp; B) 为假。</td></tr>
<tr><td align="left">||</td><td align="left">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td><td align="left">(A || B) 为真。</td></tr>
<tr><td align="left">!</td><td align="left">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td><td align="left">!(A &amp;&amp; B) 为真。</td></tr>
</tbody></table>
<h4 id="4位运算符二进制操作"><a class="header" href="#4位运算符二进制操作">4、位运算符（二进制操作）</a></h4>
<p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p>
<table><thead><tr><th align="left">p</th><th align="left">q</th><th align="left">p &amp; q</th><th align="left">p | q</th><th align="left">p ^ q</th></tr></thead><tbody>
<tr><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr>
<tr><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr>
<tr><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">0</td></tr>
<tr><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr>
</tbody></table>
<p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：</p>
<p>A = 0011 1100</p>
<p>B = 0000 1101</p>
<p>-----------------</p>
<p>A&amp;B = 0000 1100</p>
<p>A|B = 0011 1101</p>
<p>A^B = 0011 0001</p>
<p>~A = 1100 0011</p>
<blockquote>
<p>也就是对数字先转化成二进制，然后再对二进制数字进行调整</p>
</blockquote>
<p>下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：</p>
<table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody>
<tr><td align="left">&amp;</td><td align="left">如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td><td align="left">(A &amp; B) 将得到 12，即为 0000 1100</td></tr>
<tr><td align="left">|</td><td align="left">如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td><td align="left">(A | B) 将得到 61，即为 0011 1101</td></tr>
<tr><td align="left">^</td><td align="left">如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td><td align="left">(A ^ B) 将得到 49，即为 0011 0001</td></tr>
<tr><td align="left">~</td><td align="left">二进制补码运算符是一元运算符，具有&quot;翻转&quot;位效果。</td><td align="left">(~A ) 将得到 -61，即为 1100 0011，2 的补码形式，带符号的二进制数。</td></tr>
<tr><td align="left">&lt;&lt;</td><td align="left">二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td><td align="left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr>
<tr><td align="left">&gt;&gt;</td><td align="left">二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td><td align="left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr>
</tbody></table>
<!--左移位运算：十进制转化为二进制，左右后最后一位补0-->
<!--一个例子🌰：-->
<!--十进制：11-->
<!--二进制：1011-->
<table><thead><tr><th><!--←--></th><th><!--1--></th><th><!--0--></th><th><!--1--></th><th><!--1--></th></tr></thead><tbody>
<tr><td><!--1--></td><td><!--0--></td><td><!--1--></td><td><!--1--></td><td><!--0--></td></tr>
</tbody></table>
<!--完成左移，此时转化为十进制变为22-->
<!--左移几位就是在原数的基础上乘以2的几次方-->
<!--反之，右移位运算则是向右侧移动，不用补位，直接把最右边的那一位吃掉了-->
<h4 id="5赋值运算符"><a class="header" href="#5赋值运算符">5、赋值运算符</a></h4>
<p>下表列出了 C++ 支持的赋值运算符：</p>
<table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody>
<tr><td align="left">=</td><td align="left">简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td align="left">C = A + B 将把 A + B 的值赋给 C</td></tr>
<tr><td align="left">+=</td><td align="left">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td align="left">C += A 相当于 C = C + A</td></tr>
<tr><td align="left">-=</td><td align="left">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td align="left">C -= A 相当于 C = C - A</td></tr>
<tr><td align="left">*=</td><td align="left">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td align="left">C *= A 相当于 C = C * A</td></tr>
<tr><td align="left">/=</td><td align="left">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td align="left">C /= A 相当于 C = C / A</td></tr>
<tr><td align="left">%=</td><td align="left">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td><td align="left">C %= A 相当于 C = C % A</td></tr>
<tr><td align="left">&lt;&lt;=</td><td align="left">左移且赋值运算符</td><td align="left">C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td></tr>
<tr><td align="left">&gt;&gt;=</td><td align="left">右移且赋值运算符</td><td align="left">C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td></tr>
<tr><td align="left">&amp;=</td><td align="left">按位与且赋值运算符</td><td align="left">C &amp;= 2 等同于 C = C &amp; 2</td></tr>
<tr><td align="left">^=</td><td align="left">按位异或且赋值运算符</td><td align="left">C ^= 2 等同于 C = C ^ 2</td></tr>
<tr><td align="left">|=</td><td align="left">按位或且赋值运算符</td><td align="left">C |= 2 等同于 C = C | 2</td></tr>
</tbody></table>
<h4 id="6杂项运算符"><a class="header" href="#6杂项运算符">6、杂项运算符</a></h4>
<p>下表列出了 C++ 支持的其他一些重要的运算符。</p>
<table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody>
<tr><td align="left">sizeof</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-sizeof-operator.html">sizeof 运算符</a>返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。</td></tr>
<tr><td align="left">Condition ? X : Y</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-conditional-operator.html">条件运算符</a>。如果 Condition 为真 ? 则值为 X : 否则值为 Y。</td></tr>
<tr><td align="left">,</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-comma-operator.html">逗号运算符</a>会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</td></tr>
<tr><td align="left">.（点）和 -&gt;（箭头）</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-member-operators.html">成员运算符</a>用于引用类、结构和共用体的成员。</td></tr>
<tr><td align="left">Cast</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-casting-operators.html">强制转换运算符</a>把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</td></tr>
<tr><td align="left">&amp;</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-pointer-operators.html">指针运算符 &amp;</a> 返回变量的地址。例如 &amp;a; 将给出变量的实际地址。</td></tr>
<tr><td align="left">*</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-pointer-operators.html">指针运算符 *</a> 指向一个变量。例如，*var; 将指向变量 var。</td></tr>
</tbody></table>
<h4 id="c-中的运算符优先级"><a class="header" href="#c-中的运算符优先级">C++ 中的运算符优先级</a></h4>
<p>运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。</p>
<p>例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。</p>
<p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p>
<table><thead><tr><th align="left">类别</th><th align="left">运算符</th><th align="left">结合性</th></tr></thead><tbody>
<tr><td align="left">后缀</td><td align="left">() [] -&gt; . ++ - -</td><td align="left">从左到右</td></tr>
<tr><td align="left">一元</td><td align="left">+ - ! ~ ++ - - (type)* &amp; sizeof</td><td align="left">从右到左</td></tr>
<tr><td align="left">乘除</td><td align="left">* / %</td><td align="left">从左到右</td></tr>
<tr><td align="left">加减</td><td align="left">+ -</td><td align="left">从左到右</td></tr>
<tr><td align="left">移位</td><td align="left">&lt;&lt; &gt;&gt;</td><td align="left">从左到右</td></tr>
<tr><td align="left">关系</td><td align="left">&lt; &lt;= &gt; &gt;=</td><td align="left">从左到右</td></tr>
<tr><td align="left">相等</td><td align="left">== !=</td><td align="left">从左到右</td></tr>
<tr><td align="left">位与 AND</td><td align="left">&amp;</td><td align="left">从左到右</td></tr>
<tr><td align="left">位异或 XOR</td><td align="left">^</td><td align="left">从左到右</td></tr>
<tr><td align="left">位或 OR</td><td align="left">|</td><td align="left">从左到右</td></tr>
<tr><td align="left">逻辑与 AND</td><td align="left">&amp;&amp;</td><td align="left">从左到右</td></tr>
<tr><td align="left">逻辑或 OR</td><td align="left">||</td><td align="left">从左到右</td></tr>
<tr><td align="left">条件</td><td align="left">?:</td><td align="left">从右到左</td></tr>
<tr><td align="left">赋值</td><td align="left">= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |=</td><td align="left">从右到左</td></tr>
<tr><td align="left">逗号</td><td align="left">,</td><td align="left">从左到右</td></tr>
</tbody></table>
<h2 id="c-循环及控制"><a class="header" href="#c-循环及控制">C++ 循环及控制</a></h2>
<h4 id="1循环类型"><a class="header" href="#1循环类型">1、循环类型</a></h4>
<p>C++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。</p>
<table><thead><tr><th align="left">循环类型</th><th align="left">描述</th></tr></thead><tbody>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-while-loop.html">while 循环</a></td><td align="left">当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-for-loop.html">for 循环</a></td><td align="left">多次执行一个语句序列，简化管理循环变量的代码。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-do-while-loop.html">do...while 循环</a></td><td align="left">除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-nested-loops.html">嵌套循环</a></td><td align="left">您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td></tr>
</tbody></table>
<h5 id="1while-循环"><a class="header" href="#1while-循环">1、while 循环</a></h5>
<p>只要给定的条件为真，<strong>while</strong> 循环语句会重复执行一个目标语句。</p>
<p><strong>语法</strong>⭐️</p>
<pre><code class="language-C++">while(condition) (!!这里没有分号)
{
   statement(s);
}

</code></pre>
<p><strong>一个例子</strong>🌰</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main ()
{
   // 局部变量声明
   int a = 10;

   // while 循环执行
   while( a &lt; 20 )
   {
       cout &lt;&lt; &quot;a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
       a++;
   }
 
   return 0;
}
</code></pre>
<h5 id="2for循环"><a class="header" href="#2for循环">2、for循环</a></h5>
<p><strong>for</strong> 循环允许您编写一个执行特定次数的循环的重复控制结构。</p>
<p><strong>语法</strong>⭐️</p>
<pre><code class="language-C++">for (init; condition; increment)
{
  statement(s);
}
</code></pre>
<p>下面是 for 循环的控制流：</p>
<ol>
<li>
<p><strong>init</strong> 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。</p>
</li>
<li>
<p>接下来，会判断 <strong>condition</strong>。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。</p>
</li>
<li>
<p>在执行完 for 循环主体后，控制流会跳回上面的 <strong>increment</strong> 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。</p>
</li>
<li>
<p>条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。</p>
<p><strong>一个例子</strong>🌰</p>
</li>
</ol>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
 
int main ()
{
   // for 循环执行
   for( int a = 10; a &lt; 20; a = a + 1 )
   {
       cout &lt;&lt; &quot;a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   }
 
   return 0;
}
</code></pre>
<h5 id="3dowhile循环"><a class="header" href="#3dowhile循环">3、do.....while....循环</a></h5>
<p>不像 <strong>for</strong> 和 <strong>while</strong> 循环，它们是在循环头部测试循环条件。<strong>do...while</strong> 循环是在循环的尾部检查它的条件。</p>
<p><strong>do...while</strong> 循环与 while 循环类似，但是 do...while 循环会确保至少执行一次循环。</p>
<p><strong>语法</strong>⭐️</p>
<pre><code class="language-C++">do
{
   statement(s);

}while( condition ); (!!!需要注意，这里反而有一个分号)

</code></pre>
<p>请注意，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。</p>
<p>如果条件为真，控制流会跳转回上面的 do，然后重新执行循环中的 statement(s)。这个过程会不断重复，直到给定条件变为假为止。</p>
<p><strong>一个例子</strong>🌰</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main ()
{
   // 局部变量声明
   int a = 10;

   // do 循环执行
   do
   {
       cout &lt;&lt; &quot;a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
       a = a + 1;
   }while( a &lt; 20 );
 
   return 0;
}
</code></pre>
<h5 id="4嵌套的循环"><a class="header" href="#4嵌套的循环">4、嵌套的循环</a></h5>
<p>一个循环内可以嵌套另一个循环。C++ 允许至少 256 个嵌套层次。</p>
<p>C++ 中 <strong>嵌套 for 循环</strong> 语句的语法：</p>
<pre><code class="language-C++">for ( init; condition; increment )
{
   for ( init; condition; increment )
   {
      statement(s);
   }
   statement(s); // 可以放置更多的语句
}
</code></pre>
<p>C++ 中 <strong>嵌套 while 循环</strong> 语句的语法：</p>
<pre><code class="language-C++">while(condition)
{
   while(condition)
   {
      statement(s);
   }
   statement(s); // 可以放置更多的语句
}
</code></pre>
<p>C++ 中 <strong>嵌套 do...while 循环</strong> 语句的语法：</p>
<pre><code class="language-C++">do
{
   statement(s); // 可以放置更多的语句
   do
   {
      statement(s);
   }while( condition );

}while( condition );
</code></pre>
<p>此外 多种循环可以相互嵌套</p>
<h4 id="2循环控制语句"><a class="header" href="#2循环控制语句">2、循环控制语句</a></h4>
<p>循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。</p>
<p>C++ 提供了下列的控制语句。点击链接查看每个语句的细节。</p>
<table><thead><tr><th align="left">控制语句</th><th align="left">描述</th></tr></thead><tbody>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-break-statement.html">break 语句</a></td><td align="left">终止 <strong>loop</strong> 或 <strong>switch</strong> 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-continue-statement.html">continue 语句</a></td><td align="left">引起循环跳过主体的剩余部分，立即重新开始测试条件。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-goto-statement.html">goto 语句</a></td><td align="left">将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td></tr>
</tbody></table>
<h5 id="1cbreak语句达到条件提前终止"><a class="header" href="#1cbreak语句达到条件提前终止">1、C++break语句（达到条件提前终止）</a></h5>
<p>C++ 中 <strong>break</strong> 语句有以下两种用法：</p>
<ol>
<li>当 <strong>break</strong> 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。</li>
<li>它可用于终止 <strong>switch</strong> 语句中的一个 case。</li>
</ol>
<p>如果您使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。</p>
<p><img src="C++%E5%AD%A6%E4%B9%A0/C++.media/1472441083298339.jpg" alt="c++" /></p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main ()
{
   // 局部变量声明
   int a = 10;

   // do 循环执行
   do
   {
       cout &lt;&lt; &quot;a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
       a = a + 1;
       if( a &gt; 15)
       {
          // 终止循环
          break;
       }
   }while( a &lt; 20 );
 
   return 0;
}
</code></pre>
<h5 id="2ccontinue语句额外增加一次判断然后跳过原本执行的语句"><a class="header" href="#2ccontinue语句额外增加一次判断然后跳过原本执行的语句">2、C++continue语句（额外增加一次判断，然后跳过原本执行的语句）</a></h5>
<p>C++ 中的 <strong>continue</strong> 语句有点像 <strong>break</strong> 语句。但它不是强迫终止，continue 会跳过当前循环中的代码，强迫开始下一次循环。</p>
<p>对于 <strong>for</strong> 循环，<strong>continue</strong> 语句会导致执行条件测试和循环增量部分。对于 <strong>while</strong> 和 <strong>do...while</strong> 循环，<strong>continue</strong> 语句会导致程序控制回到条件测试上。</p>
<p><img src="C++%E5%AD%A6%E4%B9%A0/C++.media/2EB76530-877A-4AC1-87E6-501CEC7E6CB3.png" alt="img" /></p>
<p>一个例子🌰</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main ()
{
   // 局部变量声明
   int a = 10;

   // do 循环执行
   do
   {
       if( a == 15)
       {
          // 跳过迭代
          a = a + 1;
          continue;
       }
       cout &lt;&lt; &quot;a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
       a = a + 1;
   }while( a &lt; 20 );
 
   return 0;
}
/////////////////输出结果//////////////////////
a 的值： 10
a 的值： 11
a 的值： 12
a 的值： 13
a 的值： 14（因为continue的存在的导致直接越过了15）
a 的值： 16
a 的值： 17
a 的值： 18
a 的值： 19
</code></pre>
<h5 id="3goto-语句-满足某个条件直接蹦到执行某个命令"><a class="header" href="#3goto-语句-满足某个条件直接蹦到执行某个命令">3、goto 语句 （满足某个条件直接蹦到执行某个命令）</a></h5>
<p><strong>goto</strong> 语句允许把控制无条件转移到同一函数内的被标记的语句。</p>
<p>C++ 中 <strong>goto</strong> 语句的语法：</p>
<pre><code class="language-c++">goto label;
..
.
label: statement;
//在这里，label 是识别被标记语句的标识符，可以是任何除 C++ 关键字以外的纯文本。标记语句可以是任何语句，放置在标识符和冒号（:）后边。
</code></pre>
<p><img src="C++%E5%AD%A6%E4%B9%A0/C++.media/1472441355192426-8838760.jpg" alt="C++ goto 语句" /></p>
<p>一个例子🌰</p>
<pre><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
 
int main()
{
    int x,sum=0;
    //定义标号L1
L1: cout&lt;&lt;&quot;x=&quot;;
    cin&gt;&gt;x;
    if (x==-1)
       goto L2;          //当用户输入-1时，转到L2语句处
    else
       sum+=x;
    goto L1;             //只要用户没有输入-1，则转到L1语句处，程序一直将用户的输入默默地累加到变量sum中。
    //定义标号L2
L2: cout&lt;&lt;&quot;sum=&quot;&lt;&lt;sum&lt;&lt;endl;//一旦转到L2，将输出累计结果，程序运行结束。
    system(&quot;pause&quot;);
}
</code></pre>
<h5 id="无限循环"><a class="header" href="#无限循环">无限循环</a></h5>
<p>如果条件永远不为假则可以完成无限循环，语法比如for（；；）</p>
<h2 id="c-判断"><a class="header" href="#c-判断">C++ 判断</a></h2>
<p>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p>
<h4 id="1判断语句"><a class="header" href="#1判断语句">1、判断语句</a></h4>
<p>C++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。</p>
<table><thead><tr><th align="left">语句</th><th align="left">描述</th></tr></thead><tbody>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-if.html">if 语句</a></td><td align="left">一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-if-else.html">if...else 语句</a></td><td align="left">一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-nested-if.html">嵌套 if 语句</a></td><td align="left">您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-switch.html">switch 语句</a></td><td align="left">一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-nested-switch.html">嵌套 switch 语句</a></td><td align="left">您可以在一个 <strong>switch</strong> 语句内使用另一个 <strong>switch</strong> 语句。</td></tr>
</tbody></table>
<h5 id="1if语句"><a class="header" href="#1if语句">1、if语句</a></h5>
<p>一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</p>
<p>C++ 中 <strong>if</strong> 语句的语法：</p>
<pre><code class="language-C++">if(boolean_expression)
{
   // 如果布尔表达式为真将执行的语句；
}
</code></pre>
<h5 id="2if-else语句"><a class="header" href="#2if-else语句">2、if-else语句</a></h5>
<p>一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</p>
<p>C++ 中 <strong>if...else</strong> 语句的语法：</p>
<pre><code class="language-C++">if(boolean_expression)
{
   // 如果布尔表达式为真将执行的语句；
}
else
{
   // 如果布尔表达式为假将执行的语句；
}
</code></pre>
<p>if-else进阶版⭐️</p>
<p>C++ 中的 <strong>if...else if...else</strong> 语句的语法：</p>
<pre><code class="language-C++">if(boolean_expression 1)
{
   // 当布尔表达式 1 为真时执行
}
else if( boolean_expression 2)
{
   // 当布尔表达式 2 为真时执行
}
else if( boolean_expression 3)
{
   // 当布尔表达式 3 为真时执行
}
else 
{
   // 当上面条件都不为真时执行
}
</code></pre>
<h5 id="3嵌套if"><a class="header" href="#3嵌套if">3、嵌套if</a></h5>
<p>C++ 中 <strong>嵌套 if</strong> 语句的语法：</p>
<pre><code class="language-C++">if( boolean_expression 1)
{
   // 当布尔表达式 1 为真时执行
   if(boolean_expression 2)
   {
      // 当布尔表达式 2 为真时执行
   }
}
</code></pre>
<h5 id="4switch语句"><a class="header" href="#4switch语句">4、switch语句⭐️</a></h5>
<p>一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 <strong>switch case</strong> 进行检查。</p>
<p>C++ 中 <strong>switch</strong> 语句的语法：</p>
<pre><code class="language-C++">switch(expression){
    case constant-expression  :
       statement(s);
       break; // 可选的
    case constant-expression  :
       statement(s);
       break; // 可选的
  
    // 您可以有任意数量的 case 语句
    default : // 可选的
       statement(s);
}
</code></pre>
<p><strong>switch</strong> 语句必须遵循下面的规则：</p>
<ul>
<li><strong>switch</strong> 语句中的 <strong>expression</strong> 必须是一个<strong>整型或枚举类型</strong>，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。</li>
<li>在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。</li>
<li>case 的 <strong>constant-expression</strong> 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。</li>
<li>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 <strong>break</strong> 语句为止。</li>
<li>当遇到 <strong>break</strong> 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</li>
<li>不是每一个 case 都需要包含 <strong>break</strong>。如果 case 语句不包含 <strong>break</strong>，控制流将会 <em>继续</em> 后续的 case，直到遇到 break 为止。</li>
<li>一个 <strong>switch</strong> 语句可以有一个可选的 <strong>default</strong> case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 <strong>break</strong> 语句不是必需的。</li>
</ul>
<p>一个例子🌰</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main ()
{
   // 局部变量声明
   char grade = 'D';

   switch(grade)
   {
   case 'A' :
      cout &lt;&lt; &quot;很棒！&quot; &lt;&lt; endl; 
      break;
   case 'B' :
   case 'C' :
      cout &lt;&lt; &quot;做得好&quot; &lt;&lt; endl;
      break;
   case 'D' :
      cout &lt;&lt; &quot;您通过了&quot; &lt;&lt; endl;
      break;
   case 'F' :
      cout &lt;&lt; &quot;最好再试一下&quot; &lt;&lt; endl;
      break;
   default :
      cout &lt;&lt; &quot;无效的成绩&quot; &lt;&lt; endl;
   }
   cout &lt;&lt; &quot;您的成绩是 &quot; &lt;&lt; grade &lt;&lt; endl;
 
   return 0;
}
</code></pre>
<p>同样的，switch语句也可以被嵌套使用</p>
<p>C++ 中 <strong>嵌套 switch</strong> 语句的语法：</p>
<pre><code class="language-C++">switch(ch1) {
   case 'A': 
      cout &lt;&lt; &quot;这个 A 是外部 switch 的一部分&quot;;
      switch(ch2) {
         case 'A':
            cout &lt;&lt; &quot;这个 A 是内部 switch 的一部分&quot;;
            break;
         case 'B': // 内部 B case 代码
      }
      break;
   case 'B': // 外部 B case 代码
}
</code></pre>
<h4 id="2--运算符"><a class="header" href="#2--运算符">2、? : 运算符</a></h4>
<p>我们已经在前面的章节中讲解了 <a href="https://www.w3cschool.cn/cpp/cpp-conditional-operator.html"><strong>条件运算符 ? :</strong></a>，可以用来替代 <strong>if...else</strong> 语句。它的一般形式如下：</p>
<pre><code>Exp1 ? Exp2 : Exp3;
</code></pre>
<p>其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</p>
<p>? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。</p>
<p>一个例子🌰</p>
<pre><code class="language-C++">//if-else写法
if(a&lt;10){
  var=10
}
else{
  var=20
}

//expression写法
var = (a&lt;10)?10:20;
</code></pre>
<h2 id="c-函数"><a class="header" href="#c-函数">C++ 函数</a></h2>
<p>函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 <strong>main()</strong> ，所有简单的程序都可以定义其他额外的函数。</p>
<p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p>
<p>函数<strong>声明</strong>告诉编译器函数的名称、返回类型和参数。函数<strong>定义</strong>提供了函数的实际主体。</p>
<p>C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 <strong>strcat()</strong> 用来连接两个字符串，函数 <strong>memcpy()</strong> 用来复制内存到另一个位置。</p>
<p>函数还有很多叫法，比如方法、子例程或程序，等等。</p>
<h4 id="1函数定义"><a class="header" href="#1函数定义">1、函数定义</a></h4>
<p>C++ 中的函数定义的一般形式如下：</p>
<p>⭐️ 定义函数时注意不要从主函数main()内部定义，只能从主函数体内部调用</p>
<blockquote>
<p>return_type funcition_name ( parameter_list )</p>
<p>{</p>
<p>​	body of the function </p>
<p>}</p>
</blockquote>
<p>在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：</p>
<ul>
<li>**返回类型：**一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li>
<li>**函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>
<li>**参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>
<li>**函数主体：**函数主体包含一组定义函数执行任务的语句。</li>
</ul>
<p>一个例子🌰</p>
<p>以下是 <strong>max()</strong> 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：</p>
<pre><code class="language-C++">// 函数返回两个数中较大的那个数
 
int max(int num1, int num2) 
{
   // 局部变量声明
   int result;
 
   if (num1 &gt; num2)
      result = num1;
   else
      result = num2;
 
   return result; 
}
</code></pre>
<p><strong>Tips</strong>📢：在函数变量定义时也可以添加形参的默认值，以后在使用的使用可以不赋值直接用，跟python中的使用方法一样。</p>
<h4 id="2函数声明"><a class="header" href="#2函数声明">2、函数声明</a></h4>
<p>函数<strong>声明</strong>会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<p>函数声明包括以下几个部分：</p>
<pre><code>return_type function_name( parameter list );
</code></pre>
<p>针对上面定义的函数 max()，以下是函数声明：</p>
<pre><code>int max(int num1, int num2);
</code></pre>
<p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：</p>
<pre><code>int max(int, int);
</code></pre>
<p>⭐️<strong>当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。也就是相当于python中的import函数，或者是相当于从其他文件中引用变量的extern函数</strong>⭐️</p>
<blockquote>
<p>也就是说使用到函数声明的时候一共有两种情况：</p>
<ul>
<li>因为代码是从上到下执行的，如果先定义后引用函数则不需要声明，反之如果先应用而函数定义部分在后面时则需要在文件开头添加函数声明部分</li>
<li>第二种情况，在某个文件中定义了函数后，想要在另一个文件中引用这个函数，则需要在这个文件的开头部分添加函数声明，也就类比与python中的import函数</li>
</ul>
</blockquote>
<h4 id="3函数参数"><a class="header" href="#3函数参数">3、函数参数</a></h4>
<p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p>
<p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>
<p>当调用函数时，有两种向函数传递参数的方式：</p>
<table><thead><tr><th align="center">调用类型</th><th align="left">描述</th></tr></thead><tbody>
<tr><td align="center"><a href="https://www.w3cschool.cn/cpp/cpp-function-call-by-value.html">传值调用</a>                     （默认）</td><td align="left">该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td></tr>
<tr><td align="center"><a href="https://www.w3cschool.cn/cpp/cpp-function-call-by-pointer.html">指针调用</a></td><td align="left">该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。<strong>这意味着，修改形式参数会影响实际参数。</strong></td></tr>
<tr><td align="center"><a href="https://www.w3cschool.cn/cpp/cpp-function-call-by-reference.html">引用调用</a></td><td align="left">该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。<strong>这意味着，修改形式参数会影响实际参数。</strong></td></tr>
</tbody></table>
<p>一个例子🌰</p>
<pre><code class="language-C++">// 函数定义
								//第一种
/////////////////引用形式/////////////////
void swap(int x, int y)
{
   int temp;

   temp = x; /* 保存 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 x 赋值给 y */
  
   return;
}
/////////////////////////////////////////
								
								//第二种
/////////////////指针形式/////////////////
void swap(int *x, int *y)
{
   int temp;
   temp = *x;	/* 保存地址 x 的值 */
   *x = *y;		/* 把 y 赋值给 x */
   *y = temp;	/* 把 x 赋值给 y */
  
   return;
}
/////////////////////////////////////////

								//第三种
/////////////////引用形式/////////////////
// 函数定义
void swap(int &amp;x, int &amp;y)
{
   int temp;
   temp = x; /* 保存地址 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 x 赋值给 y  */
  
   return;
}

#include &lt;iostream&gt;
using namespace std;
 
int main ()
{
   // 局部变量声明
   int a = 100;
   int b = 200;
 
   cout &lt;&lt; &quot;交换前，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   cout &lt;&lt; &quot;交换前，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;
 
   // 调用函数来交换值
   swap(a, b);
 
   cout &lt;&lt; &quot;交换后，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   cout &lt;&lt; &quot;交换后，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;
 
   return 0;
}
////////////////////运行结果(传值）///////////////////////
交换前，a 的值： 100
交换前，b 的值： 200
交换后，a 的值： 100
交换后，b 的值： 200
📢：从这可以看出，局部变量在函数呗执行完之后就被销毁了，未对外部全局变量产生影响

////////////////////运行结果(指针和引用）///////////////////////
交换前，a 的值： 100
交换前，b 的值： 200
交换后，a 的值： 200
交换后，b 的值： 100
📢：从这可以看出，局部变量在函数呗执行完之后就被销毁了，未对外部全局变量产生影响
</code></pre>
<h2 id="c-数字"><a class="header" href="#c-数字">C++ 数字</a></h2>
<p>通常，当我们需要用到数字时，我们会使用原始的数据类型，如 <strong>int、short、long、float 和 double</strong> 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 C++ 数据类型一章中讨论过。</p>
<h4 id="1c定义数字"><a class="header" href="#1c定义数字">1、C++定义数字</a></h4>
<p>我们已经在之前章节的各种实例中定义过数字。下面是一个 C++ 中定义各种类型数字的综合实例：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main ()
{
   // 数字定义
   short  s;
   int    i;
   long   l;
   float  f;
   double d;
   
   // 数字赋值
   s = 10;      
   i = 1000;    
   l = 1000000; 
   f = 230.47;  
   d = 30949.374;
   
   // 数字输出
   cout &lt;&lt; &quot;short  s :&quot; &lt;&lt; s &lt;&lt; endl;
   cout &lt;&lt; &quot;int    i :&quot; &lt;&lt; i &lt;&lt; endl;
   cout &lt;&lt; &quot;long   l :&quot; &lt;&lt; l &lt;&lt; endl;
   cout &lt;&lt; &quot;float  f :&quot; &lt;&lt; f &lt;&lt; endl;
   cout &lt;&lt; &quot;double d :&quot; &lt;&lt; d &lt;&lt; endl;
 
   return 0;
}

/* 结果输出
short  s :10
int    i :1000
long   l :1000000
float  f :230.47
double d :30949.4*/
</code></pre>
<h4 id="2c数学运算"><a class="header" href="#2c数学运算">2、C++数学运算</a></h4>
<p>在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做<strong>内置函数</strong>。您可以在程序中引用这些函数。</p>
<p>C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。</p>
<p>为了利用这些函数，您需要引用数学头文件 ==<strong><cmath></strong>==。</p>
<table><thead><tr><th align="center">序号</th><th align="left">函数 &amp; 描述</th></tr></thead><tbody>
<tr><td align="center">1</td><td align="left"><strong>double cos(double);</strong> 该函数返回弧度角（double 型）的余弦。</td></tr>
<tr><td align="center">2</td><td align="left"><strong>double sin(double);</strong> 该函数返回弧度角（double 型）的正弦。</td></tr>
<tr><td align="center">3</td><td align="left"><strong>double tan(double);</strong> 该函数返回弧度角（double 型）的正切。</td></tr>
<tr><td align="center">4</td><td align="left"><strong>double log(double);</strong> 该函数返回参数的自然对数。</td></tr>
<tr><td align="center">5</td><td align="left"><strong>double pow(double, double);</strong> 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。</td></tr>
<tr><td align="center">6</td><td align="left"><strong>double hypot(double, double);</strong> 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。</td></tr>
<tr><td align="center">7</td><td align="left"><strong>double sqrt(double);</strong> 该函数返回参数的平方根。</td></tr>
<tr><td align="center">8</td><td align="left"><strong>int abs(int);</strong> 该函数返回整数的绝对值。</td></tr>
<tr><td align="center">9</td><td align="left"><strong>double fabs(double);</strong> 该函数返回任意一个十进制数的绝对值。</td></tr>
<tr><td align="center">10</td><td align="left"><strong>double floor(double);</strong> 该函数返回一个小于或等于传入参数的最大整数。</td></tr>
</tbody></table>
<h4 id="3c随机数"><a class="header" href="#3c随机数">3、C++随机数</a></h4>
<p>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 <strong>rand()</strong>，该函数只返回一个伪随机数。生成随机数之前必须先调用 <strong>srand()</strong> 函数。</p>
<p>下面是一个关于生成随机数的简单实例。实例中使用了 <strong>time()</strong> 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;

using namespace std;
 
int main ()
{
   int i,j;
 
   // 设置种子
   srand( (unsigned)time( NULL ) );

   /* 生成 10 个随机数 */
   for( i = 0; i &lt; 10; i++ )
   {
      // 生成实际的随机数
      j= rand();
      cout &lt;&lt;&quot;随机数： &quot; &lt;&lt; j &lt;&lt; endl;
   }

   return 0;
} 
</code></pre>
<h2 id="c-数组"><a class="header" href="#c-数组">C++ 数组</a></h2>
<p>C++ 支持<strong>数组</strong>数据结构，它可以存储一个<strong>固定大小的相同类型</strong>元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</p>
<p>所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p>
<h4 id="1声明数组"><a class="header" href="#1声明数组">1、声明数组</a></h4>
<p>在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p>
<pre><code class="language-C++">type arrayName [ arraySize ];
</code></pre>
<p>这叫做一维数组。<strong>arraySize</strong> 必须是一个大于零的整数常量，<strong>type</strong> 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 <strong>balance</strong>，声明语句如下：</p>
<pre><code class="language-C++">double balance[10];
</code></pre>
<h4 id="2初始化数组"><a class="header" href="#2初始化数组">2、初始化数组</a></h4>
<p>在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：</p>
<pre><code class="language-c">double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
</code></pre>
<p>大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。</p>
<p>如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：</p>
<pre><code class="language-C++">double balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0};
</code></pre>
<p>下面这个例子包含了数组声明、赋值、访问的流程</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
#include &lt;iomanip&gt;
using std::setw;
 
int main ()
{
   int n[ 10 ]; // n 是一个包含 10 个整数的数组
 
   // 初始化数组元素          
   for ( int i = 0; i &lt; 10; i++ )
   {
      n[ i ] = i + 100; // 设置元素 i 为 i + 100
   }
   cout &lt;&lt; &quot;Element&quot; &lt;&lt; setw( 13 ) &lt;&lt; &quot;Value&quot; &lt;&lt; endl;
 
   // 输出数组中每个元素的值                     
   for ( int j = 0; j &lt; 10; j++ )
   {
      cout &lt;&lt; setw( 7 )&lt;&lt; j &lt;&lt; setw( 13 ) &lt;&lt; n[ j ] &lt;&lt; endl;
   }
 
   return 0;
}
</code></pre>
<blockquote>
<p>可以看到，数组初始化需要挨个设置，也无法跟python一样直接输出数组，而是需要用循环打印每个元素。</p>
</blockquote>
<h4 id="3多维数组"><a class="header" href="#3多维数组">3、多维数组</a></h4>
<p>同样的，C++也可以类似python创建多维数组，具体格式要求如下：</p>
<p>C++ 支持多维数组。多维数组声明的一般形式如下：</p>
<pre><code class="language-c++">type name[size1][size2]...[sizeN];
</code></pre>
<p>例如，下面的声明创建了一个三维 5 . 10 . 4 整型数组：</p>
<pre><code class="language-C++">int threedim[5][10][4];
</code></pre>
<p><strong>初始化二维数组的两种方法</strong></p>
<ul>
<li>多维数组可以通过在括号内为每行指定值来进行初始化。下面是一个带有 3 行 4 列的数组。</li>
</ul>
<pre><code class="language-C++">int a[3][4] = {  
 {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */
 {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */
 {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */
};
</code></pre>
<ul>
<li>内部嵌套的括号是可选的，下面的初始化与上面是等同的：</li>
</ul>
<pre><code class="language-C++">int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
</code></pre>
<p>一个例子🌰</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
//二维数组的定义及输出
int main ()
{
   // 一个带有 5 行 2 列的数组
   int a[5][2] = { {0,0}, {1,2}, {2,4}, {3,6},{4,8}};
 
   // 输出数组中每个元素的值                      
   for ( int i = 0; i &lt; 5; i++ )
      for ( int j = 0; j &lt; 2; j++ )
      {
         cout &lt;&lt; &quot;a[&quot; &lt;&lt; i &lt;&lt; &quot;][&quot; &lt;&lt; j &lt;&lt; &quot;]: &quot;;
         cout &lt;&lt; a[i][j]&lt;&lt; endl;
      }
 
   return 0;
}
</code></pre>
<h4 id="c-中数组其他相关内容详解"><a class="header" href="#c-中数组其他相关内容详解">C++ 中数组其他相关内容详解</a></h4>
<p>在 C++ 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C++ 程序员必须清楚的一些与数组相关的重要概念：</p>
<table><thead><tr><th align="left">概念</th><th align="left">描述</th></tr></thead><tbody>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-multi-dimensional-arrays.html">多维数组</a></td><td align="left">C++ 支持多维数组。多维数组最简单的形式是二维数组。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-pointer-to-an-array.html">指向数组的指针</a></td><td align="left">您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-passing-arrays-to-functions.html">传递数组给函数</a></td><td align="left">您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-return-arrays-from-function.html">从函数返回数组</a></td><td align="left">C++ 允许从函数返回数组。</td></tr>
</tbody></table>
<ul>
<li>后三个内容需要学习完指针内容后才可以理解，因此此处先搁置占位</li>
</ul>
<h2 id="c-字符串"><a class="header" href="#c-字符串">C++ 字符串</a></h2>
<p>C++ 提供了以下两种类型的字符串表示形式：</p>
<ul>
<li>C 风格字符串</li>
<li>C++ 引入的 string 类类型</li>
</ul>
<h4 id="1c风格字符串"><a class="header" href="#1c风格字符串">1、C风格字符串</a></h4>
<p>C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。<strong>字符串实际上是使用 null 字符 终止的一维字符数组</strong>。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>
<p>下面的声明和初始化创建了一个 &quot;Hello&quot; 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 &quot;Hello&quot; 的字符数多一个。char greeting[6] = {'H', 'e', 'l', 'l', 'o', ''};</p>
<p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p>
<pre><code>char greeting[] = &quot;Hello&quot;;
</code></pre>
<p><img src="C++%E5%AD%A6%E4%B9%A0/C++.media/string_representation.jpg" alt="C/C++ 中的字符串表示" /></p>
<p>其实，您不需要把 <em>null</em> 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 '' 放在字符串的末尾。让我们尝试输出上面的字符串</p>
<pre><code class="language-c">#include &lt;iostream&gt;

using namespace std;

int main ()
{
   char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'};

   cout &lt;&lt; &quot;Greeting message: &quot;;
   cout &lt;&lt; greeting &lt;&lt; endl;

   return 0;
} 
</code></pre>
<p>C++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings:</p>
<table><thead><tr><th align="left">序号</th><th align="left">函数 &amp; 目的</th></tr></thead><tbody>
<tr><td align="left">1</td><td align="left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td></tr>
<tr><td align="left">2</td><td align="left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td></tr>
<tr><td align="left">3</td><td align="left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td></tr>
<tr><td align="left">4</td><td align="left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td></tr>
<tr><td align="left">5</td><td align="left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr>
<tr><td align="left">6</td><td align="left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr>
</tbody></table>
<p>下面的实例使用了上述的一些函数：</p>
<pre><code class="language-c">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

int main ()
{
   char str1[11] = &quot;Hello&quot;;
   char str2[11] = &quot;World&quot;;
   char str3[11];
   int  len ;

   // 复制 str1 到 str3
   strcpy( str3, str1);
   cout &lt;&lt; &quot;strcpy( str3, str1) : &quot; &lt;&lt; str3 &lt;&lt; endl;

   // 连接 str1 和 str2
   strcat( str1, str2);
   cout &lt;&lt; &quot;strcat( str1, str2): &quot; &lt;&lt; str1 &lt;&lt; endl;

   // 连接后，str1 的总长度
   len = strlen(str1);
   cout &lt;&lt; &quot;strlen(str1) : &quot; &lt;&lt; len &lt;&lt; endl;

   return 0;
}
</code></pre>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code class="language-c">strcpy( str3, str1) : Hello
strcat( str1, str2): HelloWorld
strlen(str1) : 10
</code></pre>
<h2 id="c-中的-string-类"><a class="header" href="#c-中的-string-类">C++ 中的 String 类</a></h2>
<p>C++ 标准库提供了 <strong>string</strong> 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：</p>
<p>现在您可能还无法透彻地理解这个实例，因为到目前为止我们还没有讨论类和对象。所以现在您可以只是粗略地看下这个实例，等理解了面向对象的概念之后再回头来理解这个实例。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt; //这里需要引入string这个模块

using namespace std;

int main ()
{
   string str1 = &quot;Hello&quot;; //建立string类型的字符串，在这里类似于类的实例化，后续字符串操作类似于python中的操作
   string str2 = &quot;World&quot;;
   string str3;
   int  len ;

   // 复制 str1 到 str3
   str3 = str1;
   cout &lt;&lt; &quot;str3 : &quot; &lt;&lt; str3 &lt;&lt; endl;

   // 连接 str1 和 str2
   str3 = str1 + str2;
   cout &lt;&lt; &quot;str1 + str2 : &quot; &lt;&lt; str3 &lt;&lt; endl;

   // 连接后，str3 的总长度
   len = str3.size();
   cout &lt;&lt; &quot;str3.size() :  &quot; &lt;&lt; len &lt;&lt; endl;

   return 0;
} 
</code></pre>
<h2 id="c-指针"><a class="header" href="#c-指针">C++ 指针⭐️⭐️</a></h2>
<p>学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。</p>
<p>正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;

int main ()
{
   int  var1;
   char var2[10];

   cout &lt;&lt; &quot;var1 变量的地址： &quot;;
   cout &lt;&lt; &amp;var1 &lt;&lt; endl;

   cout &lt;&lt; &quot;var2 变量的地址： &quot;;
   cout &lt;&lt; &amp;var2 &lt;&lt; endl;

   return 0;
}
</code></pre>
<h4 id="什么是指针"><a class="header" href="#什么是指针">什么是指针？</a></h4>
<p><strong>指针</strong>是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，==您必须在使用指针存储其他变量地址之前，对其进行声明==。指针变量声明的一般形式为：</p>
<pre><code class="language-C">type *var-name;
</code></pre>
<p>在这里，<strong>type</strong> 是指针的基类型，它必须是一个有效的 C++ 数据类型，<strong>var-name</strong> 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：</p>
<pre><code class="language-C++">int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch     /* 一个字符型的指针 */
</code></pre>
<p>所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。<strong>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</strong></p>
<p>⭐️使用**&amp;<strong>符号来访问变量的地址，使用</strong>***来访问指针对应的具体值。⭐️</p>
<table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody>
<tr><td>&amp;</td><td>取地址</td></tr>
<tr><td>*</td><td>解引用</td></tr>
</tbody></table>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;

int main ()
{
   int  var = 20;   // 实际变量的声明
   int  *ip;        // 指针变量的声明

   ip = &amp;var;       // 在指针变量中存储 var 的地址

   cout &lt;&lt; &quot;Value of var variable: &quot;;
   cout &lt;&lt; var &lt;&lt; endl;

   // 输出在指针变量中存储的地址
   cout &lt;&lt; &quot;Address stored in ip variable: &quot;;
   cout &lt;&lt; ip &lt;&lt; endl;

   // 访问指针中地址的值
   cout &lt;&lt; &quot;Value of *ip variable: &quot;;
   cout &lt;&lt; *ip &lt;&lt; endl;

   return 0;
}

/* 输出结果
Value of var variable: 20
Address stored in ip variable: 0xbfc601ac
Value of *ip variable: 20
*/
</code></pre>
<h4 id="c-null指针"><a class="header" href="#c-null指针">C++ NULL指针</a></h4>
<p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为<strong>空</strong>指针。</p>
<p>NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;

int main ()
{
   int  *ptr = NULL;

   cout &lt;&lt; &quot;ptr 的值是 &quot; &lt;&lt; ptr ;
 
   return 0;
}
//程序输出的结果为：
//ptr 的值是0!
</code></pre>
<p>​	在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。<strong>如果所有未使用的指针都被赋予空值，同时避免使用空指针，就可以防止误用一个未初始化的指针。很多时候，未初始化的变量存有一些垃圾值，导致程序难以调试。</strong>（也就是在定义变量的时候最好初始化不要定义个空的，否则有可能造成意外错误）</p>
<h4 id="c-指针的算术运算"><a class="header" href="#c-指针的算术运算">C++ 指针的算术运算</a></h4>
<p>指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、-</p>
<p>假设 <strong>ptr</strong> 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：</p>
<pre><code>ptr++
</code></pre>
<p>在执行完上述的运算之后，<strong>ptr</strong> 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 个字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 <strong>ptr</strong> 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。</p>
<h5 id="1递增一个指针"><a class="header" href="#1递增一个指针">1、<strong>递增一个指针</strong></a></h5>
<p>我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，因为数组是一个常量指针。下面的程序递增变量指针，以便顺序访问数组中的每一个元素：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;
const int MAX = 3;

int main ()
{
   int  var[MAX] = {10, 100, 200};
   int  *ptr;

   // 指针中的数组地址
   ptr = var; //这里var代表的是数组第一个变量的地址，因此后续才可以用地址递增访问变量值
   for (int i = 0; i &lt; MAX; i++)
   {
      cout &lt;&lt; &quot;Address of var[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
      cout &lt;&lt; ptr &lt;&lt; endl;

      cout &lt;&lt; &quot;Value of var[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
      cout &lt;&lt; *ptr &lt;&lt; endl;

      // 移动到下一个位置
      ptr++;
   }
   return 0;
}

</code></pre>
<h5 id="2递减一个指针"><a class="header" href="#2递减一个指针">2、递减一个指针</a></h5>
<p>同样地，对指针进行递减运算，即把值减去其数据类型的字节数，如下所示：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;
const int MAX = 3;

int main ()
{
   int  var[MAX] = {10, 100, 200};
   int  *ptr;

   // 指针中最后一个元素的地址
   ptr = &amp;var[MAX-1];//与前一种情况不同的是，这里指针直接指向数组最后一个元素，倒着往前访问
   for (int i = MAX; i &gt; 0; i--)
   {
      cout &lt;&lt; &quot;Address of var[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
      cout &lt;&lt; ptr &lt;&lt; endl;

      cout &lt;&lt; &quot;Value of var[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
      cout &lt;&lt; *ptr &lt;&lt; endl;

      // 移动到下一个位置
      ptr--;
   }
   return 0;
}
</code></pre>
<h5 id="3指针的比较"><a class="header" href="#3指针的比较"><strong>3、指针的比较</strong></a></h5>
<p>指针可以用关系运算符进行比较，如 ==、&lt; 和 &gt;。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。</p>
<p>下面的程序修改了上面的实例，只要变量指针所指向的地址小于或等于数组的最后一个元素的地址 &amp;var[MAX - 1]，则把变量指针进行递增：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;
const int MAX = 3;

int main ()
{
   int  var[MAX] = {10, 100, 200};
   int  *ptr;

   // 指针中第一个元素的地址,数组中元素越靠后对应的指针值越大
   ptr = var;
   int i = 0;
   while ( ptr &lt;= &amp;var[MAX - 1] )
   {
      cout &lt;&lt; &quot;Address of var[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
      cout &lt;&lt; ptr &lt;&lt; endl;

      cout &lt;&lt; &quot;Value of var[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
      cout &lt;&lt; *ptr &lt;&lt; endl;

      // 指向上一个位置
      ptr++;
      i++;
   }
   return 0;
}

</code></pre>
<h4 id="c指针vs数组"><a class="header" href="#c指针vs数组">C++指针VS数组</a></h4>
<p>​	指针和数组是密切相关的。事实上，指针和数组在很多情况下是可以互换的。例如，一个指向数组开头的指针，<strong>可以通过使用指针的算术运算或数组索引来访问数组</strong>。类似于上文中举例的使用指针访问数组中元素的具体数值。==指针就类似于数组的索引==</p>
<p>但是！！，数组和指针并不是完全相等可以无条件交换的！！！</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
 
using namespace std;
const int MAX = 3;
 
int main ()
{
   int  var[MAX] = {10, 100, 200};
 
   for (int i = 0; i &lt; MAX; i++)
   {
      *var = i;    // 这是正确的语法,
      var++;       // 这是不正确的 这是因为在这里var是一个指针常量，如果想要改变他时则编译器就会自动报错
   }
   return 0;
}
</code></pre>
<h4 id="c指针数组"><a class="header" href="#c指针数组">C++指针数组</a></h4>
<p>数组除了可以储存int,char等类别外，同样可以储存指针类型</p>
<p>下面是一个指向整数的指针数组的声明：</p>
<pre><code class="language-C++">int *ptr[MAX];
</code></pre>
<p>在这里，把 <strong>ptr</strong> 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。下面的实例用到了三个整数，它们将存储在一个指针数组中，如下所示:</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
 
using namespace std;
const int MAX = 3;
 
int main ()
{
   int  var[MAX] = {10, 100, 200};
   int *ptr[MAX];
 
   for (int i = 0; i &lt; MAX; i++)
   {
      ptr[i] = &amp;var[i]; // 赋值为整数的地址
   }
   for (int i = 0; i &lt; MAX; i++)
   {
      cout &lt;&lt; &quot;Value of var[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
      cout &lt;&lt; *ptr[i] &lt;&lt; endl;
   }
   return 0;
}

</code></pre>
<p>也可以用一个指向字符的指针数组来存储一个字符串列表，如下：</p>
<pre><code class="language-C++">const char *names[4] = {
                   &quot;Zara Ali&quot;,
                   &quot;Hina Ali&quot;,
                   &quot;Nuha Ali&quot;,
                   &quot;Sara Ali&quot;,}
////////此外，还有定义字符串列表的另一种方法
char names[4] = {
                   'a',
                   'b',
                   'c',
                   'd',}//此时不能储存字符串，只能储存单个的字母
</code></pre>
<h5 id="c-指向指针的指针多级间接寻址"><a class="header" href="#c-指向指针的指针多级间接寻址">C++ 指向指针的指针（多级间接寻址）</a></h5>
<p>指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。</p>
<p>一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：</p>
<pre><code class="language-C++">int **var;	
//同样的，为了解析指针储存的变量值，需要使用两个**来进行解耦
</code></pre>
<pre><code class="language-C++">#include &lt;iostream&gt;
 
using namespace std;
 
int main ()
{
   int  var;
   int  *ptr;
   int  **pptr;

   var = 3000;

   // 获取 var 的地址
   ptr = &amp;var;

   // 使用运算符 &amp; 获取 ptr 的地址
   pptr = &amp;ptr;

   // 使用 pptr 获取值
   cout &lt;&lt; &quot;Value of var :&quot; &lt;&lt; var &lt;&lt; endl;
   cout &lt;&lt; &quot;Value available at *ptr :&quot; &lt;&lt; *ptr &lt;&lt; endl;
   cout &lt;&lt; &quot;Value available at **pptr :&quot; &lt;&lt; **pptr &lt;&lt; endl;

   return 0;
}
// 就是个指针的嵌套
</code></pre>
<h5 id="c-传递指针给函数"><a class="header" href="#c-传递指针给函数">C++ 传递指针给函数</a></h5>
<p>C++ 允许您传递指针给函数，只需要简单地声明函数参数为指针类型即可。</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;ctime&gt;
 
using namespace std;
void getSeconds(unsigned long *par);

int main ()
{
   unsigned long sec;


   getSeconds( &amp;sec );

   // 输出实际值
   cout &lt;&lt; &quot;Number of seconds :&quot; &lt;&lt; sec &lt;&lt; endl;

   return 0;
}

void getSeconds(unsigned long *par)
{
   // 获取当前的秒数
   *par = time( NULL );
   return;
}
//返回值
Number of seconds :1294450468
</code></pre>
<p>能接受指针作为参数的函数，也能接受数组作为参数，如下所示：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
// 函数声明
double getAverage(int *arr, int size);
 
int main ()
{
   // 带有 5 个元素的整型数组
   int balance[5] = {1000, 2, 3, 17, 50};
   double avg;
 
   // 传递一个指向数组的指针作为参数
   avg = getAverage( balance, 5 ) ;
 
   // 输出返回值
   cout &lt;&lt; &quot;Average value is: &quot; &lt;&lt; avg &lt;&lt; endl; 
    
   return 0;
}

double getAverage(int *arr, int size)
{
  int    i, sum = 0;       
  double avg;          
 
  for (i = 0; i &lt; size; ++i)
  {
    sum += arr[i];
   }
 
  avg = double(sum) / size;
 
  return avg;
}

</code></pre>
<p>数组≈指针，但是指针的概念要大于数组，指针比数组更加灵活</p>
<h5 id="c-从函数返回指针数组"><a class="header" href="#c-从函数返回指针数组">C++ 从函数返回指针/数组</a></h5>
<p>C++ 不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针</p>
<pre><code class="language-C++">int * myFunction()
{
.
.
.
}

</code></pre>
<p><strong>另外，C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。</strong></p>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;ctime&gt;
 
using namespace std;
 
// 要生成和返回随机数的函数
int * getRandom( )
{
  static int  r[10];//⭐️在这里！！！！，要用static，否则虽然函数会生成r，但是在函数执行完毕后就会被销毁，这时返回的指针不能正确指示数组的情况✅
 
  // 设置种子
  srand( (unsigned)time( NULL ) );
  for (int i = 0; i &lt; 10; ++i)
  {
    r[i] = rand();
    cout &lt;&lt; r[i] &lt;&lt; endl;
  }
 
  return r;
}
 
// 要调用上面定义函数的主函数
int main ()
{
   // 一个指向整数的指针
   int *p;
 
   p = getRandom();
   for ( int i = 0; i &lt; 10; i++ )
   {
       cout &lt;&lt; &quot;*(p + &quot; &lt;&lt; i &lt;&lt; &quot;) : &quot;;
       cout &lt;&lt; *(p + i) &lt;&lt; endl;
   }
 
   return 0;
}

</code></pre>
<h2 id="c-指针总结及相关容易混淆概念"><a class="header" href="#c-指针总结及相关容易混淆概念">C++ 指针总结及相关容易混淆概念</a></h2>
<h4 id="一内存和地址"><a class="header" href="#一内存和地址"><strong>一，内存和地址</strong></a></h4>
<p>我们知道，计算机内存的每个字节都有一个唯一的地址，CPU每次寻址就是通过固定的步长（这就解释了为什么需要内存对齐）来跳跃进行寻址的。举个例子，我们可以把内存看做是一条长街上的一排房屋，每个房屋都有自己固定的门牌号，每座房屋里面都可以容纳数据，为了读取到某个房屋里面的数据，我们必须知道这个房屋的门牌号，根据这个门牌号来打开这个房间，取走数据。同样，计算机也必须为每个内存字节都编上号码，就像门牌号一样，每个字节的编号是唯一的，根据编号可以准确地找到某个字节。</p>
<h4 id="二指针的本质就是地址"><a class="header" href="#二指针的本质就是地址"><strong>二，指针的本质就是地址</strong></a></h4>
<p>当我们在程序中声明一个变量并给这个变量赋值的时候，编译器做了什么呢？实际上，变量名代表内存中的一个存储单元，在编译器对程序编译连接的时候由系统给变量分配一个地址：</p>
<pre><code class="language-cpp">int a = 10;
</code></pre>
<p>上面这行代码我们定义并初始化了这个变量a，系统会为a分配一块内存单元，a只是这块内存单元的别名，在程序中从变量中取值，实际上是通过变量名找到相应的内存单元，从其中读取数据。</p>
<img src="C++学习/C++.media/v2-94eddad728ee414bc95200bbe9334cca_720w-9098341.jpg" alt="img" style="zoom:67%;" />
<p>假如系统为变量 a 分配的内存地址为0xFF00, 那么我们可以说这个地址就是变量 a 的门牌号。<strong>一个变量的地址称为该变量的指针</strong>。所以说，<strong>指针的本质就是地址，指针变量是一种特殊的变量，它专门保存指针(也即地址)，当我们说这个地址对应的内存单元的时候，我们可以说这个指针指向这块内存单元。</strong></p>
<p>例如：</p>
<pre><code class="language-cpp">int a = 10;  
int* p = &amp;a;  //定义指针变量 p
*p = 20;      //将指针p指向的值修改为 20
</code></pre>
<ul>
<li>上面两行代码中，我们首先定义了一个整型变量 a ,- </li>
<li>然后又定义了一个指针变量 p 指向 a .第二行代码中，符号&amp;代表取地址，相当于把变量a的地址赋值给了指针变量p(p指向a)，- </li>
<li>加在指针变量前面代表解引用，意思找到指针p指向的值，因此，第三行代码的意思就是讲p指向的值也就是a修改为20.<strong>总之一定要记住，符号&amp;代表取值，符号⭐️代表解引用。</strong></li>
</ul>
<table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody>
<tr><td>&amp;</td><td>取地址</td></tr>
<tr><td>*</td><td>解引用</td></tr>
</tbody></table>
<p>这三行代码的内存模型如下：</p>
<p><img src="C++%E5%AD%A6%E4%B9%A0/C++.media/v2-c5ca0796ded98350603aed46799cdffa_720w.jpg" alt="img" /></p>
<p>我们假设系统给变量 a 分配的内存首地址为2000，我们又声明了一个指针变量p，<strong>这个p也是要占用内存空间的</strong>，只不过这个变量p保存的内容是变量a的地址，也就是2000，当我们想通过p来操纵a的话，首先要根据p保存的地址找到它指向的内容，也就是解引用<em>p，当</em>p的内容放生改变的时候，首地址为2000的内存单元存储的值也会做出改变，因此变量当*p被重新赋值为20的时候，变量a的值也会做出改变，变为20.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;ctime&gt;
 
using namespace std;
// 要调用上面定义函数的主函数
int main ()
{
   // 一个指向整数的指针
   int a = 3;
   int *p;
   p = &amp;a; 
   cout &lt;&lt; p &lt;&lt; endl;
   cout &lt;&lt; *p&lt;&lt; endl;
   cout &lt;&lt; &amp;p&lt;&lt; endl;

 
   return 0;
}
//输出结果
0x16f1874d4
3
0x16f1874c8
</code></pre>
<p>由此扩展到二级指针，如果我们再定义一个指针变量q来指向p，那么q就是一个二级指针，因为它指向的对象还是一个指针，只不过比他自己低一级，是一级指针,那么二级指针如何定义呢，请看下面的代码：</p>
<pre><code class="language-cpp">int a = 10;
int* p = &amp;a;
int** q = &amp;p; 
</code></pre>
<p>上面第三行代码就是定义了一个二级指针q，它指向的是一级指针p，而一级指针p又指向了变量a，它的内存模型如下图所示：</p>
<p><img src="C++%E5%AD%A6%E4%B9%A0/C++.media/v2-fe08bdfd089fc437adee0b6abaa70d93_720w.jpg" alt="img" /></p>
<p>二级指针q保存的内容为一级指针p的地址而非内容，注意p地址是2008，p的内容为2000. 因此对q进行解引用也即q得出的是p,也就是2008,再对(q)进行解引用也即(q)得出的才是变量a的值，由于运算符的结合性自右向左，因此括号可以省略，也即**q才是a的值。</p>
<h4 id="三一些容易混淆的重要内容"><a class="header" href="#三一些容易混淆的重要内容">三，一些容易混淆的重要内容</a></h4>
<h5 id="1常量指针与指针常量"><a class="header" href="#1常量指针与指针常量">1、常量指针与指针常量</a></h5>
<p>请看下面两行代码：</p>
<pre><code class="language-cpp">int a = 10; //const跟谁挨得近谁就是常量
const int * p1 = &amp;a;    //常量指针：指向常量的指针变量
int * const p2 = &amp;a;    //指针常量：指向变量的常量指针
</code></pre>
<p>上面第二行代码中的p1是一个常量指针，就是指向常量的指针变量。意味着它指向的值不可以修改，但是指针的指向可以修改：</p>
<pre><code class="language-cpp">int a = 10;
int b = 20;
const int * p1 = &amp;a;    //常量指针
*p1 = 100;  //错误，常量指针指向的值不可以修改
p1 = &amp;b;   //正确
</code></pre>
<p>而对于指针常量，它本质是一个常量，但是由指针修饰。意味着它指向的值可以修改，但是指针的指向不可修改，与常量指针刚刚相反：</p>
<pre><code class="language-cpp">int a = 10;
int b = 20;
int * const p1 = &amp;a;    //指针常量
*p1 = 100;  //正确
p1 = &amp;b;   //错误，指针的指向不可以修改
</code></pre>
<p><strong>对照表😀</strong></p>
<table><thead><tr><th>名称</th><th>意义</th><th>特点</th></tr></thead><tbody>
<tr><td>const int * p</td><td>常量指针</td><td>指向可修改，指向的值不可修改</td></tr>
<tr><td>int * const p</td><td>指针常量</td><td>指向不可修改，指向的值可修改</td></tr>
</tbody></table>
<h5 id="2指针与数组"><a class="header" href="#2指针与数组">2、指针与数组</a></h5>
<p>一维数组名本身就是一个指针，但是在使用的过程中要小心，因为这个指针分为指向数组首元素的指针与指向整个数组的指针，那么如何区分它们呢？我们来看下面几行代码：</p>
<pre><code class="language-cpp">int arr[] = {1, 2, 3, 4, 5};
int* p1 = arr;
int* p2 = &amp;arr[0]; //都是默认指向第一个值得地址
int* p3 = &amp;arr;    //报错
</code></pre>
<p>上面三行代码中，其中p1与p2是等价的，因为<strong>数组名arr本身就是一个指针</strong>，**但是这个指针不是指向整个数组，而是指向数组的首元素的地址。**第四行直接报错，因为&amp;arr指的是整个数组的指针，不能把数组指针赋值给整形指针。虽然arr与&amp;arr在数值上是相同的，但是两者意义不同。意味着&amp;arr它的步长为整个数组，而对于arr，步长为单个元素。</p>
<p>所以，我们得出结论，对于一维数组arr：</p>
<table><thead><tr><th>名称</th><th>意义</th><th>步长</th></tr></thead><tbody>
<tr><td>arr</td><td>指向数组首元素</td><td>单个元素</td></tr>
<tr><td>&amp;arr[0]</td><td>指向数组首元素</td><td>单个元素</td></tr>
<tr><td>&amp;arr</td><td>指向整个数组</td><td>整个数组</td></tr>
</tbody></table>
<p>在定义了指向数组首元素的指针变量后，我们可以通过这个指针变量来访问数组元素：</p>
<pre><code class="language-cpp"> int arr[] = { 1,2,3,4,5 };
  int* p1 = arr;
  int length = sizeof(arr) / sizeof(int);
  for (int i = 0; i &lt; length; i++)
  {
    cout &lt;&lt; p1[i] &lt;&lt; endl; //这里相当于把p1和arr直接画了等号
    cout &lt;&lt; *(p1 + i) &lt;&lt; endl; //这里则是使用解析引用返回数组中的数值
  }
</code></pre>
<p>上面几行代码中，p1[i]与*(p1+i)两者是等价的，所以输出的结果一样。但是要注意，当用sizeof操作符操作arr的时候，这个时候不能把arr当做一个指针来对待，因为sizeof操作数组的时候它返回的是数组的字节长度，而单个指针变量只占用四个字节。上面循环体中，我们也可以通过下面方式访问：</p>
<pre><code class="language-cpp">cout &lt;&lt; *p1++ &lt;&lt; endl;  
cout &lt;&lt; *(p1++) &lt;&lt; endl;
</code></pre>
<p><em>p1++与</em>(p1++)是等价的，这是因为++的运算符优先级比<em>要高，因此不管你加不加括号，都会优先执行p++，然而p++是先返回p的值，再与</em>结合，最后p再向后移动一位。</p>
<p>不过在这里要特别注意，有一种情况下我们是不能通过sizeof操作符来计算数组的长度的，就是当数组名作为函数参数传递的时候：</p>
<pre><code class="language-cpp">void test(int arr[])
{
  int lenth = sizeof(arr) / sizeof(int);
}
</code></pre>
<p>上面这行代码语法上没有问题，但是得出的结果却不是我们想要的结果，为什么呢，这是因为数组名作为函数传递的时候，会退化成一个指针，如果是二维数组的话，会退化成指向一维数组的指针，所以sizeof(arr)计算出来的结果就不是数组的字节长度了。所以说，在c/c++中传递数组的时候，一般我们也会把数组的长度作为形参传递过去。</p>
<p>但是我们不能通过下面方式去访问数组元素：</p>
<pre><code class="language-cpp">cout &lt;&lt; *arr++ &lt;&lt; endl;    //报错
</code></pre>
<p>这是因为arr本身是一个<strong>指针常量</strong>，指针的指向不可更改，因此编译器直接报错。</p>
<p><strong>3、数组指针与指针数组</strong></p>
<p>数组指针顾名思义，本质就是一个指针，这个指针指向整个数组；指针数组本质上是一个数组，但是数组的每个元素都是指针。</p>
<pre><code class="language-cpp">int (*p2)[10];  //数组指针
int *p1[10];    //指针数组
</code></pre>
<p>上面两行代码，p1是一个数组，而p2却是一个指针，它指向一个匿名数组。为什么是这样呢？这是因为[]的优先级比*要高。p1 先与[]结合，构成一个数组的定义，数组名为p1，int *修饰的是数组的内容，即数组的每个元素。那现在我们清楚，这是一个数组，其包含10 个指向int 类型数据的指针，即指针数组。至于p2 就更好理解了，在这里括号的优先级比[]高，*号和p2 构成一个指针的定义，指针变量名为p2，int 修饰的是数组的内容，即数组的每个元素。数组在这里并没有名字，是个匿名数组。那现在我们清楚p2 是一个指针，它指向一个包含10 个int 类型数据的数组，即数组指针。</p>
<p><img src="C++%E5%AD%A6%E4%B9%A0/C++.media/v2-0748696dcdccff7cd64082d2c53d6293_1440w-9105157.jpg" alt="img" /></p>
<p>p1为数组名，每个元素都是int型指针</p>
<p><img src="C++%E5%AD%A6%E4%B9%A0/C++.media/v2-30e1d5983c4feea1f2e8b2866f61c9da_1440w.jpg" alt="img" /></p>
<p>p2为指针变量，指向一个匿名数组</p>
<p>如果我们定义： </p>
<pre><code class="language-cpp">int(*p)[10] = &amp;arr;
</code></pre>
<p>那么如何访问数组的元素呢？且看，由于上行代码中，p=&amp;arr，那么对其解引用，*p就是arr，因此我们可以通过(*p)[]来进行访问数组的元素： </p>
<pre><code class="language-cpp">for(int i = 0; i &lt; 10; i++)
{
  cout&lt;&lt; (*p)[i] &lt;&lt; endl;
}
</code></pre>
<h5 id="4指针函数与函数指针"><a class="header" href="#4指针函数与函数指针"><strong>4、指针函数与函数指针</strong></a></h5>
<p>指针函数顾名思义，他是一个函数，但返回值是一个指针，例如下面这几行代码：</p>
<pre><code class="language-cpp">int* test()
{
  int a = 10;
  int* p = &amp;a;
  return p;
}
</code></pre>
<p>这个test就是一个指针函数，它返回的是一个int型的指针。</p>
<p>函数指针本质是一个指针，这个指针指向一个函数，那么我们如何定义函数指针呢？请看下面代码：</p>
<pre><code class="language-cpp">int myAdd(int a, int b)
{
  return a + b;
}
void test()
{
  int(*pFun)(int, int) = myAdd;    //定义一个函数指针，（）增加了优先级以便可以构成指针结构
  cout &lt;&lt; (*pFun)(2, 5) &lt;&lt; endl;    //用函数指针调用函数
  cout &lt;&lt; pFun(2, 5) &lt;&lt; endl;      //用函数指针调用函数
}
</code></pre>
<p>一个巨复杂的例子🌰：</p>
<pre><code class="language-cpp">char *(* c[10])(int **p);
</code></pre>
<p>乍一看，让人眼花缭乱，不知道是什么东西，在这里请大家记住一个规则：C语言标准规定，对于一个符号的定义，编译器总是从它的名字开始读取，然后按照优先级顺序依次解析。注意是从名字开始，不是从开头也不是从末尾，这是理解复杂指针的关键。</p>
<p>有了上面的规则，我们来逐步剖析上面哪行代码的意义：</p>
<p>首先从*c[10]开始，由于[]的优先级比*高，因此，*c[10]代表一个指针数组，每个元素都是指针，但类型还不知道。再看右边的(int** p)，它是一个函数，参数为一个二级指针。最左边char* 代表这个函数的返回类型。因此，整行代码的含义就是：c 是一个拥有 10 个元素的指针数组，数组每个元素指向一个原型为char *(int **p)的函数。</p>
<h2 id="c-引用理解成一种特殊的指针"><a class="header" href="#c-引用理解成一种特殊的指针">C++ 引用（理解成一种特殊的指针）</a></h2>
<h4 id="1基本定义"><a class="header" href="#1基本定义">1、基本定义</a></h4>
<p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>
<p>引用<strong>很容易与指针混淆</strong>，它们之间有三个主要的不同：</p>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
</ul>
<p>一个例子🌰</p>
<p>例如：</p>
<pre><code class="language-cpp">int    i = 17;
</code></pre>
<p>我们可以为 i 声明引用变量，如下所示：</p>
<pre><code class="language-cpp">int&amp;    r = i;
</code></pre>
<p>在这些声明中，&amp; 读作<strong>引用</strong>。因此，第一个声明可以读作 &quot;r 是一个初始化为 i 的整型引用&quot;，第二个声明可以读作 &quot;s 是一个初始化为 d 的 double 型引用&quot;。下面的实例使用了 int 和 double 引用：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
 
using namespace std;
 
int main ()
{
   // 声明简单的变量
   int    i;
   double d;
 
   // 声明引用变量
   int&amp;    r = i;
   double&amp; s = d;
   
   i = 5;
   cout &lt;&lt; &quot;Value of i : &quot; &lt;&lt; i &lt;&lt; endl;
   cout &lt;&lt; &quot;Value of i reference : &quot; &lt;&lt; r  &lt;&lt; endl;
 
   d = 11.7;
   cout &lt;&lt; &quot;Value of d : &quot; &lt;&lt; d &lt;&lt; endl;
   cout &lt;&lt; &quot;Value of d reference : &quot; &lt;&lt; s  &lt;&lt; endl;
   
   return 0;
}
//输出结果
Value of i : 5
Value of i reference : 5
Value of d : 11.7
Value of d reference : 11.7
</code></pre>
<h4 id="2把引用作为函数参数"><a class="header" href="#2把引用作为函数参数">2、把引用作为函数参数</a></h4>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
// 函数声明
void swap(int&amp; x, int&amp; y);
 
int main ()
{
   // 局部变量声明
   int a = 100;
   int b = 200;
 
   cout &lt;&lt; &quot;交换前，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   cout &lt;&lt; &quot;交换前，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;
 
   /* 调用函数来交换值 */
   swap(a, b);
 
   cout &lt;&lt; &quot;交换后，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   cout &lt;&lt; &quot;交换前，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;
 
   return 0;
}
 
// 函数定义
void swap(int&amp; x, int&amp; y)
{
   int temp;
   temp = x; /* 保存地址 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 x 赋值给 y  */
  
   return;
}
//输出结果
交换前，a 的值： 100
交换前，b 的值： 200
交换后，a 的值： 200
交换后，b 的值： 100
</code></pre>
<h4 id="3把引用作为函数返回值"><a class="header" href="#3把引用作为函数返回值">3、把引用作为函数返回值</a></h4>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;ctime&gt;
 
using namespace std;
 
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
 
double&amp; setValues( int i )
{
  return vals[i];   // 返回第 i 个元素的引用
}
 
// 要调用上面定义函数的主函数
int main ()
{
 
   cout &lt;&lt; &quot;改变前的值&quot; &lt;&lt; endl;
   for ( int i = 0; i &lt; 5; i++ )
   {
       cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
       cout &lt;&lt; vals[i] &lt;&lt; endl;
   }
 
   setValues(1) = 20.23; // 改变第 2 个元素
   setValues(3) = 70.8;  // 改变第 4 个元素
 
   cout &lt;&lt; &quot;改变后的值&quot; &lt;&lt; endl;
   for ( int i = 0; i &lt; 5; i++ )
   {
       cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
       cout &lt;&lt; vals[i] &lt;&lt; endl;
   }
   return 0;
}
//输出结果
改变前的值
vals[0] = 10.1
vals[1] = 12.6
vals[2] = 33.1
vals[3] = 24.1
vals[4] = 50
改变后的值
vals[0] = 10.1
vals[1] = 20.23
vals[2] = 33.1
vals[3] = 70.8
vals[4] = 50
</code></pre>
<p><strong>当返回一个引用时，要注意被引用的对象不能超出作用域</strong>。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。</p>
<pre><code class="language-C++">int&amp; func() {
   int q;
   //! return q; // 在编译时发生错误
   static int x;
   return x;     // 安全，x 在函数作用域外依然是有效的
}
</code></pre>
<h2 id="c-基本的输入输出"><a class="header" href="#c-基本的输入输出">C++ 基本的输入输出</a></h2>
<p>C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做<strong>输入操作</strong>。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做<strong>输出操作</strong>。</p>
<h4 id="1io-库头文件"><a class="header" href="#1io-库头文件">1、I/O 库头文件</a></h4>
<p>下列的头文件在 C++ 编程中很重要。</p>
<table><thead><tr><th align="left">头文件</th><th align="left">函数和描述</th></tr></thead><tbody>
<tr><td align="left"><iostream></td><td align="left">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td></tr>
<tr><td align="left"><iomanip></td><td align="left">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I/O 有用的服务。</td></tr>
<tr><td align="left"><fstream></td><td align="left">该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</td></tr>
</tbody></table>
<h4 id="2标准输出流cout"><a class="header" href="#2标准输出流cout">2、标准输出流（cout）</a></h4>
<p>预定义的对象 <strong>cout</strong> 是 <strong>ostream</strong> 类的一个实例。cout 对象&quot;连接&quot;到标准输出设备，通常是显示屏。<strong>cout</strong> 是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main( )
{
   char str[] = &quot;Hello C++&quot;;
   cout &lt;&lt; &quot;Value of str is : &quot; &lt;&lt; str &lt;&lt; endl; 
} 
</code></pre>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code class="language-C++">Value of str is : Hello C++
</code></pre>
<p>C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。</p>
<p>==流插入运算符 &lt;&lt;== 在一个语句中可以多次使用，如上面实例中所示，<strong>endl</strong> 用于在行末添加一个换行符。</p>
<h4 id="3标准输入流cin"><a class="header" href="#3标准输入流cin">3、标准输入流（cin)</a></h4>
<p>预定义的对象 <strong>cin</strong> 是 <strong>istream</strong> 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。<strong>cin</strong> 是与==流提取运算符 &gt;&gt;== 结合使用的，如下所示：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main( )
{
    char name[50];
    int age;
    cout &lt;&lt; &quot;请输入您的名称： &quot;;
    cin &gt;&gt; name;
    cout &lt;&lt; &quot;您的名称是： &quot; &lt;&lt; name &lt;&lt; endl;   
    cout &lt;&lt;&quot;请输入年龄&quot;;
    cin &gt;&gt; age;
    if (age &gt; 10){
      cout &lt;&lt; &quot;your age is older than 10&quot;;
    }else{
      cout &lt;&lt; &quot;your are so young&quot;;
    }
} 
</code></pre>
<p>C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。</p>
<p>流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：</p>
<pre><code class="language-C++">cin &gt;&gt; name &gt;&gt; age;
</code></pre>
<p>这相当于下面两个语句：</p>
<pre><code class="language-c++">cin &gt;&gt; name;
cin &gt;&gt; age;
</code></pre>
<h4 id="4标准错误流cerr"><a class="header" href="#4标准错误流cerr">4、标准错误流（cerr)</a></h4>
<p>预定义的对象 <strong>cerr</strong> 是 <strong>ostream</strong> 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 <strong>cerr</strong> 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</p>
<p><strong>cerr</strong> 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main( )
{
   char str[] = &quot;Unable to read....&quot;;
   cerr &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl; 
} 
</code></pre>
<h4 id="5标准日志流clog"><a class="header" href="#5标准日志流clog">5、标准日志流（clog)</a></h4>
<p>预定义的对象 <strong>clog</strong> 是 <strong>ostream</strong> 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 <strong>clog</strong> 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区中，直到缓冲填满或者缓冲区刷新时才会输出。</p>
<p><strong>clog</strong> 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main( )
{
   char str[] = &quot;Unable to read....&quot;;
   clog &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl;
} 
</code></pre>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code class="language-C++">Error message : Unable to read....
</code></pre>
<h2 id="c-数据结构"><a class="header" href="#c-数据结构">C++ 数据结构</a></h2>
<p>C/C++ 数组允许定义可存储相同类型数据项的变量，但是<strong>结构是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</strong></p>
<p>结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：</p>
<ul>
<li>Title</li>
<li>Author</li>
<li>Subject</li>
<li>Book ID</li>
</ul>
<h4 id="1数据结构的定义"><a class="header" href="#1数据结构的定义">1、数据结构的定义</a></h4>
<p>为了定义结构，您必须使用 <strong>struct</strong> 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>
<pre><code class="language-C++">struct [structure tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more structure variables];  
</code></pre>
<p><strong>structure tag</strong> 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明 Book 结构的方式：</p>
<pre><code class="language-C++">struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
}book; //分号必不可少
// 这里的book相当于在定义struct的同时就默认初始化了一个变量book
</code></pre>
<blockquote>
<p>感觉类似于python中的创建一个空的类 用于储存数据一样</p>
</blockquote>
<p>对结构变量可以在定义时初始化。方法是：
在花括号中顺序填入结构中的（数据）成员的初始值：</p>
<pre><code class="language-C++">Books book1 = {&quot;bookname&quot;,&quot;me&quot;,&quot;science&quot;,&quot;1000101&quot;}
</code></pre>
<p>此外值得注意：</p>
<pre><code class="language-C++">//该结构可以嵌套
struct mail
{
       char address[30] ; //地址
       long int zip ; //邮政编码
       long int telenum ; //电话号码
};
 
struct employee
{
       char name[25] ; //员工姓名
       mail addinfo ; //结构变量作为成员，嵌套
       double salary ; //工资
};
//访问结构变量的结构成员的方法：用连续点号来访问结构变量的结构成员。例如有程序段：
employee emp1={“朱明”,“四牌楼2号”,210096,83792666,2430.0};//因为存在结构嵌套，因此多了好几个初始化需要添加的参数
cout&lt;&lt;emp1.addinfo.telenum&lt;&lt;endl;
</code></pre>
<h4 id="2访问结构成员"><a class="header" href="#2访问结构成员">2、访问结构成员</a></h4>
<p>为了访问结构的成员，我们使用<strong>成员访问运算符（.）</strong>。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 <strong>struct</strong> 关键字来定义结构类型的变量。下面的实例演示了结构的用法：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
 
using namespace std;
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
int main( )
{
   struct Books Book1;        // 声明 Book1，类型为 Book
   struct Books Book2;        // 声明 Book2，类型为 Book
 
   // Book1 详述
   strcpy( Book1.title, &quot;Learn C++ Programming&quot;);
   strcpy( Book1.author, &quot;Chand Miyan&quot;); 
   strcpy( Book1.subject, &quot;C++ Programming&quot;);
   Book1.book_id = 6495407;

   // Book2 详述
   strcpy( Book2.title, &quot;Telecom Billing&quot;);
   strcpy( Book2.author, &quot;Yakit Singha&quot;);
   strcpy( Book2.subject, &quot;Telecom&quot;);
   Book2.book_id = 6495700;
 
   // 输出 Book1 信息
   cout &lt;&lt; &quot;Book 1 title : &quot; &lt;&lt; Book1.title &lt;&lt;endl;
   cout &lt;&lt; &quot;Book 1 author : &quot; &lt;&lt; Book1.author &lt;&lt;endl;
   cout &lt;&lt; &quot;Book 1 subject : &quot; &lt;&lt; Book1.subject &lt;&lt;endl;
   cout &lt;&lt; &quot;Book 1 id : &quot; &lt;&lt; Book1.book_id &lt;&lt;endl;

   // 输出 Book2 信息
   cout &lt;&lt; &quot;Book 2 title : &quot; &lt;&lt; Book2.title &lt;&lt;endl;
   cout &lt;&lt; &quot;Book 2 author : &quot; &lt;&lt; Book2.author &lt;&lt;endl;
   cout &lt;&lt; &quot;Book 2 subject : &quot; &lt;&lt; Book2.subject &lt;&lt;endl;
   cout &lt;&lt; &quot;Book 2 id : &quot; &lt;&lt; Book2.book_id &lt;&lt;endl;

   return 0;
}
</code></pre>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code>Book 1 title : Learn C++ Programming
Book 1 author : Chand Miyan
Book 1 subject : C++ Programming
Book 1 id : 6495407
Book 2 title : Telecom Billing
Book 2 author : Yakit Singha
Book 2 subject : Telecom
Book 2 id : 6495700
</code></pre>
<h4 id="3结构作为函数参数"><a class="header" href="#3结构作为函数参数">3、结构作为函数参数</a></h4>
<p>您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
 
using namespace std;
void printBook( struct Books book );

struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
int main( )
{
   struct Books Book1;        // 声明 Book1，类型为 Book
   struct Books Book2;        // 声明 Book2，类型为 Book
 
   // Book1 详述
   strcpy( Book1.title, &quot;Learn C++ Programming&quot;);
   strcpy( Book1.author, &quot;Chand Miyan&quot;); 
   strcpy( Book1.subject, &quot;C++ Programming&quot;);
   Book1.book_id = 6495407;

   // Book2 详述
   strcpy( Book2.title, &quot;Telecom Billing&quot;);
   strcpy( Book2.author, &quot;Yakit Singha&quot;);
   strcpy( Book2.subject, &quot;Telecom&quot;);
   Book2.book_id = 6495700;
 
   // 输出 Book1 信息
   printBook( Book1 );

   // 输出 Book2 信息
   printBook( Book2 );

   return 0;
}
void printBook( struct Books book )
{
   cout &lt;&lt; &quot;Book title : &quot; &lt;&lt; book.title &lt;&lt;endl;
   cout &lt;&lt; &quot;Book author : &quot; &lt;&lt; book.author &lt;&lt;endl;
   cout &lt;&lt; &quot;Book subject : &quot; &lt;&lt; book.subject &lt;&lt;endl;
   cout &lt;&lt; &quot;Book id : &quot; &lt;&lt; book.book_id &lt;&lt;endl;
}
</code></pre>
<h4 id="4指向结构的指针"><a class="header" href="#4指向结构的指针">4、指向结构的指针</a></h4>
<p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</p>
<pre><code class="language-C++">struct Books *struct_pointer;
</code></pre>
<p>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</p>
<pre><code class="language-c++">struct_pointer = &amp;Book1;
</code></pre>
<p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：</p>
<pre><code class="language-c++">struct_pointer -&gt; title;
</code></pre>
<p>一个具体的例子🌰：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
 
using namespace std;
void printBook( struct Books *book );

struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
int main( )
{
   struct Books Book1;        // 声明 Book1，类型为 Book
   struct Books Book2;        // 声明 Book2，类型为 Book */
 
   // Book1 详述
   strcpy( Book1.title, &quot;Learn C++ Programming&quot;);
   strcpy( Book1.author, &quot;Chand Miyan&quot;); 
   strcpy( Book1.subject, &quot;C++ Programming&quot;);
   Book1.book_id = 6495407;

   // Book2 详述
   strcpy( Book2.title, &quot;Telecom Billing&quot;);
   strcpy( Book2.author, &quot;Yakit Singha&quot;);
   strcpy( Book2.subject, &quot;Telecom&quot;);
   Book2.book_id = 6495700;
 
   // 通过传 Book1 的地址来输出 Book1 信息
   printBook( &amp;Book1 ); //就相当于在函数定义时在此处声明了一个指针，然后在函数调用的时候直接将地址值赋给这个指针。

   // 通过传 Book2 的地址来输出 Book2 信息
   printBook( &amp;Book2 );

   return 0;
}
// 该函数以结构指针作为参数
void printBook( struct Books *book )
{
   cout &lt;&lt; &quot;Book title : &quot; &lt;&lt; book-&gt;title &lt;&lt;endl;
   cout &lt;&lt; &quot;Book author : &quot; &lt;&lt; book-&gt;author &lt;&lt;endl;
   cout &lt;&lt; &quot;Book subject : &quot; &lt;&lt; book-&gt;subject &lt;&lt;endl;
   cout &lt;&lt; &quot;Book id : &quot; &lt;&lt; book-&gt;book_id &lt;&lt;endl;
} 
</code></pre>
<h4 id="5typedef关键字"><a class="header" href="#5typedef关键字">5、typedef关键字</a></h4>
<p>下面是一种更简单的定义结构的方式，您可以为创建的类型取一个&quot;别名&quot;。例如：</p>
<pre><code class="language-c++">typedef struct
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
}Books;
</code></pre>
<p>现在，您可以直接使用 <em>Books</em> 来定义 <em>Books</em> 类型的变量，而不需要使用 struct 关键字。下面是实例：</p>
<pre><code class="language-c++">Books Book1, Book2;
</code></pre>
<p>您可以使用 <strong>typedef</strong> 关键字来定义非结构类型，如下所示：</p>
<pre><code class="language-c++">typedef long int *pint32;
 
pint32 x, y, z;
</code></pre>
<p>x, y 和 z 都是指向长整型 long int 的指针。</p>
<div style="break-before: page; page-break-before: always;"></div><p><a name="index"><strong>Index</strong></a>
 <a href="C++学习/C++基础带目录.html#0">C++ 简介</a><br />
 <a href="C++学习/C++基础带目录.html#1">标准库</a><br />
 <a href="C++学习/C++基础带目录.html#2">C++ 环境设置</a><br />
 <a href="C++学习/C++基础带目录.html#3">C++ 基本语法</a><br />
 <a href="C++学习/C++基础带目录.html#4">编译 &amp; 执行 C++ 程序</a><br />
 <a href="C++学习/C++基础带目录.html#5">C++ 中的分号 &amp; 块</a><br />
 <a href="C++学习/C++基础带目录.html#6">C++ 标识符</a><br />
 <a href="C++学习/C++基础带目录.html#7">C++ 关键字</a><br />
 <a href="C++学习/C++基础带目录.html#8">C++ 中的空格</a><br />
 <a href="C++学习/C++基础带目录.html#9">C++ 注释</a><br />
 <a href="C++学习/C++基础带目录.html#10">C++ 数据类型</a><br />
 <a href="C++学习/C++基础带目录.html#11">枚举类型(迷惑？)</a><br />
 <a href="C++学习/C++基础带目录.html#12">C++ 变量类型</a><br />
 <a href="C++学习/C++基础带目录.html#13">C++ 中的变量定义</a><br />
 <a href="C++学习/C++基础带目录.html#14">C++ 中的变量声明</a><br />
 <a href="C++学习/C++基础带目录.html#15">C++ 中的左值（Lvalues）和右值（Rvalues）</a><br />
 <a href="C++学习/C++基础带目录.html#16">C++ 变量作用域</a><br />
 <a href="C++学习/C++基础带目录.html#17">全局变量和局部变量</a><br />
 <a href="C++学习/C++基础带目录.html#18">C++ 常量</a><br />
   <a href="C++学习/C++基础带目录.html#19">整数常量</a><br />
   <a href="C++学习/C++基础带目录.html#20">浮点常量</a><br />
   <a href="C++学习/C++基础带目录.html#21">布尔常量</a><br />
   <a href="C++学习/C++基础带目录.html#22">字符常量</a><br />
   <a href="C++学习/C++基础带目录.html#23">字符串常量</a><br />
 <a href="C++学习/C++基础带目录.html#24">定义常量</a><br />
   <a href="C++学习/C++基础带目录.html#25">1、define预处理器</a><br />
   <a href="C++学习/C++基础带目录.html#26">2、const关键字</a><br />
 <a href="C++学习/C++基础带目录.html#27">C++ 修饰符类型</a><br />
 <a href="C++学习/C++基础带目录.html#28">C++ 中的类型限定符</a><br />
 <a href="C++学习/C++基础带目录.html#29">C++ 存储类</a><br />
   <a href="C++学习/C++基础带目录.html#30">1、auto 存储类</a><br />
   <a href="C++学习/C++基础带目录.html#31">2、register 存储类</a><br />
   <a href="C++学习/C++基础带目录.html#32">3、static 存储类</a><br />
   <a href="C++学习/C++基础带目录.html#33">4、extern储存类（相当于定义一个可以多个文件共享的变量）</a><br />
   <a href="C++学习/C++基础带目录.html#34">5、mutable储存类</a><br />
 <a href="C++学习/C++基础带目录.html#35">C++ 运算符</a><br />
   <a href="C++学习/C++基础带目录.html#36">1、算数运算符</a><br />
   <a href="C++学习/C++基础带目录.html#37">2、关系运算符</a><br />
   <a href="C++学习/C++基础带目录.html#38">3、逻辑运算符（与或非）</a><br />
   <a href="C++学习/C++基础带目录.html#39">4、位运算符（二进制操作）</a><br />
   <a href="C++学习/C++基础带目录.html#40">5、赋值运算符</a><br />
   <a href="C++学习/C++基础带目录.html#41">6、杂项运算符</a><br />
   <a href="C++学习/C++基础带目录.html#42">C++ 中的运算符优先级</a><br />
 <a href="C++学习/C++基础带目录.html#43">C++ 循环及控制</a><br />
   <a href="C++学习/C++基础带目录.html#44">1、循环类型</a><br />
    <a href="C++学习/C++基础带目录.html#45">1、while 循环</a><br />
    <a href="C++学习/C++基础带目录.html#46">2、for循环</a><br />
    <a href="C++学习/C++基础带目录.html#47">3、do.....while....循环</a><br />
    <a href="C++学习/C++基础带目录.html#48">4、嵌套的循环</a><br />
   <a href="C++学习/C++基础带目录.html#49">2、循环控制语句</a><br />
    <a href="C++学习/C++基础带目录.html#50">1、C++break语句（达到条件提前终止）</a><br />
    <a href="C++学习/C++基础带目录.html#51">2、C++continue语句（额外增加一次判断，然后跳过原本执行的语句）</a><br />
    <a href="C++学习/C++基础带目录.html#52">3、goto 语句 （满足某个条件直接蹦到执行某个命令）</a><br />
    <a href="C++学习/C++基础带目录.html#53">无限循环</a><br />
 <a href="C++学习/C++基础带目录.html#54">C++ 判断</a><br />
   <a href="C++学习/C++基础带目录.html#55">1、判断语句</a><br />
    <a href="C++学习/C++基础带目录.html#56">1、if语句</a><br />
    <a href="C++学习/C++基础带目录.html#57">2、if-else语句</a><br />
    <a href="C++学习/C++基础带目录.html#58">3、嵌套if</a><br />
    <a href="C++学习/C++基础带目录.html#59">4、switch语句⭐️</a><br />
   <a href="C++学习/C++基础带目录.html#60">2、? : 运算符</a><br />
 <a href="C++学习/C++基础带目录.html#61">C++ 函数</a><br />
   <a href="C++学习/C++基础带目录.html#62">1、函数定义</a><br />
   <a href="C++学习/C++基础带目录.html#63">2、函数声明</a><br />
   <a href="C++学习/C++基础带目录.html#64">3、函数参数</a><br />
 <a href="C++学习/C++基础带目录.html#65">C++ 数字</a><br />
   <a href="C++学习/C++基础带目录.html#66">1、C++定义数字</a><br />
   <a href="C++学习/C++基础带目录.html#67">2、C++数学运算</a><br />
   <a href="C++学习/C++基础带目录.html#68">3、C++随机数</a><br />
 <a href="C++学习/C++基础带目录.html#69">C++ 数组</a><br />
   <a href="C++学习/C++基础带目录.html#70">1、声明数组</a><br />
   <a href="C++学习/C++基础带目录.html#71">2、初始化数组</a><br />
   <a href="C++学习/C++基础带目录.html#72">3、多维数组</a><br />
   <a href="C++学习/C++基础带目录.html#73">C++ 中数组其他相关内容详解</a><br />
 <a href="C++学习/C++基础带目录.html#74">C++ 字符串</a><br />
   <a href="C++学习/C++基础带目录.html#75">1、C风格字符串</a><br />
 <a href="C++学习/C++基础带目录.html#76">C++ 中的 String 类</a><br />
 <a href="C++学习/C++基础带目录.html#77">C++ 指针⭐️⭐️</a><br />
   <a href="C++学习/C++基础带目录.html#78">什么是指针？</a><br />
   <a href="C++学习/C++基础带目录.html#79">C++ NULL指针</a><br />
   <a href="C++学习/C++基础带目录.html#80">C++ 指针的算术运算</a><br />
    <a href="C++学习/C++基础带目录.html#81">1、<strong>递增一个指针</strong></a><br />
    <a href="C++学习/C++基础带目录.html#82">2、递减一个指针</a><br />
    <a href="C++学习/C++基础带目录.html#83"><strong>3、指针的比较</strong></a><br />
   <a href="C++学习/C++基础带目录.html#84">C++指针VS数组</a><br />
   <a href="C++学习/C++基础带目录.html#85">C++指针数组</a><br />
    <a href="C++学习/C++基础带目录.html#86">C++ 指向指针的指针（多级间接寻址）</a><br />
    <a href="C++学习/C++基础带目录.html#87">C++ 传递指针给函数</a><br />
    <a href="C++学习/C++基础带目录.html#88">C++ 从函数返回指针/数组</a><br />
 <a href="C++学习/C++基础带目录.html#89">C++ 指针总结及相关容易混淆概念</a><br />
   <a href="C++学习/C++基础带目录.html#90"><strong>一，内存和地址</strong></a><br />
   <a href="C++学习/C++基础带目录.html#91"><strong>二，指针的本质就是地址</strong> </a><br />
   <a href="C++学习/C++基础带目录.html#92">三，一些容易混淆的重要内容</a><br />
    <a href="C++学习/C++基础带目录.html#93">1、常量指针与指针常量</a><br />
    <a href="C++学习/C++基础带目录.html#94">2、指针与数组</a><br />
    <a href="C++学习/C++基础带目录.html#95"><strong>4、指针函数与函数指针</strong></a><br />
 <a href="C++学习/C++基础带目录.html#96">C++ 引用（理解成一种特殊的指针）</a><br />
   <a href="C++学习/C++基础带目录.html#97">1、基本定义</a><br />
   <a href="C++学习/C++基础带目录.html#98">2、把引用作为函数参数</a><br />
   <a href="C++学习/C++基础带目录.html#99">3、把引用作为函数返回值</a><br />
 <a href="C++学习/C++基础带目录.html#100">C++ 基本的输入输出</a><br />
   <a href="C++学习/C++基础带目录.html#101">1、I/O 库头文件</a><br />
   <a href="C++学习/C++基础带目录.html#102">2、标准输出流（cout）</a><br />
   <a href="C++学习/C++基础带目录.html#103">3、标准输入流（cin)</a><br />
   <a href="C++学习/C++基础带目录.html#104">4、标准错误流（cerr)</a><br />
   <a href="C++学习/C++基础带目录.html#105">5、标准日志流（clog)</a><br />
 <a href="C++学习/C++基础带目录.html#106">C++ 数据结构</a><br />
   <a href="C++学习/C++基础带目录.html#107">1、数据结构的定义</a><br />
   <a href="C++学习/C++基础带目录.html#108">2、访问结构成员</a><br />
   <a href="C++学习/C++基础带目录.html#109">3、结构作为函数参数</a><br />
   <a href="C++学习/C++基础带目录.html#110">4、指向结构的指针</a><br />
   <a href="C++学习/C++基础带目录.html#111">5、typedef关键字</a></p>
<h2 id="a-name0c-简介aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name0c-简介aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="0">C++ 简介</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>C++ 是一种静态类型的编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p>
<h2 id="a-name1标准库aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name1标准库aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="1">标准库</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>标准的 C++ 由三个重要部分组成：</p>
<ul>
<li>核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。</li>
<li>C++ 标准库，提供了大量的函数，用于操作文件、字符串等。</li>
<li>标准模板库（STL），提供了大量的方法，用于操作数据结构等。</li>
</ul>
<h2 id="a-name2c-环境设置aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name2c-环境设置aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="2">C++ 环境设置</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p><strong>编辑 and 编译</strong></p>
<p>==编辑==：通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。</p>
<p>==编译==：它需要&quot;编译&quot;，转为机器语言，这样 CPU 可以按给定指令执行程序。</p>
<p>C++ 编译器用于把源代码编译成最终的可执行程序。大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。</p>
<p>最常用的免费可用的编译器是 GNU 的 C/C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。</p>
<h2 id="a-name3c-基本语法aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name3c-基本语法aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="3">C++ 基本语法</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。</p>
<ul>
<li><strong>对象 -</strong> 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。</li>
<li><strong>类 -</strong> 类可以定义为描述对象行为/状态的模板/蓝图。</li>
<li><strong>方法 -</strong> 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。</li>
<li><strong>即时变量 -</strong> 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

// main() 是程序开始执行的地方

int main()
{
   cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World    return 0; 
} 
</code></pre>
<ul>
<li>C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 <strong><iostream></strong>。</li>
<li>行 <strong>using namespace std;</strong> 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。</li>
<li>下一行 <strong>// main() 是程序开始执行的地方</strong> 是一个单行注释。单行注释以 // 开头，在行末结束。</li>
<li>下一行 <strong>int main()</strong> 是主函数，程序从这里开始执行。</li>
<li>下一行 <strong>cout &lt;&lt; &quot;Hello World&quot;;</strong> 会在屏幕上显示消息 &quot;Hello World&quot;。</li>
<li>下一行 <strong>return 0;</strong> 终止 main( )函数，并向调用进程返回值 0。</li>
</ul>
<h2 id="a-name4编译--执行-c-程序aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name4编译--执行-c-程序aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="4">编译 &amp; 执行 C++ 程序</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：</p>
<ul>
<li>打开一个文本编辑器，添加上述代码。</li>
<li>保存文件为 hello.cpp。</li>
<li>打开命令提示符，进入到保存文件所在的目录。</li>
<li>键入 'g++ hello.cpp '，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。</li>
<li>现在，键入 ' a.out' 来运行程序。</li>
<li>您可以看到屏幕上显示 ' Hello World '。</li>
</ul>
<h2 id="a-name5c-中的分号--块aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name5c-中的分号--块aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="5">C++ 中的分号 &amp; 块</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>C++中默认以<strong>分号</strong>结尾才叫结束一句话，否则自然换行是不能被正确识别的</p>
<p><strong>块</strong>是一组使用大括号括起来的按逻辑连接的语句</p>
<h2 id="a-name6c-标识符aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name6c-标识符aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="6">C++ 标识符</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p>
<p>C++ 标识符内不允许出现标点字符，比如 @、$ 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，<strong>Manpower</strong> 和 <strong>manpower</strong> 是两个不同的标识符。</p>
<pre><code class="language-c++">mohd       zara    abc   move_name  a_123
myname50   _temp   j     a23b9      retVal
</code></pre>
<blockquote>
<p>类比于Python中的变量命名空间</p>
</blockquote>
<h2 id="a-name7c-关键字aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name7c-关键字aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="7">C++ 关键字</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p>
<table><thead><tr><th>asm</th><th>else</th><th>new</th><th>this</th></tr></thead><tbody>
<tr><td>auto</td><td>enum</td><td>operator</td><td>throw</td></tr>
<tr><td>bool</td><td>explicit</td><td>private</td><td>true</td></tr>
<tr><td>break</td><td>export</td><td>protected</td><td>try</td></tr>
<tr><td>case</td><td>extern</td><td>public</td><td>typedef</td></tr>
<tr><td>catch</td><td>false</td><td>register</td><td>typeid</td></tr>
<tr><td>char</td><td>float</td><td>reinterpret_cast</td><td>typename</td></tr>
<tr><td>class</td><td>for</td><td>return</td><td>union</td></tr>
<tr><td>const</td><td>friend</td><td>short</td><td>unsigned</td></tr>
<tr><td>const_cast</td><td>goto</td><td>signed</td><td>using</td></tr>
<tr><td>continue</td><td>if</td><td>sizeof</td><td>virtual</td></tr>
<tr><td>default</td><td>inline</td><td>static</td><td>void</td></tr>
<tr><td>delete</td><td>int</td><td>static_cast</td><td>volatile</td></tr>
<tr><td>do</td><td>long</td><td>struct</td><td>wchar_t</td></tr>
<tr><td>double</td><td>mutable</td><td>switch</td><td>while</td></tr>
<tr><td>dynamic_cast</td><td>namespace</td><td>template</td><td></td></tr>
</tbody></table>
<h2 id="a-name8c-中的空格aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name8c-中的空格aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="8">C++ 中的空格</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。</p>
<p>在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：</p>
<pre><code class="language-c++">int age
//为了增加代码的可读性，有时候会在变量之间增加空格
fruit = apples + oranges;   // 获取水果的总数
</code></pre>
<h2 id="a-name9c-注释aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name9c-注释aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="9">C++ 注释</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>注释包含单行注释和多行注释两种</p>
<ul>
<li>单行注释用//表示即可，直到行末为止</li>
<li>多行注释使用/*  */包围表示，可以跨行使用</li>
</ul>
<blockquote>
<p>注意：在使用时，两者嵌套使用时不会互相干扰，谁在外层谁的优先级就更高</p>
</blockquote>
<h2 id="a-name10c-数据类型aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name10c-数据类型aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="10">C++ 数据类型</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p><strong>基本的内置类型</strong></p>
<table><thead><tr><th align="left">类型</th><th align="left">关键字</th></tr></thead><tbody>
<tr><td align="left">布尔型</td><td align="left">bool</td></tr>
<tr><td align="left">字符型</td><td align="left">char</td></tr>
<tr><td align="left">整型</td><td align="left">int</td></tr>
<tr><td align="left">浮点型</td><td align="left">float</td></tr>
<tr><td align="left">双浮点型</td><td align="left">double</td></tr>
<tr><td align="left">无类型</td><td align="left">void</td></tr>
<tr><td align="left">宽字符型</td><td align="left">wchar_t</td></tr>
</tbody></table>
<p>一些基本类型可以使用一个或多个类型修饰符进行修饰：</p>
<ul>
<li>signed</li>
<li>unsigned</li>
<li>short</li>
<li>long</li>
</ul>
<p>下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。</p>
<table><thead><tr><th align="left">类型</th><th align="left">位</th><th align="left">范围</th></tr></thead><tbody>
<tr><td align="left">char</td><td align="left">1 个字节</td><td align="left">-128 到 127 或者 0 到 255</td></tr>
<tr><td align="left">unsigned char</td><td align="left">1 个字节</td><td align="left">0 到 255</td></tr>
<tr><td align="left">signed char</td><td align="left">1 个字节</td><td align="left">-128 到 127</td></tr>
<tr><td align="left">int</td><td align="left">4 个字节</td><td align="left">-2147483648 到 2147483647</td></tr>
<tr><td align="left">unsigned int</td><td align="left">4 个字节</td><td align="left">0 到 4294967295</td></tr>
<tr><td align="left">signed int</td><td align="left">4 个字节</td><td align="left">-2147483648 到 2147483647</td></tr>
<tr><td align="left">short int</td><td align="left">2 个字节</td><td align="left">-32768 到 32767</td></tr>
<tr><td align="left">unsigned short int</td><td align="left">2 个字节</td><td align="left">0 到 65,535</td></tr>
<tr><td align="left">signed short int</td><td align="left">2 个字节</td><td align="left">-32768 到 32767</td></tr>
<tr><td align="left">long int</td><td align="left">8 个字节</td><td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr>
<tr><td align="left">signed long int</td><td align="left">8 个字节</td><td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr>
<tr><td align="left">unsigned long int</td><td align="left">8 个字节</td><td align="left">0 到 18,446,744,073,709,551,615</td></tr>
<tr><td align="left">float</td><td align="left">4 个字节</td><td align="left">精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td></tr>
<tr><td align="left">double</td><td align="left">8 个字节</td><td align="left">双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308(~15 个数字)</td></tr>
<tr><td align="left">long double</td><td align="left">16 个字节</td><td align="left">长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td></tr>
<tr><td align="left">wchar_t</td><td align="left">2 或 4 个字节</td><td align="left">1 个宽字符</td></tr>
</tbody></table>
<blockquote>
<p>类型关键字重新定义</p>
<p>例如： typedef int feet;</p>
<p>此时编译器将会认为feet就是关键词int，后续在定义时直接使用feet distance也可以定义一个名为distance的整形变量。</p>
</blockquote>
<h2 id="a-name11枚举类型迷惑aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name11枚举类型迷惑aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="11">枚举类型(迷惑？)</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p><del>枚举类型声明一个可选的类型名称和一组标识符，用来作为该类型的值。其带有零个或多个标识符可以被用来作为该类型的值。每个枚举数是一个枚举类型的常数。</del><em>看不懂</em></p>
<p><strong>枚举是C语言中的一种基本数据类型</strong>，并不是构造类型，它可以用于声明一组常数。当一个变量有几个固定的可能取值时，可以将这个变量定义为枚举类型。比如，你可以用一个枚举类型的变量来表示季节，因为季节只有4种可能的取值：春天、夏天、秋天、冬天。</p>
<p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：</p>
<pre><code class="language-c">//枚举结构
enum　枚举名　{枚举元素1,枚举元素2,……} 枚举变量;
enum enum-name { list of names } var-list;

//枚举的用法
1、赋值
enum Season {spring, summer, autumn, winter} s;
s = spring; // 等价于 s = 0;
s = 3; // 等价于 s = winter;

2、遍历元素
enum Season {spring, summer, autumn, winter} s;
// 遍历枚举元素
for (s = spring; s &lt;= winter; s++) {
    printf(&quot;枚举元素：%d \n&quot;, s);
}
</code></pre>
<h2 id="a-name12c-变量类型aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name12c-变量类型aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="12">C++ 变量类型</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p>
<p>变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的，具体的变量类型如上节中的表格所示</p>
<table><thead><tr><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody>
<tr><td align="left">bool</td><td align="left">存储值 true 或 false。</td></tr>
<tr><td align="left">char</td><td align="left">通常是一个八位字节（一个字节）。这是一个整数类型。</td></tr>
<tr><td align="left">int</td><td align="left">对机器而言，整数的最自然的大小。</td></tr>
<tr><td align="left">float</td><td align="left">单精度浮点值。</td></tr>
<tr><td align="left">double</td><td align="left">双精度浮点值。</td></tr>
<tr><td align="left">void</td><td align="left">表示类型的缺失。</td></tr>
<tr><td align="left">wchar_t</td><td align="left">宽字符类型。</td></tr>
</tbody></table>
<p>C++ 也允许定义各种其他类型的变量，比如<strong>枚举、指针、数组、引用、数据结构、类</strong>等等，这将会在后续的章节中进行讲解</p>
<h2 id="a-name13c-中的变量定义aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name13c-中的变量定义aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="13">C++ 中的变量定义</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<blockquote>
<p>典型定义结构</p>
<p>type variable_list;</p>
</blockquote>
<p>在这里，<strong>type</strong> 必须是一个有效的 C++ 数据类型，可以是 char、w_char、int、float、double、bool 或任何用户自定义的对象，<strong>variable_list</strong> 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：</p>
<pre><code class="language-c++">int    i, j, k;
char   c, ch;
float  f, salary;
double d;
//额外实例
extern int d = 3, f = 5;    // d 和 f 的声明 
int d = 3, f = 5;           // 定义并初始化 d 和 f
byte z = 22;                // 定义并初始化 z
char x = 'x';               // 变量 x 的值为 'x'
</code></pre>
<p>**不带初始化的定义：**带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。</p>
<h2 id="a-name14c-中的变量声明aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name14c-中的变量声明aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="14">C++ 中的变量声明</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<blockquote>
<p><strong>extern</strong>关键字</p>
<p>当两个文件需要链接使用，两个文件中同时定义了一个重名的变量时，编译时是不会出现问题的，但是当运行时就会出现重复定义的问题。为了克服这个问题可以使用extern关键字（挖坑待填）</p>
</blockquote>
<h2 id="a-name15c-中的左值lvalues和右值rvaluesaa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name15c-中的左值lvalues和右值rvaluesaa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="15">C++ 中的左值（Lvalues）和右值（Rvalues）</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>C++ 中有两种类型的表达式：</p>
<ul>
<li>
<p><strong>左值（lvalue）：<strong>指向</strong>内存位置</strong>的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</p>
</li>
<li>
<p><strong>右值（rvalue）：<strong>术语右值（rvalue）指的是</strong>存储在内存中某些地址的数值</strong>。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</p>
<blockquote>
<p>右值是具体的数值，是在内存特定位置的一些数值，而左值则只是指示特定值在内存中位置的标签。</p>
</blockquote>
</li>
</ul>
<p>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：</p>
<pre><code>int g = 20;
</code></pre>
<p>但是下面这个就不是一个有效的语句，会生成编译时错误：</p>
<pre><code class="language-c">10 = 20;
</code></pre>
<h2 id="a-name16c-变量作用域aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name16c-变量作用域aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="16">C++ 变量作用域</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>作用域是程序的一个区域，一般来说有三个地方可以声明变量：</p>
<ul>
<li>在函数或一个代码块内部声明的变量，称为局部变量。</li>
<li>在函数参数的定义中声明的变量，称为形式参数。</li>
<li>在所有函数外部声明的变量，称为全局变量</li>
</ul>
<h2 id="a-name17全局变量和局部变量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name17全局变量和局部变量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="17">全局变量和局部变量</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。</p>
<p>全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
// 全局变量声明
int g;
 
int main ()
{
  // 局部变量声明
  int a, b;
 
  // 实际初始化
  a = 10;
  b = 20;
  g = a + b;
 
  cout &lt;&lt; g;     return 0;
 } 
// g = 30

//全局变量和局部变量可以同时定义，但是如果变量名相同是，局部变量会覆盖全局变量
</code></pre>
<blockquote>
<p>值得注意的是，与python不同，变量可以单独被创建而不需要预先赋值，但是系统会默认给个值，可能会导致意外的错误，因此最好直接在定义变量的时候就直接把数值定义好。</p>
</blockquote>
<p>当<strong>局部变量</strong>被定义时，系统不会对其初始化，您必须自行对其初始化。<strong>定义全局变量时，系统会自动初始化为下列值：</strong></p>
<table><thead><tr><th align="left">数据类型</th><th align="left">初始化默认值</th></tr></thead><tbody>
<tr><td align="left">int</td><td align="left">0</td></tr>
<tr><td align="left">char</td><td align="left">'\0'</td></tr>
<tr><td align="left">float</td><td align="left">0</td></tr>
<tr><td align="left">double</td><td align="left">0</td></tr>
<tr><td align="left">pointer</td><td align="left">NULL</td></tr>
</tbody></table>
<h2 id="a-name18c-常量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name18c-常量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="18">C++ 常量</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<h4 id="a-name19整数常量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name19整数常量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="19">整数常量</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>常量是固定值，<strong>在程序执行期间不会改变</strong>。这些固定的值，又叫做<strong>字面量</strong>。</p>
<p>常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。</p>
<p>常量就像是常规的变量，只不过常量的值在定义后不能进行修改。</p>
<p><strong>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</strong></p>
<p><strong>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</strong></p>
<p>常量实例</p>
<pre><code class="language-c++">212         // 合法的
215u        // 合法的
0xFeeL      // 合法的
078         // 非法的：8 不是八进制的数字
032UU       // 非法的：不能重复后缀
✅正确常量实例
85         // 十进制
0213       // 八进制 
0x4b       // 十六进制 
30         // 整数 
30u        // 无符号整数 
30l        // 长整数 
30ul       // 无符号长整数
</code></pre>
<h4 id="a-name20浮点常量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name20浮点常量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="20">浮点常量</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p>
<p>当使用小数形式表示时，必须包含小数点、指数，或同时包含两者。当使用指数形式表示时，必须包含整数部分、小数部分，或同时包含两者。带符号的指数是用 e 或 E 引入的。</p>
<pre><code class="language-c++">3.14159       // 合法的 
314159E-5L    // 合法的 
510E          // 非法的：不完整的指数
210f          // 非法的：没有小数或指数
.e55          // 非法的：缺少整数或分数
</code></pre>
<h4 id="a-name21布尔常量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name21布尔常量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="21">布尔常量</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>布尔常量共有两个，它们都是标准的 C++ 关键字：</p>
<ul>
<li><strong>true</strong> 值代表真。</li>
<li><strong>false</strong> 值代表假。</li>
</ul>
<p>我们不应把 true 的值看成 1，把 false 的值看成 0。</p>
<h4 id="a-name22字符常量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name22字符常量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="22">字符常量</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 <strong>wchar_t</strong> 类型的变量中。否则，它就是一个窄字符常量（例如 'x'），此时它可以存储在 <strong>char</strong> 类型的简单变量中。</p>
<p>字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。</p>
<p>在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：</p>
<table><thead><tr><th align="left">转义序列</th><th align="left">含义</th></tr></thead><tbody>
<tr><td align="left">\</td><td align="left">\ 字符</td></tr>
<tr><td align="left">'</td><td align="left">' 字符</td></tr>
<tr><td align="left">&quot;</td><td align="left">&quot; 字符</td></tr>
<tr><td align="left">?</td><td align="left">? 字符</td></tr>
<tr><td align="left">\a</td><td align="left">警报铃声</td></tr>
<tr><td align="left">\b</td><td align="left">退格键</td></tr>
<tr><td align="left">\f</td><td align="left">换页符</td></tr>
<tr><td align="left">\n</td><td align="left">换行符</td></tr>
<tr><td align="left">\r</td><td align="left">回车</td></tr>
<tr><td align="left">\t</td><td align="left">水平制表符</td></tr>
<tr><td align="left">\v</td><td align="left">垂直制表符</td></tr>
<tr><td align="left">\ooo</td><td align="left">一到三位的八进制数</td></tr>
<tr><td align="left">\xhh . . .</td><td align="left">一个或多个数字的十六进制数</td></tr>
</tbody></table>
<h4 id="a-name23字符串常量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name23字符串常量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="23">字符串常量</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>字符串字面值或常量是括在双引号 &quot;&quot; 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。</p>
<p>您可以使用空格做分隔符，把一个很长的字符串常量进行分行。</p>
<h2 id="a-name24定义常量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name24定义常量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="24">定义常量</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>在 C++ 中，有两种简单的定义常量的方式：</p>
<ul>
<li>使用 <strong>#define</strong> 预处理器。</li>
<li>使用 <strong>const</strong> 关键字。</li>
</ul>
<h4 id="a-name251define预处理器aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name251define预处理器aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="25">1、define预处理器</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>下面是使用 #define 预处理器定义常量的形式：</p>
<pre><code class="language-c++">#define identifier value
</code></pre>
<p><strong>一个例子</strong></p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

#define LENGTH 10   
#define WIDTH  5
#define NEWLINE '\n'

int main()
{

   int area;  
   
   area = LENGTH * WIDTH;
   cout &lt;&lt; area;
   cout &lt;&lt; NEWLINE;
   return 0;
}

//输出结果 50
</code></pre>
<h4 id="a-name262const关键字aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name262const关键字aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="26">2、const关键字</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<pre><code class="language-c++">const type variable = value;
</code></pre>
<p><strong>一个例子</strong></p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

int main()
{
   const int  LENGTH = 10;
   const int  WIDTH  = 5;
   const char NEWLINE = '\n';
   int area;  
   
   area = LENGTH * WIDTH;
   cout &lt;&lt; area;
   cout &lt;&lt; NEWLINE;
   return 0;
} 
</code></pre>
<p>==请注意，把常量定义为大写字母形式，是一个很好的编程实践。==</p>
<blockquote>
<p>此外，define和const是两种不同的定义方式，denfine的定义优先级好像要高于const，通过define方法定义后的变量就不可以再被const利用</p>
</blockquote>
<h2 id="a-name27c-修饰符类型aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name27c-修饰符类型aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="27">C++ 修饰符类型</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>C++ 允许在 <strong>char、int 和 double</strong> 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。</p>
<p>下面列出了数据类型修饰符：</p>
<ul>
<li>signed</li>
<li>unsigned</li>
<li>long</li>
<li>short</li>
</ul>
<p>修饰符 <strong>signed、unsigned、long 和 short</strong> 可应用于整型，<strong>signed</strong> 和 <strong>unsigned</strong> 可应用于字符型，<strong>long</strong> 可应用于双精度型。</p>
<p>修饰符 <strong>signed</strong> 和 <strong>unsigned</strong> 也可以作为 <strong>long</strong> 或 <strong>short</strong> 修饰符的前缀。例如：<strong>unsigned long int</strong>。</p>
<p>C++ 允许使用速记符号来声明<strong>无符号短整数</strong>或<strong>无符号长整数</strong>。您可以不写 int，只写单词 <strong>unsigned short</strong> 或 <strong>unsigned long</strong>，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。</p>
<blockquote>
<p>例如</p>
<p>unsigned x;</p>
<p>unsigned int y;</p>
</blockquote>
<p>为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
 
/* 
 * 这个程序演示了有符号整数和无符号整数之间的差别
*/
int main()
{
   short int i;           // 有符号短整数
   short unsigned int j;  // 无符号短整数

   j = 50000;

   i = j;
   cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j;

   return 0;
} 
</code></pre>
<blockquote>
<p>输出结果为-15536 50000</p>
<p>上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。</p>
</blockquote>
<h2 id="a-name28c-中的类型限定符aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name28c-中的类型限定符aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="28">C++ 中的类型限定符</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>类型限定符提供了变量的额外信息。</p>
<table><thead><tr><th align="left">限定符</th><th align="left">含义</th></tr></thead><tbody>
<tr><td align="left">const</td><td align="left"><strong>const</strong> 类型的对象在程序执行期间不能被修改改变。</td></tr>
<tr><td align="left">volatile</td><td align="left">修饰符 <strong>volatile</strong> 告诉编译器，变量的值可能以程序未明确指定的方式被改变。</td></tr>
<tr><td align="left">restrict</td><td align="left">由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td></tr>
</tbody></table>
<h2 id="a-name29c-存储类aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name29c-存储类aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="29">C++ 存储类</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>mutable</li>
</ul>
<h4 id="a-name301auto-存储类aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name301auto-存储类aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="30">1、auto 存储类</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p><strong>auto</strong> 存储类是所有局部变量默认的存储类。</p>
<pre><code class="language-c++">{
   int mount;
   auto int month;
}
</code></pre>
<p>在函数中定义局部变量时，系统默认认为其为auto储存类</p>
<h4 id="a-name312register-存储类aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name312register-存储类aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="31">2、register 存储类</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&amp;' 运算符（因为它没有内存位置）。</p>
<pre><code class="language-c++">{
   register int  miles;
}
</code></pre>
<p><strong>寄存器只用于需要快速访问的变量</strong>，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>
<!--如果把被储存的东西比作能量：-->
<!--1. 寄存器就是 ATP，可以随时拿来用，性能高，但数量有限；-->
<!--2. 内存就是葡萄糖，性能一般，但是存量可以比较多；-->
<!--3. 外存（比如硬盘）就是脂肪，容量可以非常大，性能很差，要先转化为葡萄糖（存进内存），然后转化为 ATP（放到寄存器）才能直接利用（存取）。-->
<h4 id="a-name323static-存储类aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name323static-存储类aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="32">3、static 存储类</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。<strong>因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</strong></p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。<strong>全局变量默认就是static类型。</strong></p>
<p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p>
<h4 id="a-name334extern储存类相当于定义一个可以多个文件共享的变量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name334extern储存类相当于定义一个可以多个文件共享的变量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="33">4、extern储存类（相当于定义一个可以多个文件共享的变量）</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p>
<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p>
<p>一个例子🌰：</p>
<p>☝🏻第一个文件：main.cpp</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
 
int count ;
extern void write_extern();
 
main()
{
   count = 5;
   write_extern();
}
</code></pre>
<p>2️⃣第二个文件：support.cpp</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
 
extern int count;
 
void write_extern(void)
{
   std::cout &lt;&lt; &quot;Count is &quot; &lt;&lt; count &lt;&lt; std::endl; 
} 
</code></pre>
<p>在这里，第二个文件中的 <em>extern</em> 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示：</p>
<blockquote>
<p>联立编译</p>
<p>$g++ main.cpp support.cpp -o write</p>
<p>然后运行输出的write文件便可以输出</p>
<p>Count is  5</p>
</blockquote>
<p><u>在这里，我的理解相当于extern类似于python中的import函数，可以跨文件声明及引用变量及函数定义，使多个文件可以联立使用</u></p>
<h4 id="a-name345mutable储存类aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name345mutable储存类aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="34">5、mutable储存类</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p><strong>mutable</strong> 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p>
<h2 id="a-name35c-运算符aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name35c-运算符aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="35">C++ 运算符</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>杂项运算符</li>
</ul>
<h4 id="a-name361算数运算符aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name361算数运算符aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="36">1、算数运算符</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>也即一般的加减乘除等基本操作的符号，具体的如下表所示：</p>
<p>假设变量 A 的值为 10，变量 B 的值为 20，则：</p>
<table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody>
<tr><td align="left">+</td><td align="left">把两个操作数相加</td><td align="left">A + B 将得到 30</td></tr>
<tr><td align="left">-</td><td align="left">从第一个操作数中减去第二个操作数</td><td align="left">A - B 将得到 -10</td></tr>
<tr><td align="left">*</td><td align="left">把两个操作数相乘</td><td align="left">A * B 将得到 200</td></tr>
<tr><td align="left">/</td><td align="left">分子除以分母</td><td align="left">B / A 将得到 2</td></tr>
<tr><td align="left">%</td><td align="left">取模运算符，整除后的余数</td><td align="left">B % A 将得到 0</td></tr>
<tr><td align="left">++</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-increment-decrement-operators.html">自增运算符</a>，整数值增加 1</td><td align="left">A++ 将得到 11</td></tr>
<tr><td align="left">--</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-increment-decrement-operators.html">自减运算符</a>，整数值减少 1</td><td align="left">A-- 将得到 9</td></tr>
</tbody></table>
<h4 id="a-name372关系运算符aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name372关系运算符aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="37">2、关系运算符</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>下表显示了 C++ 支持的所有关系运算符。</p>
<p>假设变量 A 的值为 10，变量 B 的值为 20，则：</p>
<table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody>
<tr><td align="left">==</td><td align="left">检查两个操作数的值是否相等，如果相等则条件为真。</td><td align="left">(A == B) 不为真。</td></tr>
<tr><td align="left">!=</td><td align="left">检查两个操作数的值是否相等，如果不相等则条件为真。</td><td align="left">(A != B) 为真。</td></tr>
<tr><td align="left">&gt;</td><td align="left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td><td align="left">(A &gt; B) 不为真。</td></tr>
<tr><td align="left">&lt;</td><td align="left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td><td align="left">(A &lt; B) 为真。</td></tr>
<tr><td align="left">&gt;=</td><td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td><td align="left">(A &gt;= B) 不为真。</td></tr>
<tr><td align="left">&lt;=</td><td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td><td align="left">(A &lt;= B) 为真。</td></tr>
</tbody></table>
<h4 id="a-name383逻辑运算符与或非aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name383逻辑运算符与或非aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="38">3、逻辑运算符（与或非）</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>假设变量 A 的值为 1，变量 B 的值为 0，则：</p>
<table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody>
<tr><td align="left">&amp;&amp;</td><td align="left">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td><td align="left">(A &amp;&amp; B) 为假。</td></tr>
<tr><td align="left">||</td><td align="left">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td><td align="left">(A || B) 为真。</td></tr>
<tr><td align="left">!</td><td align="left">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td><td align="left">!(A &amp;&amp; B) 为真。</td></tr>
</tbody></table>
<h4 id="a-name394位运算符二进制操作aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name394位运算符二进制操作aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="39">4、位运算符（二进制操作）</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p>
<table><thead><tr><th align="left">p</th><th align="left">q</th><th align="left">p &amp; q</th><th align="left">p | q</th><th align="left">p ^ q</th></tr></thead><tbody>
<tr><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr>
<tr><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr>
<tr><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">0</td></tr>
<tr><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr>
</tbody></table>
<p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：</p>
<p>A = 0011 1100</p>
<p>B = 0000 1101</p>
<p>-----------------</p>
<p>A&amp;B = 0000 1100</p>
<p>A|B = 0011 1101</p>
<p>A^B = 0011 0001</p>
<p>~A = 1100 0011</p>
<blockquote>
<p>也就是对数字先转化成二进制，然后再对二进制数字进行调整</p>
</blockquote>
<p>下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：</p>
<table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody>
<tr><td align="left">&amp;</td><td align="left">如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td><td align="left">(A &amp; B) 将得到 12，即为 0000 1100</td></tr>
<tr><td align="left">|</td><td align="left">如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td><td align="left">(A | B) 将得到 61，即为 0011 1101</td></tr>
<tr><td align="left">^</td><td align="left">如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td><td align="left">(A ^ B) 将得到 49，即为 0011 0001</td></tr>
<tr><td align="left">~</td><td align="left">二进制补码运算符是一元运算符，具有&quot;翻转&quot;位效果。</td><td align="left">(~A ) 将得到 -61，即为 1100 0011，2 的补码形式，带符号的二进制数。</td></tr>
<tr><td align="left">&lt;&lt;</td><td align="left">二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td><td align="left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr>
<tr><td align="left">&gt;&gt;</td><td align="left">二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td><td align="left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr>
</tbody></table>
<!--左移位运算：十进制转化为二进制，左右后最后一位补0-->
<!--一个例子🌰：-->
<!--十进制：11-->
<!--二进制：1011-->
<table><thead><tr><th><!--←--></th><th><!--1--></th><th><!--0--></th><th><!--1--></th><th><!--1--></th></tr></thead><tbody>
<tr><td><!--1--></td><td><!--0--></td><td><!--1--></td><td><!--1--></td><td><!--0--></td></tr>
</tbody></table>
<!--完成左移，此时转化为十进制变为22-->
<!--左移几位就是在原数的基础上乘以2的几次方-->
<!--反之，右移位运算则是向右侧移动，不用补位，直接把最右边的那一位吃掉了-->
<h4 id="a-name405赋值运算符aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name405赋值运算符aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="40">5、赋值运算符</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>下表列出了 C++ 支持的赋值运算符：</p>
<table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody>
<tr><td align="left">=</td><td align="left">简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td align="left">C = A + B 将把 A + B 的值赋给 C</td></tr>
<tr><td align="left">+=</td><td align="left">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td align="left">C += A 相当于 C = C + A</td></tr>
<tr><td align="left">-=</td><td align="left">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td align="left">C -= A 相当于 C = C - A</td></tr>
<tr><td align="left">*=</td><td align="left">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td align="left">C *= A 相当于 C = C * A</td></tr>
<tr><td align="left">/=</td><td align="left">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td align="left">C /= A 相当于 C = C / A</td></tr>
<tr><td align="left">%=</td><td align="left">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td><td align="left">C %= A 相当于 C = C % A</td></tr>
<tr><td align="left">&lt;&lt;=</td><td align="left">左移且赋值运算符</td><td align="left">C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td></tr>
<tr><td align="left">&gt;&gt;=</td><td align="left">右移且赋值运算符</td><td align="left">C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td></tr>
<tr><td align="left">&amp;=</td><td align="left">按位与且赋值运算符</td><td align="left">C &amp;= 2 等同于 C = C &amp; 2</td></tr>
<tr><td align="left">^=</td><td align="left">按位异或且赋值运算符</td><td align="left">C ^= 2 等同于 C = C ^ 2</td></tr>
<tr><td align="left">|=</td><td align="left">按位或且赋值运算符</td><td align="left">C |= 2 等同于 C = C | 2</td></tr>
</tbody></table>
<h4 id="a-name416杂项运算符aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name416杂项运算符aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="41">6、杂项运算符</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>下表列出了 C++ 支持的其他一些重要的运算符。</p>
<table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody>
<tr><td align="left">sizeof</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-sizeof-operator.html">sizeof 运算符</a>返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。</td></tr>
<tr><td align="left">Condition ? X : Y</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-conditional-operator.html">条件运算符</a>。如果 Condition 为真 ? 则值为 X : 否则值为 Y。</td></tr>
<tr><td align="left">,</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-comma-operator.html">逗号运算符</a>会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</td></tr>
<tr><td align="left">.（点）和 -&gt;（箭头）</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-member-operators.html">成员运算符</a>用于引用类、结构和共用体的成员。</td></tr>
<tr><td align="left">Cast</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-casting-operators.html">强制转换运算符</a>把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</td></tr>
<tr><td align="left">&amp;</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-pointer-operators.html">指针运算符 &amp;</a> 返回变量的地址。例如 &amp;a; 将给出变量的实际地址。</td></tr>
<tr><td align="left">*</td><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-pointer-operators.html">指针运算符 *</a> 指向一个变量。例如，*var; 将指向变量 var。</td></tr>
</tbody></table>
<h4 id="a-name42c-中的运算符优先级aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name42c-中的运算符优先级aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="42">C++ 中的运算符优先级</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。</p>
<p>例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。</p>
<p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p>
<table><thead><tr><th align="left">类别</th><th align="left">运算符</th><th align="left">结合性</th></tr></thead><tbody>
<tr><td align="left">后缀</td><td align="left">() [] -&gt; . ++ - -</td><td align="left">从左到右</td></tr>
<tr><td align="left">一元</td><td align="left">+ - ! ~ ++ - - (type)* &amp; sizeof</td><td align="left">从右到左</td></tr>
<tr><td align="left">乘除</td><td align="left">* / %</td><td align="left">从左到右</td></tr>
<tr><td align="left">加减</td><td align="left">+ -</td><td align="left">从左到右</td></tr>
<tr><td align="left">移位</td><td align="left">&lt;&lt; &gt;&gt;</td><td align="left">从左到右</td></tr>
<tr><td align="left">关系</td><td align="left">&lt; &lt;= &gt; &gt;=</td><td align="left">从左到右</td></tr>
<tr><td align="left">相等</td><td align="left">== !=</td><td align="left">从左到右</td></tr>
<tr><td align="left">位与 AND</td><td align="left">&amp;</td><td align="left">从左到右</td></tr>
<tr><td align="left">位异或 XOR</td><td align="left">^</td><td align="left">从左到右</td></tr>
<tr><td align="left">位或 OR</td><td align="left">|</td><td align="left">从左到右</td></tr>
<tr><td align="left">逻辑与 AND</td><td align="left">&amp;&amp;</td><td align="left">从左到右</td></tr>
<tr><td align="left">逻辑或 OR</td><td align="left">||</td><td align="left">从左到右</td></tr>
<tr><td align="left">条件</td><td align="left">?:</td><td align="left">从右到左</td></tr>
<tr><td align="left">赋值</td><td align="left">= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |=</td><td align="left">从右到左</td></tr>
<tr><td align="left">逗号</td><td align="left">,</td><td align="left">从左到右</td></tr>
</tbody></table>
<h2 id="a-name43c-循环及控制aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name43c-循环及控制aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="43">C++ 循环及控制</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<h4 id="a-name441循环类型aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name441循环类型aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="44">1、循环类型</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>C++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。</p>
<table><thead><tr><th align="left">循环类型</th><th align="left">描述</th></tr></thead><tbody>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-while-loop.html">while 循环</a></td><td align="left">当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-for-loop.html">for 循环</a></td><td align="left">多次执行一个语句序列，简化管理循环变量的代码。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-do-while-loop.html">do...while 循环</a></td><td align="left">除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-nested-loops.html">嵌套循环</a></td><td align="left">您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td></tr>
</tbody></table>
<h5 id="a-name451while-循环aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name451while-循环aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="45">1、while 循环</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>只要给定的条件为真，<strong>while</strong> 循环语句会重复执行一个目标语句。</p>
<p><strong>语法</strong>⭐️</p>
<pre><code class="language-C++">while(condition) (!!这里没有分号)
{
   statement(s);
}

</code></pre>
<p><strong>一个例子</strong>🌰</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main ()
{
   // 局部变量声明
   int a = 10;

   // while 循环执行
   while( a &lt; 20 )
   {
       cout &lt;&lt; &quot;a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
       a++;
   }
 
   return 0;
}
</code></pre>
<h5 id="a-name462for循环aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name462for循环aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="46">2、for循环</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p><strong>for</strong> 循环允许您编写一个执行特定次数的循环的重复控制结构。</p>
<p><strong>语法</strong>⭐️</p>
<pre><code class="language-C++">for (init; condition; increment)
{
  statement(s);
}
</code></pre>
<p>下面是 for 循环的控制流：</p>
<ol>
<li>
<p><strong>init</strong> 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。</p>
</li>
<li>
<p>接下来，会判断 <strong>condition</strong>。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。</p>
</li>
<li>
<p>在执行完 for 循环主体后，控制流会跳回上面的 <strong>increment</strong> 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。</p>
</li>
<li>
<p>条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。</p>
<p><strong>一个例子</strong>🌰</p>
</li>
</ol>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
 
int main ()
{
   // for 循环执行
   for( int a = 10; a &lt; 20; a = a + 1 )
   {
       cout &lt;&lt; &quot;a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   }
 
   return 0;
}
</code></pre>
<h5 id="a-name473dowhile循环aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name473dowhile循环aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="47">3、do.....while....循环</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>不像 <strong>for</strong> 和 <strong>while</strong> 循环，它们是在循环头部测试循环条件。<strong>do...while</strong> 循环是在循环的尾部检查它的条件。</p>
<p><strong>do...while</strong> 循环与 while 循环类似，但是 do...while 循环会确保至少执行一次循环。</p>
<p><strong>语法</strong>⭐️</p>
<pre><code class="language-C++">do
{
   statement(s);

}while( condition ); (!!!需要注意，这里反而有一个分号)

</code></pre>
<p>请注意，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。</p>
<p>如果条件为真，控制流会跳转回上面的 do，然后重新执行循环中的 statement(s)。这个过程会不断重复，直到给定条件变为假为止。</p>
<p><strong>一个例子</strong>🌰</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main ()
{
   // 局部变量声明
   int a = 10;

   // do 循环执行
   do
   {
       cout &lt;&lt; &quot;a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
       a = a + 1;
   }while( a &lt; 20 );
 
   return 0;
}
</code></pre>
<h5 id="a-name484嵌套的循环aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name484嵌套的循环aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="48">4、嵌套的循环</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>一个循环内可以嵌套另一个循环。C++ 允许至少 256 个嵌套层次。</p>
<p>C++ 中 <strong>嵌套 for 循环</strong> 语句的语法：</p>
<pre><code class="language-C++">for ( init; condition; increment )
{
   for ( init; condition; increment )
   {
      statement(s);
   }
   statement(s); // 可以放置更多的语句
}
</code></pre>
<p>C++ 中 <strong>嵌套 while 循环</strong> 语句的语法：</p>
<pre><code class="language-C++">while(condition)
{
   while(condition)
   {
      statement(s);
   }
   statement(s); // 可以放置更多的语句
}
</code></pre>
<p>C++ 中 <strong>嵌套 do...while 循环</strong> 语句的语法：</p>
<pre><code class="language-C++">do
{
   statement(s); // 可以放置更多的语句
   do
   {
      statement(s);
   }while( condition );

}while( condition );
</code></pre>
<p>此外 多种循环可以相互嵌套</p>
<h4 id="a-name492循环控制语句aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name492循环控制语句aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="49">2、循环控制语句</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。</p>
<p>C++ 提供了下列的控制语句。点击链接查看每个语句的细节。</p>
<table><thead><tr><th align="left">控制语句</th><th align="left">描述</th></tr></thead><tbody>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-break-statement.html">break 语句</a></td><td align="left">终止 <strong>loop</strong> 或 <strong>switch</strong> 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-continue-statement.html">continue 语句</a></td><td align="left">引起循环跳过主体的剩余部分，立即重新开始测试条件。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-goto-statement.html">goto 语句</a></td><td align="left">将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td></tr>
</tbody></table>
<h5 id="a-name501cbreak语句达到条件提前终止aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name501cbreak语句达到条件提前终止aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="50">1、C++break语句（达到条件提前终止）</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>C++ 中 <strong>break</strong> 语句有以下两种用法：</p>
<ol>
<li>当 <strong>break</strong> 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。</li>
<li>它可用于终止 <strong>switch</strong> 语句中的一个 case。</li>
</ol>
<p>如果您使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。</p>
<p><img src="C++%E5%AD%A6%E4%B9%A0/C++.media/1472441083298339.jpg" alt="c++" /></p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main ()
{
   // 局部变量声明
   int a = 10;

   // do 循环执行
   do
   {
       cout &lt;&lt; &quot;a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
       a = a + 1;
       if( a &gt; 15)
       {
          // 终止循环
          break;
       }
   }while( a &lt; 20 );
 
   return 0;
}
</code></pre>
<h5 id="a-name512ccontinue语句额外增加一次判断然后跳过原本执行的语句aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name512ccontinue语句额外增加一次判断然后跳过原本执行的语句aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="51">2、C++continue语句（额外增加一次判断，然后跳过原本执行的语句）</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>C++ 中的 <strong>continue</strong> 语句有点像 <strong>break</strong> 语句。但它不是强迫终止，continue 会跳过当前循环中的代码，强迫开始下一次循环。</p>
<p>对于 <strong>for</strong> 循环，<strong>continue</strong> 语句会导致执行条件测试和循环增量部分。对于 <strong>while</strong> 和 <strong>do...while</strong> 循环，<strong>continue</strong> 语句会导致程序控制回到条件测试上。</p>
<p><img src="C++%E5%AD%A6%E4%B9%A0/C++.media/2EB76530-877A-4AC1-87E6-501CEC7E6CB3.png" alt="img" /></p>
<p>一个例子🌰</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main ()
{
   // 局部变量声明
   int a = 10;

   // do 循环执行
   do
   {
       if( a == 15)
       {
          // 跳过迭代
          a = a + 1;
          continue;
       }
       cout &lt;&lt; &quot;a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
       a = a + 1;
   }while( a &lt; 20 );
 
   return 0;
}
/////////////////输出结果//////////////////////
a 的值： 10
a 的值： 11
a 的值： 12
a 的值： 13
a 的值： 14（因为continue的存在的导致直接越过了15）
a 的值： 16
a 的值： 17
a 的值： 18
a 的值： 19
</code></pre>
<h5 id="a-name523goto-语句-满足某个条件直接蹦到执行某个命令aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name523goto-语句-满足某个条件直接蹦到执行某个命令aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="52">3、goto 语句 （满足某个条件直接蹦到执行某个命令）</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p><strong>goto</strong> 语句允许把控制无条件转移到同一函数内的被标记的语句。</p>
<p>C++ 中 <strong>goto</strong> 语句的语法：</p>
<pre><code class="language-c++">goto label;
..
.
label: statement;
//在这里，label 是识别被标记语句的标识符，可以是任何除 C++ 关键字以外的纯文本。标记语句可以是任何语句，放置在标识符和冒号（:）后边。
</code></pre>
<p><img src="C++%E5%AD%A6%E4%B9%A0/C++.media/1472441355192426-8838760.jpg" alt="C++ goto 语句" /></p>
<p>一个例子🌰</p>
<pre><code class="language-C++">#include&lt;iostream&gt;
using namespace std;
 
int main()
{
    int x,sum=0;
    //定义标号L1
L1: cout&lt;&lt;&quot;x=&quot;;
    cin&gt;&gt;x;
    if (x==-1)
       goto L2;          //当用户输入-1时，转到L2语句处
    else
       sum+=x;
    goto L1;             //只要用户没有输入-1，则转到L1语句处，程序一直将用户的输入默默地累加到变量sum中。
    //定义标号L2
L2: cout&lt;&lt;&quot;sum=&quot;&lt;&lt;sum&lt;&lt;endl;//一旦转到L2，将输出累计结果，程序运行结束。
    system(&quot;pause&quot;);
}
</code></pre>
<h5 id="a-name53无限循环aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name53无限循环aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="53">无限循环</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>如果条件永远不为假则可以完成无限循环，语法比如for（；；）</p>
<h2 id="a-name54c-判断aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name54c-判断aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="54">C++ 判断</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p>
<h4 id="a-name551判断语句aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name551判断语句aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="55">1、判断语句</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>C++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。</p>
<table><thead><tr><th align="left">语句</th><th align="left">描述</th></tr></thead><tbody>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-if.html">if 语句</a></td><td align="left">一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-if-else.html">if...else 语句</a></td><td align="left">一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-nested-if.html">嵌套 if 语句</a></td><td align="left">您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-switch.html">switch 语句</a></td><td align="left">一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-nested-switch.html">嵌套 switch 语句</a></td><td align="left">您可以在一个 <strong>switch</strong> 语句内使用另一个 <strong>switch</strong> 语句。</td></tr>
</tbody></table>
<h5 id="a-name561if语句aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name561if语句aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="56">1、if语句</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</p>
<p>C++ 中 <strong>if</strong> 语句的语法：</p>
<pre><code class="language-C++">if(boolean_expression)
{
   // 如果布尔表达式为真将执行的语句；
}
</code></pre>
<h5 id="a-name572if-else语句aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name572if-else语句aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="57">2、if-else语句</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</p>
<p>C++ 中 <strong>if...else</strong> 语句的语法：</p>
<pre><code class="language-C++">if(boolean_expression)
{
   // 如果布尔表达式为真将执行的语句；
}
else
{
   // 如果布尔表达式为假将执行的语句；
}
</code></pre>
<p>if-else进阶版⭐️</p>
<p>C++ 中的 <strong>if...else if...else</strong> 语句的语法：</p>
<pre><code class="language-C++">if(boolean_expression 1)
{
   // 当布尔表达式 1 为真时执行
}
else if( boolean_expression 2)
{
   // 当布尔表达式 2 为真时执行
}
else if( boolean_expression 3)
{
   // 当布尔表达式 3 为真时执行
}
else 
{
   // 当上面条件都不为真时执行
}
</code></pre>
<h5 id="a-name583嵌套ifaa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name583嵌套ifaa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="58">3、嵌套if</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>C++ 中 <strong>嵌套 if</strong> 语句的语法：</p>
<pre><code class="language-C++">if( boolean_expression 1)
{
   // 当布尔表达式 1 为真时执行
   if(boolean_expression 2)
   {
      // 当布尔表达式 2 为真时执行
   }
}
</code></pre>
<h5 id="a-name594switch语句aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name594switch语句aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="59">4、switch语句⭐️</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 <strong>switch case</strong> 进行检查。</p>
<p>C++ 中 <strong>switch</strong> 语句的语法：</p>
<pre><code class="language-C++">switch(expression){
    case constant-expression  :
       statement(s);
       break; // 可选的
    case constant-expression  :
       statement(s);
       break; // 可选的
  
    // 您可以有任意数量的 case 语句
    default : // 可选的
       statement(s);
}
</code></pre>
<p><strong>switch</strong> 语句必须遵循下面的规则：</p>
<ul>
<li><strong>switch</strong> 语句中的 <strong>expression</strong> 必须是一个<strong>整型或枚举类型</strong>，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。</li>
<li>在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。</li>
<li>case 的 <strong>constant-expression</strong> 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。</li>
<li>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 <strong>break</strong> 语句为止。</li>
<li>当遇到 <strong>break</strong> 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</li>
<li>不是每一个 case 都需要包含 <strong>break</strong>。如果 case 语句不包含 <strong>break</strong>，控制流将会 <em>继续</em> 后续的 case，直到遇到 break 为止。</li>
<li>一个 <strong>switch</strong> 语句可以有一个可选的 <strong>default</strong> case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 <strong>break</strong> 语句不是必需的。</li>
</ul>
<p>一个例子🌰</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main ()
{
   // 局部变量声明
   char grade = 'D';

   switch(grade)
   {
   case 'A' :
      cout &lt;&lt; &quot;很棒！&quot; &lt;&lt; endl; 
      break;
   case 'B' :
   case 'C' :
      cout &lt;&lt; &quot;做得好&quot; &lt;&lt; endl;
      break;
   case 'D' :
      cout &lt;&lt; &quot;您通过了&quot; &lt;&lt; endl;
      break;
   case 'F' :
      cout &lt;&lt; &quot;最好再试一下&quot; &lt;&lt; endl;
      break;
   default :
      cout &lt;&lt; &quot;无效的成绩&quot; &lt;&lt; endl;
   }
   cout &lt;&lt; &quot;您的成绩是 &quot; &lt;&lt; grade &lt;&lt; endl;
 
   return 0;
}
</code></pre>
<p>同样的，switch语句也可以被嵌套使用</p>
<p>C++ 中 <strong>嵌套 switch</strong> 语句的语法：</p>
<pre><code class="language-C++">switch(ch1) {
   case 'A': 
      cout &lt;&lt; &quot;这个 A 是外部 switch 的一部分&quot;;
      switch(ch2) {
         case 'A':
            cout &lt;&lt; &quot;这个 A 是内部 switch 的一部分&quot;;
            break;
         case 'B': // 内部 B case 代码
      }
      break;
   case 'B': // 外部 B case 代码
}
</code></pre>
<h4 id="a-name602--运算符aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name602--运算符aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="60">2、? : 运算符</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>我们已经在前面的章节中讲解了 <a href="https://www.w3cschool.cn/cpp/cpp-conditional-operator.html"><strong>条件运算符 ? :</strong></a>，可以用来替代 <strong>if...else</strong> 语句。它的一般形式如下：</p>
<pre><code>Exp1 ? Exp2 : Exp3;
</code></pre>
<p>其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</p>
<p>? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。</p>
<p>一个例子🌰</p>
<pre><code class="language-C++">//if-else写法
if(a&lt;10){
  var=10
}
else{
  var=20
}

//expression写法
var = (a&lt;10)?10:20;
</code></pre>
<h2 id="a-name61c-函数aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name61c-函数aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="61">C++ 函数</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 <strong>main()</strong> ，所有简单的程序都可以定义其他额外的函数。</p>
<p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p>
<p>函数<strong>声明</strong>告诉编译器函数的名称、返回类型和参数。函数<strong>定义</strong>提供了函数的实际主体。</p>
<p>C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 <strong>strcat()</strong> 用来连接两个字符串，函数 <strong>memcpy()</strong> 用来复制内存到另一个位置。</p>
<p>函数还有很多叫法，比如方法、子例程或程序，等等。</p>
<h4 id="a-name621函数定义aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name621函数定义aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="62">1、函数定义</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>C++ 中的函数定义的一般形式如下：</p>
<p>⭐️ 定义函数时注意不要从主函数main()内部定义，只能从主函数体内部调用</p>
<blockquote>
<p>return_type funcition_name ( parameter_list )</p>
<p>{</p>
<p>​	body of the function </p>
<p>}</p>
</blockquote>
<p>在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：</p>
<ul>
<li>**返回类型：**一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li>
<li>**函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>
<li>**参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>
<li>**函数主体：**函数主体包含一组定义函数执行任务的语句。</li>
</ul>
<p>一个例子🌰</p>
<p>以下是 <strong>max()</strong> 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：</p>
<pre><code class="language-C++">// 函数返回两个数中较大的那个数
 
int max(int num1, int num2) 
{
   // 局部变量声明
   int result;
 
   if (num1 &gt; num2)
      result = num1;
   else
      result = num2;
 
   return result; 
}
</code></pre>
<p><strong>Tips</strong>📢：在函数变量定义时也可以添加形参的默认值，以后在使用的使用可以不赋值直接用，跟python中的使用方法一样。</p>
<h4 id="a-name632函数声明aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name632函数声明aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="63">2、函数声明</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>函数<strong>声明</strong>会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<p>函数声明包括以下几个部分：</p>
<pre><code>return_type function_name( parameter list );
</code></pre>
<p>针对上面定义的函数 max()，以下是函数声明：</p>
<pre><code>int max(int num1, int num2);
</code></pre>
<p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：</p>
<pre><code>int max(int, int);
</code></pre>
<p>⭐️<strong>当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。也就是相当于python中的import函数，或者是相当于从其他文件中引用变量的extern函数</strong>⭐️</p>
<blockquote>
<p>也就是说使用到函数声明的时候一共有两种情况：</p>
<ul>
<li>因为代码是从上到下执行的，如果先定义后引用函数则不需要声明，反之如果先应用而函数定义部分在后面时则需要在文件开头添加函数声明部分</li>
<li>第二种情况，在某个文件中定义了函数后，想要在另一个文件中引用这个函数，则需要在这个文件的开头部分添加函数声明，也就类比与python中的import函数</li>
</ul>
</blockquote>
<h4 id="a-name643函数参数aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name643函数参数aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="64">3、函数参数</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p>
<p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>
<p>当调用函数时，有两种向函数传递参数的方式：</p>
<table><thead><tr><th align="center">调用类型</th><th align="left">描述</th></tr></thead><tbody>
<tr><td align="center"><a href="https://www.w3cschool.cn/cpp/cpp-function-call-by-value.html">传值调用</a>                     （默认）</td><td align="left">该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td></tr>
<tr><td align="center"><a href="https://www.w3cschool.cn/cpp/cpp-function-call-by-pointer.html">指针调用</a></td><td align="left">该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。<strong>这意味着，修改形式参数会影响实际参数。</strong></td></tr>
<tr><td align="center"><a href="https://www.w3cschool.cn/cpp/cpp-function-call-by-reference.html">引用调用</a></td><td align="left">该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。<strong>这意味着，修改形式参数会影响实际参数。</strong></td></tr>
</tbody></table>
<p>一个例子🌰</p>
<pre><code class="language-C++">// 函数定义
								//第一种
/////////////////引用形式/////////////////
void swap(int x, int y)
{
   int temp;

   temp = x; /* 保存 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 x 赋值给 y */
  
   return;
}
/////////////////////////////////////////
								
								//第二种
/////////////////指针形式/////////////////
void swap(int *x, int *y)
{
   int temp;
   temp = *x;	/* 保存地址 x 的值 */
   *x = *y;		/* 把 y 赋值给 x */
   *y = temp;	/* 把 x 赋值给 y */
  
   return;
}
/////////////////////////////////////////

								//第三种
/////////////////引用形式/////////////////
// 函数定义
void swap(int &amp;x, int &amp;y)
{
   int temp;
   temp = x; /* 保存地址 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 x 赋值给 y  */
  
   return;
}

#include &lt;iostream&gt;
using namespace std;
 
int main ()
{
   // 局部变量声明
   int a = 100;
   int b = 200;
 
   cout &lt;&lt; &quot;交换前，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   cout &lt;&lt; &quot;交换前，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;
 
   // 调用函数来交换值
   swap(a, b);
 
   cout &lt;&lt; &quot;交换后，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   cout &lt;&lt; &quot;交换后，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;
 
   return 0;
}
////////////////////运行结果(传值）///////////////////////
交换前，a 的值： 100
交换前，b 的值： 200
交换后，a 的值： 100
交换后，b 的值： 200
📢：从这可以看出，局部变量在函数呗执行完之后就被销毁了，未对外部全局变量产生影响

////////////////////运行结果(指针和引用）///////////////////////
交换前，a 的值： 100
交换前，b 的值： 200
交换后，a 的值： 200
交换后，b 的值： 100
📢：从这可以看出，局部变量在函数呗执行完之后就被销毁了，未对外部全局变量产生影响
</code></pre>
<h2 id="a-name65c-数字aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name65c-数字aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="65">C++ 数字</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>通常，当我们需要用到数字时，我们会使用原始的数据类型，如 <strong>int、short、long、float 和 double</strong> 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 C++ 数据类型一章中讨论过。</p>
<h4 id="a-name661c定义数字aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name661c定义数字aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="66">1、C++定义数字</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>我们已经在之前章节的各种实例中定义过数字。下面是一个 C++ 中定义各种类型数字的综合实例：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main ()
{
   // 数字定义
   short  s;
   int    i;
   long   l;
   float  f;
   double d;
   
   // 数字赋值
   s = 10;      
   i = 1000;    
   l = 1000000; 
   f = 230.47;  
   d = 30949.374;
   
   // 数字输出
   cout &lt;&lt; &quot;short  s :&quot; &lt;&lt; s &lt;&lt; endl;
   cout &lt;&lt; &quot;int    i :&quot; &lt;&lt; i &lt;&lt; endl;
   cout &lt;&lt; &quot;long   l :&quot; &lt;&lt; l &lt;&lt; endl;
   cout &lt;&lt; &quot;float  f :&quot; &lt;&lt; f &lt;&lt; endl;
   cout &lt;&lt; &quot;double d :&quot; &lt;&lt; d &lt;&lt; endl;
 
   return 0;
}

/* 结果输出
short  s :10
int    i :1000
long   l :1000000
float  f :230.47
double d :30949.4*/
</code></pre>
<h4 id="a-name672c数学运算aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name672c数学运算aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="67">2、C++数学运算</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做<strong>内置函数</strong>。您可以在程序中引用这些函数。</p>
<p>C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。</p>
<p>为了利用这些函数，您需要引用数学头文件 ==<strong><cmath></strong>==。</p>
<table><thead><tr><th align="center">序号</th><th align="left">函数 &amp; 描述</th></tr></thead><tbody>
<tr><td align="center">1</td><td align="left"><strong>double cos(double);</strong> 该函数返回弧度角（double 型）的余弦。</td></tr>
<tr><td align="center">2</td><td align="left"><strong>double sin(double);</strong> 该函数返回弧度角（double 型）的正弦。</td></tr>
<tr><td align="center">3</td><td align="left"><strong>double tan(double);</strong> 该函数返回弧度角（double 型）的正切。</td></tr>
<tr><td align="center">4</td><td align="left"><strong>double log(double);</strong> 该函数返回参数的自然对数。</td></tr>
<tr><td align="center">5</td><td align="left"><strong>double pow(double, double);</strong> 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。</td></tr>
<tr><td align="center">6</td><td align="left"><strong>double hypot(double, double);</strong> 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。</td></tr>
<tr><td align="center">7</td><td align="left"><strong>double sqrt(double);</strong> 该函数返回参数的平方根。</td></tr>
<tr><td align="center">8</td><td align="left"><strong>int abs(int);</strong> 该函数返回整数的绝对值。</td></tr>
<tr><td align="center">9</td><td align="left"><strong>double fabs(double);</strong> 该函数返回任意一个十进制数的绝对值。</td></tr>
<tr><td align="center">10</td><td align="left"><strong>double floor(double);</strong> 该函数返回一个小于或等于传入参数的最大整数。</td></tr>
</tbody></table>
<h4 id="a-name683c随机数aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name683c随机数aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="68">3、C++随机数</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 <strong>rand()</strong>，该函数只返回一个伪随机数。生成随机数之前必须先调用 <strong>srand()</strong> 函数。</p>
<p>下面是一个关于生成随机数的简单实例。实例中使用了 <strong>time()</strong> 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;

using namespace std;
 
int main ()
{
   int i,j;
 
   // 设置种子
   srand( (unsigned)time( NULL ) );

   /* 生成 10 个随机数 */
   for( i = 0; i &lt; 10; i++ )
   {
      // 生成实际的随机数
      j= rand();
      cout &lt;&lt;&quot;随机数： &quot; &lt;&lt; j &lt;&lt; endl;
   }

   return 0;
} 
</code></pre>
<h2 id="a-name69c-数组aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name69c-数组aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="69">C++ 数组</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>C++ 支持<strong>数组</strong>数据结构，它可以存储一个<strong>固定大小的相同类型</strong>元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</p>
<p>所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p>
<h4 id="a-name701声明数组aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name701声明数组aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="70">1、声明数组</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p>
<pre><code class="language-C++">type arrayName [ arraySize ];
</code></pre>
<p>这叫做一维数组。<strong>arraySize</strong> 必须是一个大于零的整数常量，<strong>type</strong> 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 <strong>balance</strong>，声明语句如下：</p>
<pre><code class="language-C++">double balance[10];
</code></pre>
<h4 id="a-name712初始化数组aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name712初始化数组aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="71">2、初始化数组</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：</p>
<pre><code class="language-c">double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
</code></pre>
<p>大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。</p>
<p>如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：</p>
<pre><code class="language-C++">double balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0};
</code></pre>
<p>下面这个例子包含了数组声明、赋值、访问的流程</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
#include &lt;iomanip&gt;
using std::setw;
 
int main ()
{
   int n[ 10 ]; // n 是一个包含 10 个整数的数组
 
   // 初始化数组元素          
   for ( int i = 0; i &lt; 10; i++ )
   {
      n[ i ] = i + 100; // 设置元素 i 为 i + 100
   }
   cout &lt;&lt; &quot;Element&quot; &lt;&lt; setw( 13 ) &lt;&lt; &quot;Value&quot; &lt;&lt; endl;
 
   // 输出数组中每个元素的值                     
   for ( int j = 0; j &lt; 10; j++ )
   {
      cout &lt;&lt; setw( 7 )&lt;&lt; j &lt;&lt; setw( 13 ) &lt;&lt; n[ j ] &lt;&lt; endl;
   }
 
   return 0;
}
</code></pre>
<blockquote>
<p>可以看到，数组初始化需要挨个设置，也无法跟python一样直接输出数组，而是需要用循环打印每个元素。</p>
</blockquote>
<h4 id="a-name723多维数组aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name723多维数组aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="72">3、多维数组</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>同样的，C++也可以类似python创建多维数组，具体格式要求如下：</p>
<p>C++ 支持多维数组。多维数组声明的一般形式如下：</p>
<pre><code class="language-c++">type name[size1][size2]...[sizeN];
</code></pre>
<p>例如，下面的声明创建了一个三维 5 . 10 . 4 整型数组：</p>
<pre><code class="language-C++">int threedim[5][10][4];
</code></pre>
<p><strong>初始化二维数组的两种方法</strong></p>
<ul>
<li>多维数组可以通过在括号内为每行指定值来进行初始化。下面是一个带有 3 行 4 列的数组。</li>
</ul>
<pre><code class="language-C++">int a[3][4] = {  
 {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */
 {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */
 {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */
};
</code></pre>
<ul>
<li>内部嵌套的括号是可选的，下面的初始化与上面是等同的：</li>
</ul>
<pre><code class="language-C++">int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
</code></pre>
<p>一个例子🌰</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
//二维数组的定义及输出
int main ()
{
   // 一个带有 5 行 2 列的数组
   int a[5][2] = { {0,0}, {1,2}, {2,4}, {3,6},{4,8}};
 
   // 输出数组中每个元素的值                      
   for ( int i = 0; i &lt; 5; i++ )
      for ( int j = 0; j &lt; 2; j++ )
      {
         cout &lt;&lt; &quot;a[&quot; &lt;&lt; i &lt;&lt; &quot;][&quot; &lt;&lt; j &lt;&lt; &quot;]: &quot;;
         cout &lt;&lt; a[i][j]&lt;&lt; endl;
      }
 
   return 0;
}
</code></pre>
<h4 id="a-name73c-中数组其他相关内容详解aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name73c-中数组其他相关内容详解aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="73">C++ 中数组其他相关内容详解</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>在 C++ 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C++ 程序员必须清楚的一些与数组相关的重要概念：</p>
<table><thead><tr><th align="left">概念</th><th align="left">描述</th></tr></thead><tbody>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-multi-dimensional-arrays.html">多维数组</a></td><td align="left">C++ 支持多维数组。多维数组最简单的形式是二维数组。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-pointer-to-an-array.html">指向数组的指针</a></td><td align="left">您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-passing-arrays-to-functions.html">传递数组给函数</a></td><td align="left">您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-return-arrays-from-function.html">从函数返回数组</a></td><td align="left">C++ 允许从函数返回数组。</td></tr>
</tbody></table>
<ul>
<li>后三个内容需要学习完指针内容后才可以理解，因此此处先搁置占位</li>
</ul>
<h2 id="a-name74c-字符串aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name74c-字符串aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="74">C++ 字符串</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>C++ 提供了以下两种类型的字符串表示形式：</p>
<ul>
<li>C 风格字符串</li>
<li>C++ 引入的 string 类类型</li>
</ul>
<h4 id="a-name751c风格字符串aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name751c风格字符串aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="75">1、C风格字符串</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。<strong>字符串实际上是使用 null 字符 终止的一维字符数组</strong>。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>
<p>下面的声明和初始化创建了一个 &quot;Hello&quot; 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 &quot;Hello&quot; 的字符数多一个。char greeting[6] = {'H', 'e', 'l', 'l', 'o', ''};</p>
<p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p>
<pre><code>char greeting[] = &quot;Hello&quot;;
</code></pre>
<p><img src="C++%E5%AD%A6%E4%B9%A0/C++.media/string_representation.jpg" alt="C/C++ 中的字符串表示" /></p>
<p>其实，您不需要把 <em>null</em> 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 '' 放在字符串的末尾。让我们尝试输出上面的字符串</p>
<pre><code class="language-c">#include &lt;iostream&gt;

using namespace std;

int main ()
{
   char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'};

   cout &lt;&lt; &quot;Greeting message: &quot;;
   cout &lt;&lt; greeting &lt;&lt; endl;

   return 0;
} 
</code></pre>
<p>C++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings:</p>
<table><thead><tr><th align="left">序号</th><th align="left">函数 &amp; 目的</th></tr></thead><tbody>
<tr><td align="left">1</td><td align="left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td></tr>
<tr><td align="left">2</td><td align="left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td></tr>
<tr><td align="left">3</td><td align="left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td></tr>
<tr><td align="left">4</td><td align="left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td></tr>
<tr><td align="left">5</td><td align="left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr>
<tr><td align="left">6</td><td align="left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr>
</tbody></table>
<p>下面的实例使用了上述的一些函数：</p>
<pre><code class="language-c">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

int main ()
{
   char str1[11] = &quot;Hello&quot;;
   char str2[11] = &quot;World&quot;;
   char str3[11];
   int  len ;

   // 复制 str1 到 str3
   strcpy( str3, str1);
   cout &lt;&lt; &quot;strcpy( str3, str1) : &quot; &lt;&lt; str3 &lt;&lt; endl;

   // 连接 str1 和 str2
   strcat( str1, str2);
   cout &lt;&lt; &quot;strcat( str1, str2): &quot; &lt;&lt; str1 &lt;&lt; endl;

   // 连接后，str1 的总长度
   len = strlen(str1);
   cout &lt;&lt; &quot;strlen(str1) : &quot; &lt;&lt; len &lt;&lt; endl;

   return 0;
}
</code></pre>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code class="language-c">strcpy( str3, str1) : Hello
strcat( str1, str2): HelloWorld
strlen(str1) : 10
</code></pre>
<h2 id="a-name76c-中的-string-类aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name76c-中的-string-类aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="76">C++ 中的 String 类</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>C++ 标准库提供了 <strong>string</strong> 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：</p>
<p>现在您可能还无法透彻地理解这个实例，因为到目前为止我们还没有讨论类和对象。所以现在您可以只是粗略地看下这个实例，等理解了面向对象的概念之后再回头来理解这个实例。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt; //这里需要引入string这个模块

using namespace std;

int main ()
{
   string str1 = &quot;Hello&quot;; //建立string类型的字符串，在这里类似于类的实例化，后续字符串操作类似于python中的操作
   string str2 = &quot;World&quot;;
   string str3;
   int  len ;

   // 复制 str1 到 str3
   str3 = str1;
   cout &lt;&lt; &quot;str3 : &quot; &lt;&lt; str3 &lt;&lt; endl;

   // 连接 str1 和 str2
   str3 = str1 + str2;
   cout &lt;&lt; &quot;str1 + str2 : &quot; &lt;&lt; str3 &lt;&lt; endl;

   // 连接后，str3 的总长度
   len = str3.size();
   cout &lt;&lt; &quot;str3.size() :  &quot; &lt;&lt; len &lt;&lt; endl;

   return 0;
} 
</code></pre>
<h2 id="a-name77c-指针aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name77c-指针aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="77">C++ 指针⭐️⭐️</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。</p>
<p>正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;

int main ()
{
   int  var1;
   char var2[10];

   cout &lt;&lt; &quot;var1 变量的地址： &quot;;
   cout &lt;&lt; &amp;var1 &lt;&lt; endl;

   cout &lt;&lt; &quot;var2 变量的地址： &quot;;
   cout &lt;&lt; &amp;var2 &lt;&lt; endl;

   return 0;
}
</code></pre>
<h4 id="a-name78什么是指针aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name78什么是指针aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="78">什么是指针？</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p><strong>指针</strong>是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，==您必须在使用指针存储其他变量地址之前，对其进行声明==。指针变量声明的一般形式为：</p>
<pre><code class="language-C">type *var-name;
</code></pre>
<p>在这里，<strong>type</strong> 是指针的基类型，它必须是一个有效的 C++ 数据类型，<strong>var-name</strong> 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：</p>
<pre><code class="language-C++">int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch     /* 一个字符型的指针 */
</code></pre>
<p>所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。<strong>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</strong></p>
<p>⭐️使用**&amp;<strong>符号来访问变量的地址，使用</strong>***来访问指针对应的具体值。⭐️</p>
<table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody>
<tr><td>&amp;</td><td>取地址</td></tr>
<tr><td>*</td><td>解引用</td></tr>
</tbody></table>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;

int main ()
{
   int  var = 20;   // 实际变量的声明
   int  *ip;        // 指针变量的声明

   ip = &amp;var;       // 在指针变量中存储 var 的地址

   cout &lt;&lt; &quot;Value of var variable: &quot;;
   cout &lt;&lt; var &lt;&lt; endl;

   // 输出在指针变量中存储的地址
   cout &lt;&lt; &quot;Address stored in ip variable: &quot;;
   cout &lt;&lt; ip &lt;&lt; endl;

   // 访问指针中地址的值
   cout &lt;&lt; &quot;Value of *ip variable: &quot;;
   cout &lt;&lt; *ip &lt;&lt; endl;

   return 0;
}

/* 输出结果
Value of var variable: 20
Address stored in ip variable: 0xbfc601ac
Value of *ip variable: 20
*/
</code></pre>
<h4 id="a-name79c-null指针aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name79c-null指针aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="79">C++ NULL指针</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为<strong>空</strong>指针。</p>
<p>NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;

int main ()
{
   int  *ptr = NULL;

   cout &lt;&lt; &quot;ptr 的值是 &quot; &lt;&lt; ptr ;
 
   return 0;
}
//程序输出的结果为：
//ptr 的值是0!
</code></pre>
<p>​	在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。<strong>如果所有未使用的指针都被赋予空值，同时避免使用空指针，就可以防止误用一个未初始化的指针。很多时候，未初始化的变量存有一些垃圾值，导致程序难以调试。</strong>（也就是在定义变量的时候最好初始化不要定义个空的，否则有可能造成意外错误）</p>
<h4 id="a-name80c-指针的算术运算aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name80c-指针的算术运算aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="80">C++ 指针的算术运算</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、-</p>
<p>假设 <strong>ptr</strong> 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：</p>
<pre><code>ptr++
</code></pre>
<p>在执行完上述的运算之后，<strong>ptr</strong> 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 个字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 <strong>ptr</strong> 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。</p>
<h5 id="a-name811递增一个指针aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name811递增一个指针aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="81">1、<strong>递增一个指针</strong></a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，因为数组是一个常量指针。下面的程序递增变量指针，以便顺序访问数组中的每一个元素：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;
const int MAX = 3;

int main ()
{
   int  var[MAX] = {10, 100, 200};
   int  *ptr;

   // 指针中的数组地址
   ptr = var; //这里var代表的是数组第一个变量的地址，因此后续才可以用地址递增访问变量值
   for (int i = 0; i &lt; MAX; i++)
   {
      cout &lt;&lt; &quot;Address of var[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
      cout &lt;&lt; ptr &lt;&lt; endl;

      cout &lt;&lt; &quot;Value of var[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
      cout &lt;&lt; *ptr &lt;&lt; endl;

      // 移动到下一个位置
      ptr++;
   }
   return 0;
}

</code></pre>
<h5 id="a-name822递减一个指针aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name822递减一个指针aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="82">2、递减一个指针</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>同样地，对指针进行递减运算，即把值减去其数据类型的字节数，如下所示：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;
const int MAX = 3;

int main ()
{
   int  var[MAX] = {10, 100, 200};
   int  *ptr;

   // 指针中最后一个元素的地址
   ptr = &amp;var[MAX-1];//与前一种情况不同的是，这里指针直接指向数组最后一个元素，倒着往前访问
   for (int i = MAX; i &gt; 0; i--)
   {
      cout &lt;&lt; &quot;Address of var[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
      cout &lt;&lt; ptr &lt;&lt; endl;

      cout &lt;&lt; &quot;Value of var[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
      cout &lt;&lt; *ptr &lt;&lt; endl;

      // 移动到下一个位置
      ptr--;
   }
   return 0;
}
</code></pre>
<h5 id="a-name833指针的比较aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name833指针的比较aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="83"><strong>3、指针的比较</strong></a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>指针可以用关系运算符进行比较，如 ==、&lt; 和 &gt;。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。</p>
<p>下面的程序修改了上面的实例，只要变量指针所指向的地址小于或等于数组的最后一个元素的地址 &amp;var[MAX - 1]，则把变量指针进行递增：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;
const int MAX = 3;

int main ()
{
   int  var[MAX] = {10, 100, 200};
   int  *ptr;

   // 指针中第一个元素的地址,数组中元素越靠后对应的指针值越大
   ptr = var;
   int i = 0;
   while ( ptr &lt;= &amp;var[MAX - 1] )
   {
      cout &lt;&lt; &quot;Address of var[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
      cout &lt;&lt; ptr &lt;&lt; endl;

      cout &lt;&lt; &quot;Value of var[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
      cout &lt;&lt; *ptr &lt;&lt; endl;

      // 指向上一个位置
      ptr++;
      i++;
   }
   return 0;
}

</code></pre>
<h4 id="a-name84c指针vs数组aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name84c指针vs数组aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="84">C++指针VS数组</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>​	指针和数组是密切相关的。事实上，指针和数组在很多情况下是可以互换的。例如，一个指向数组开头的指针，<strong>可以通过使用指针的算术运算或数组索引来访问数组</strong>。类似于上文中举例的使用指针访问数组中元素的具体数值。==指针就类似于数组的索引==</p>
<p>但是！！，数组和指针并不是完全相等可以无条件交换的！！！</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
 
using namespace std;
const int MAX = 3;
 
int main ()
{
   int  var[MAX] = {10, 100, 200};
 
   for (int i = 0; i &lt; MAX; i++)
   {
      *var = i;    // 这是正确的语法,
      var++;       // 这是不正确的 这是因为在这里var是一个指针常量，如果想要改变他时则编译器就会自动报错
   }
   return 0;
}
</code></pre>
<h4 id="a-name85c指针数组aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name85c指针数组aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="85">C++指针数组</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>数组除了可以储存int,char等类别外，同样可以储存指针类型</p>
<p>下面是一个指向整数的指针数组的声明：</p>
<pre><code class="language-C++">int *ptr[MAX];
</code></pre>
<p>在这里，把 <strong>ptr</strong> 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。下面的实例用到了三个整数，它们将存储在一个指针数组中，如下所示:</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
 
using namespace std;
const int MAX = 3;
 
int main ()
{
   int  var[MAX] = {10, 100, 200};
   int *ptr[MAX];
 
   for (int i = 0; i &lt; MAX; i++)
   {
      ptr[i] = &amp;var[i]; // 赋值为整数的地址
   }
   for (int i = 0; i &lt; MAX; i++)
   {
      cout &lt;&lt; &quot;Value of var[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
      cout &lt;&lt; *ptr[i] &lt;&lt; endl;
   }
   return 0;
}

</code></pre>
<p>也可以用一个指向字符的指针数组来存储一个字符串列表，如下：</p>
<pre><code class="language-C++">const char *names[4] = {
                   &quot;Zara Ali&quot;,
                   &quot;Hina Ali&quot;,
                   &quot;Nuha Ali&quot;,
                   &quot;Sara Ali&quot;,}
////////此外，还有定义字符串列表的另一种方法
char names[4] = {
                   'a',
                   'b',
                   'c',
                   'd',}//此时不能储存字符串，只能储存单个的字母
</code></pre>
<h5 id="a-name86c-指向指针的指针多级间接寻址aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name86c-指向指针的指针多级间接寻址aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="86">C++ 指向指针的指针（多级间接寻址）</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。</p>
<p>一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：</p>
<pre><code class="language-C++">int **var;	
//同样的，为了解析指针储存的变量值，需要使用两个**来进行解耦
</code></pre>
<pre><code class="language-C++">#include &lt;iostream&gt;
 
using namespace std;
 
int main ()
{
   int  var;
   int  *ptr;
   int  **pptr;

   var = 3000;

   // 获取 var 的地址
   ptr = &amp;var;

   // 使用运算符 &amp; 获取 ptr 的地址
   pptr = &amp;ptr;

   // 使用 pptr 获取值
   cout &lt;&lt; &quot;Value of var :&quot; &lt;&lt; var &lt;&lt; endl;
   cout &lt;&lt; &quot;Value available at *ptr :&quot; &lt;&lt; *ptr &lt;&lt; endl;
   cout &lt;&lt; &quot;Value available at **pptr :&quot; &lt;&lt; **pptr &lt;&lt; endl;

   return 0;
}
// 就是个指针的嵌套
</code></pre>
<h5 id="a-name87c-传递指针给函数aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name87c-传递指针给函数aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="87">C++ 传递指针给函数</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>C++ 允许您传递指针给函数，只需要简单地声明函数参数为指针类型即可。</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;ctime&gt;
 
using namespace std;
void getSeconds(unsigned long *par);

int main ()
{
   unsigned long sec;


   getSeconds( &amp;sec );

   // 输出实际值
   cout &lt;&lt; &quot;Number of seconds :&quot; &lt;&lt; sec &lt;&lt; endl;

   return 0;
}

void getSeconds(unsigned long *par)
{
   // 获取当前的秒数
   *par = time( NULL );
   return;
}
//返回值
Number of seconds :1294450468
</code></pre>
<p>能接受指针作为参数的函数，也能接受数组作为参数，如下所示：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
// 函数声明
double getAverage(int *arr, int size);
 
int main ()
{
   // 带有 5 个元素的整型数组
   int balance[5] = {1000, 2, 3, 17, 50};
   double avg;
 
   // 传递一个指向数组的指针作为参数
   avg = getAverage( balance, 5 ) ;
 
   // 输出返回值
   cout &lt;&lt; &quot;Average value is: &quot; &lt;&lt; avg &lt;&lt; endl; 
    
   return 0;
}

double getAverage(int *arr, int size)
{
  int    i, sum = 0;       
  double avg;          
 
  for (i = 0; i &lt; size; ++i)
  {
    sum += arr[i];
   }
 
  avg = double(sum) / size;
 
  return avg;
}

</code></pre>
<p>数组≈指针，但是指针的概念要大于数组，指针比数组更加灵活</p>
<h5 id="a-name88c-从函数返回指针数组aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name88c-从函数返回指针数组aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="88">C++ 从函数返回指针/数组</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>C++ 不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针</p>
<pre><code class="language-C++">int * myFunction()
{
.
.
.
}

</code></pre>
<p><strong>另外，C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。</strong></p>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;ctime&gt;
 
using namespace std;
 
// 要生成和返回随机数的函数
int * getRandom( )
{
  static int  r[10];//⭐️在这里！！！！，要用static，否则虽然函数会生成r，但是在函数执行完毕后就会被销毁，这时返回的指针不能正确指示数组的情况✅
 
  // 设置种子
  srand( (unsigned)time( NULL ) );
  for (int i = 0; i &lt; 10; ++i)
  {
    r[i] = rand();
    cout &lt;&lt; r[i] &lt;&lt; endl;
  }
 
  return r;
}
 
// 要调用上面定义函数的主函数
int main ()
{
   // 一个指向整数的指针
   int *p;
 
   p = getRandom();
   for ( int i = 0; i &lt; 10; i++ )
   {
       cout &lt;&lt; &quot;*(p + &quot; &lt;&lt; i &lt;&lt; &quot;) : &quot;;
       cout &lt;&lt; *(p + i) &lt;&lt; endl;
   }
 
   return 0;
}

</code></pre>
<h2 id="a-name89c-指针总结及相关容易混淆概念aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name89c-指针总结及相关容易混淆概念aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="89">C++ 指针总结及相关容易混淆概念</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<h4 id="a-name90一内存和地址aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name90一内存和地址aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="90"><strong>一，内存和地址</strong></a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>我们知道，计算机内存的每个字节都有一个唯一的地址，CPU每次寻址就是通过固定的步长（这就解释了为什么需要内存对齐）来跳跃进行寻址的。举个例子，我们可以把内存看做是一条长街上的一排房屋，每个房屋都有自己固定的门牌号，每座房屋里面都可以容纳数据，为了读取到某个房屋里面的数据，我们必须知道这个房屋的门牌号，根据这个门牌号来打开这个房间，取走数据。同样，计算机也必须为每个内存字节都编上号码，就像门牌号一样，每个字节的编号是唯一的，根据编号可以准确地找到某个字节。</p>
<h4 id="a-name91二指针的本质就是地址-aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name91二指针的本质就是地址-aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="91"><strong>二，指针的本质就是地址</strong> </a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>当我们在程序中声明一个变量并给这个变量赋值的时候，编译器做了什么呢？实际上，变量名代表内存中的一个存储单元，在编译器对程序编译连接的时候由系统给变量分配一个地址：</p>
<pre><code class="language-cpp">int a = 10;
</code></pre>
<p>上面这行代码我们定义并初始化了这个变量a，系统会为a分配一块内存单元，a只是这块内存单元的别名，在程序中从变量中取值，实际上是通过变量名找到相应的内存单元，从其中读取数据。</p>
<img src="C++学习/C++.media/v2-94eddad728ee414bc95200bbe9334cca_720w-9098341.jpg" alt="img" style="zoom:67%;" />
<p>假如系统为变量 a 分配的内存地址为0xFF00, 那么我们可以说这个地址就是变量 a 的门牌号。<strong>一个变量的地址称为该变量的指针</strong>。所以说，<strong>指针的本质就是地址，指针变量是一种特殊的变量，它专门保存指针(也即地址)，当我们说这个地址对应的内存单元的时候，我们可以说这个指针指向这块内存单元。</strong></p>
<p>例如：</p>
<pre><code class="language-cpp">int a = 10;  
int* p = &amp;a;  //定义指针变量 p
*p = 20;      //将指针p指向的值修改为 20
</code></pre>
<ul>
<li>上面两行代码中，我们首先定义了一个整型变量 a ,- </li>
<li>然后又定义了一个指针变量 p 指向 a .第二行代码中，符号&amp;代表取地址，相当于把变量a的地址赋值给了指针变量p(p指向a)，- </li>
<li>加在指针变量前面代表解引用，意思找到指针p指向的值，因此，第三行代码的意思就是讲p指向的值也就是a修改为20.<strong>总之一定要记住，符号&amp;代表取值，符号⭐️代表解引用。</strong></li>
</ul>
<table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody>
<tr><td>&amp;</td><td>取地址</td></tr>
<tr><td>*</td><td>解引用</td></tr>
</tbody></table>
<p>这三行代码的内存模型如下：</p>
<p><img src="C++%E5%AD%A6%E4%B9%A0/C++.media/v2-c5ca0796ded98350603aed46799cdffa_720w.jpg" alt="img" /></p>
<p>我们假设系统给变量 a 分配的内存首地址为2000，我们又声明了一个指针变量p，<strong>这个p也是要占用内存空间的</strong>，只不过这个变量p保存的内容是变量a的地址，也就是2000，当我们想通过p来操纵a的话，首先要根据p保存的地址找到它指向的内容，也就是解引用<em>p，当</em>p的内容放生改变的时候，首地址为2000的内存单元存储的值也会做出改变，因此变量当*p被重新赋值为20的时候，变量a的值也会做出改变，变为20.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;ctime&gt;
 
using namespace std;
// 要调用上面定义函数的主函数
int main ()
{
   // 一个指向整数的指针
   int a = 3;
   int *p;
   p = &amp;a; 
   cout &lt;&lt; p &lt;&lt; endl;
   cout &lt;&lt; *p&lt;&lt; endl;
   cout &lt;&lt; &amp;p&lt;&lt; endl;

 
   return 0;
}
//输出结果
0x16f1874d4
3
0x16f1874c8
</code></pre>
<p>由此扩展到二级指针，如果我们再定义一个指针变量q来指向p，那么q就是一个二级指针，因为它指向的对象还是一个指针，只不过比他自己低一级，是一级指针,那么二级指针如何定义呢，请看下面的代码：</p>
<pre><code class="language-cpp">int a = 10;
int* p = &amp;a;
int** q = &amp;p; 
</code></pre>
<p>上面第三行代码就是定义了一个二级指针q，它指向的是一级指针p，而一级指针p又指向了变量a，它的内存模型如下图所示：</p>
<p><img src="C++%E5%AD%A6%E4%B9%A0/C++.media/v2-fe08bdfd089fc437adee0b6abaa70d93_720w.jpg" alt="img" /></p>
<p>二级指针q保存的内容为一级指针p的地址而非内容，注意p地址是2008，p的内容为2000. 因此对q进行解引用也即q得出的是p,也就是2008,再对(q)进行解引用也即(q)得出的才是变量a的值，由于运算符的结合性自右向左，因此括号可以省略，也即**q才是a的值。</p>
<h4 id="a-name92三一些容易混淆的重要内容aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name92三一些容易混淆的重要内容aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="92">三，一些容易混淆的重要内容</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<h5 id="a-name931常量指针与指针常量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name931常量指针与指针常量aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="93">1、常量指针与指针常量</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>请看下面两行代码：</p>
<pre><code class="language-cpp">int a = 10; //const跟谁挨得近谁就是常量
const int * p1 = &amp;a;    //常量指针：指向常量的指针变量
int * const p2 = &amp;a;    //指针常量：指向变量的常量指针
</code></pre>
<p>上面第二行代码中的p1是一个常量指针，就是指向常量的指针变量。意味着它指向的值不可以修改，但是指针的指向可以修改：</p>
<pre><code class="language-cpp">int a = 10;
int b = 20;
const int * p1 = &amp;a;    //常量指针
*p1 = 100;  //错误，常量指针指向的值不可以修改
p1 = &amp;b;   //正确
</code></pre>
<p>而对于指针常量，它本质是一个常量，但是由指针修饰。意味着它指向的值可以修改，但是指针的指向不可修改，与常量指针刚刚相反：</p>
<pre><code class="language-cpp">int a = 10;
int b = 20;
int * const p1 = &amp;a;    //指针常量
*p1 = 100;  //正确
p1 = &amp;b;   //错误，指针的指向不可以修改
</code></pre>
<p><strong>对照表😀</strong></p>
<table><thead><tr><th>名称</th><th>意义</th><th>特点</th></tr></thead><tbody>
<tr><td>const int * p</td><td>常量指针</td><td>指向可修改，指向的值不可修改</td></tr>
<tr><td>int * const p</td><td>指针常量</td><td>指向不可修改，指向的值可修改</td></tr>
</tbody></table>
<h5 id="a-name942指针与数组aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name942指针与数组aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="94">2、指针与数组</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>一维数组名本身就是一个指针，但是在使用的过程中要小心，因为这个指针分为指向数组首元素的指针与指向整个数组的指针，那么如何区分它们呢？我们来看下面几行代码：</p>
<pre><code class="language-cpp">int arr[] = {1, 2, 3, 4, 5};
int* p1 = arr;
int* p2 = &amp;arr[0]; //都是默认指向第一个值得地址
int* p3 = &amp;arr;    //报错
</code></pre>
<p>上面三行代码中，其中p1与p2是等价的，因为<strong>数组名arr本身就是一个指针</strong>，**但是这个指针不是指向整个数组，而是指向数组的首元素的地址。**第四行直接报错，因为&amp;arr指的是整个数组的指针，不能把数组指针赋值给整形指针。虽然arr与&amp;arr在数值上是相同的，但是两者意义不同。意味着&amp;arr它的步长为整个数组，而对于arr，步长为单个元素。</p>
<p>所以，我们得出结论，对于一维数组arr：</p>
<table><thead><tr><th>名称</th><th>意义</th><th>步长</th></tr></thead><tbody>
<tr><td>arr</td><td>指向数组首元素</td><td>单个元素</td></tr>
<tr><td>&amp;arr[0]</td><td>指向数组首元素</td><td>单个元素</td></tr>
<tr><td>&amp;arr</td><td>指向整个数组</td><td>整个数组</td></tr>
</tbody></table>
<p>在定义了指向数组首元素的指针变量后，我们可以通过这个指针变量来访问数组元素：</p>
<pre><code class="language-cpp"> int arr[] = { 1,2,3,4,5 };
  int* p1 = arr;
  int length = sizeof(arr) / sizeof(int);
  for (int i = 0; i &lt; length; i++)
  {
    cout &lt;&lt; p1[i] &lt;&lt; endl; //这里相当于把p1和arr直接画了等号
    cout &lt;&lt; *(p1 + i) &lt;&lt; endl; //这里则是使用解析引用返回数组中的数值
  }
</code></pre>
<p>上面几行代码中，p1[i]与*(p1+i)两者是等价的，所以输出的结果一样。但是要注意，当用sizeof操作符操作arr的时候，这个时候不能把arr当做一个指针来对待，因为sizeof操作数组的时候它返回的是数组的字节长度，而单个指针变量只占用四个字节。上面循环体中，我们也可以通过下面方式访问：</p>
<pre><code class="language-cpp">cout &lt;&lt; *p1++ &lt;&lt; endl;  
cout &lt;&lt; *(p1++) &lt;&lt; endl;
</code></pre>
<p><em>p1++与</em>(p1++)是等价的，这是因为++的运算符优先级比<em>要高，因此不管你加不加括号，都会优先执行p++，然而p++是先返回p的值，再与</em>结合，最后p再向后移动一位。</p>
<p>不过在这里要特别注意，有一种情况下我们是不能通过sizeof操作符来计算数组的长度的，就是当数组名作为函数参数传递的时候：</p>
<pre><code class="language-cpp">void test(int arr[])
{
  int lenth = sizeof(arr) / sizeof(int);
}
</code></pre>
<p>上面这行代码语法上没有问题，但是得出的结果却不是我们想要的结果，为什么呢，这是因为数组名作为函数传递的时候，会退化成一个指针，如果是二维数组的话，会退化成指向一维数组的指针，所以sizeof(arr)计算出来的结果就不是数组的字节长度了。所以说，在c/c++中传递数组的时候，一般我们也会把数组的长度作为形参传递过去。</p>
<p>但是我们不能通过下面方式去访问数组元素：</p>
<pre><code class="language-cpp">cout &lt;&lt; *arr++ &lt;&lt; endl;    //报错
</code></pre>
<p>这是因为arr本身是一个<strong>指针常量</strong>，指针的指向不可更改，因此编译器直接报错。</p>
<p><strong>3、数组指针与指针数组</strong></p>
<p>数组指针顾名思义，本质就是一个指针，这个指针指向整个数组；指针数组本质上是一个数组，但是数组的每个元素都是指针。</p>
<pre><code class="language-cpp">int (*p2)[10];  //数组指针
int *p1[10];    //指针数组
</code></pre>
<p>上面两行代码，p1是一个数组，而p2却是一个指针，它指向一个匿名数组。为什么是这样呢？这是因为[]的优先级比*要高。p1 先与[]结合，构成一个数组的定义，数组名为p1，int *修饰的是数组的内容，即数组的每个元素。那现在我们清楚，这是一个数组，其包含10 个指向int 类型数据的指针，即指针数组。至于p2 就更好理解了，在这里括号的优先级比[]高，*号和p2 构成一个指针的定义，指针变量名为p2，int 修饰的是数组的内容，即数组的每个元素。数组在这里并没有名字，是个匿名数组。那现在我们清楚p2 是一个指针，它指向一个包含10 个int 类型数据的数组，即数组指针。</p>
<p><img src="C++%E5%AD%A6%E4%B9%A0/C++.media/v2-0748696dcdccff7cd64082d2c53d6293_1440w-9105157.jpg" alt="img" /></p>
<p>p1为数组名，每个元素都是int型指针</p>
<p><img src="C++%E5%AD%A6%E4%B9%A0/C++.media/v2-30e1d5983c4feea1f2e8b2866f61c9da_1440w.jpg" alt="img" /></p>
<p>p2为指针变量，指向一个匿名数组</p>
<p>如果我们定义： </p>
<pre><code class="language-cpp">int(*p)[10] = &amp;arr;
</code></pre>
<p>那么如何访问数组的元素呢？且看，由于上行代码中，p=&amp;arr，那么对其解引用，*p就是arr，因此我们可以通过(*p)[]来进行访问数组的元素： </p>
<pre><code class="language-cpp">for(int i = 0; i &lt; 10; i++)
{
  cout&lt;&lt; (*p)[i] &lt;&lt; endl;
}
</code></pre>
<h5 id="a-name954指针函数与函数指针aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name954指针函数与函数指针aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="95"><strong>4、指针函数与函数指针</strong></a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h5>
<p>指针函数顾名思义，他是一个函数，但返回值是一个指针，例如下面这几行代码：</p>
<pre><code class="language-cpp">int* test()
{
  int a = 10;
  int* p = &amp;a;
  return p;
}
</code></pre>
<p>这个test就是一个指针函数，它返回的是一个int型的指针。</p>
<p>函数指针本质是一个指针，这个指针指向一个函数，那么我们如何定义函数指针呢？请看下面代码：</p>
<pre><code class="language-cpp">int myAdd(int a, int b)
{
  return a + b;
}
void test()
{
  int(*pFun)(int, int) = myAdd;    //定义一个函数指针，（）增加了优先级以便可以构成指针结构
  cout &lt;&lt; (*pFun)(2, 5) &lt;&lt; endl;    //用函数指针调用函数
  cout &lt;&lt; pFun(2, 5) &lt;&lt; endl;      //用函数指针调用函数
}
</code></pre>
<p>一个巨复杂的例子🌰：</p>
<pre><code class="language-cpp">char *(* c[10])(int **p);
</code></pre>
<p>乍一看，让人眼花缭乱，不知道是什么东西，在这里请大家记住一个规则：C语言标准规定，对于一个符号的定义，编译器总是从它的名字开始读取，然后按照优先级顺序依次解析。注意是从名字开始，不是从开头也不是从末尾，这是理解复杂指针的关键。</p>
<p>有了上面的规则，我们来逐步剖析上面哪行代码的意义：</p>
<p>首先从*c[10]开始，由于[]的优先级比*高，因此，*c[10]代表一个指针数组，每个元素都是指针，但类型还不知道。再看右边的(int** p)，它是一个函数，参数为一个二级指针。最左边char* 代表这个函数的返回类型。因此，整行代码的含义就是：c 是一个拥有 10 个元素的指针数组，数组每个元素指向一个原型为char *(int **p)的函数。</p>
<h2 id="a-name96c-引用理解成一种特殊的指针aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name96c-引用理解成一种特殊的指针aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="96">C++ 引用（理解成一种特殊的指针）</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<h4 id="a-name971基本定义aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name971基本定义aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="97">1、基本定义</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>
<p>引用<strong>很容易与指针混淆</strong>，它们之间有三个主要的不同：</p>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
</ul>
<p>一个例子🌰</p>
<p>例如：</p>
<pre><code class="language-cpp">int    i = 17;
</code></pre>
<p>我们可以为 i 声明引用变量，如下所示：</p>
<pre><code class="language-cpp">int&amp;    r = i;
</code></pre>
<p>在这些声明中，&amp; 读作<strong>引用</strong>。因此，第一个声明可以读作 &quot;r 是一个初始化为 i 的整型引用&quot;，第二个声明可以读作 &quot;s 是一个初始化为 d 的 double 型引用&quot;。下面的实例使用了 int 和 double 引用：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
 
using namespace std;
 
int main ()
{
   // 声明简单的变量
   int    i;
   double d;
 
   // 声明引用变量
   int&amp;    r = i;
   double&amp; s = d;
   
   i = 5;
   cout &lt;&lt; &quot;Value of i : &quot; &lt;&lt; i &lt;&lt; endl;
   cout &lt;&lt; &quot;Value of i reference : &quot; &lt;&lt; r  &lt;&lt; endl;
 
   d = 11.7;
   cout &lt;&lt; &quot;Value of d : &quot; &lt;&lt; d &lt;&lt; endl;
   cout &lt;&lt; &quot;Value of d reference : &quot; &lt;&lt; s  &lt;&lt; endl;
   
   return 0;
}
//输出结果
Value of i : 5
Value of i reference : 5
Value of d : 11.7
Value of d reference : 11.7
</code></pre>
<h4 id="a-name982把引用作为函数参数aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name982把引用作为函数参数aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="98">2、把引用作为函数参数</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
// 函数声明
void swap(int&amp; x, int&amp; y);
 
int main ()
{
   // 局部变量声明
   int a = 100;
   int b = 200;
 
   cout &lt;&lt; &quot;交换前，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   cout &lt;&lt; &quot;交换前，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;
 
   /* 调用函数来交换值 */
   swap(a, b);
 
   cout &lt;&lt; &quot;交换后，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;
   cout &lt;&lt; &quot;交换前，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;
 
   return 0;
}
 
// 函数定义
void swap(int&amp; x, int&amp; y)
{
   int temp;
   temp = x; /* 保存地址 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 x 赋值给 y  */
  
   return;
}
//输出结果
交换前，a 的值： 100
交换前，b 的值： 200
交换后，a 的值： 200
交换后，b 的值： 100
</code></pre>
<h4 id="a-name993把引用作为函数返回值aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name993把引用作为函数返回值aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="99">3、把引用作为函数返回值</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;ctime&gt;
 
using namespace std;
 
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
 
double&amp; setValues( int i )
{
  return vals[i];   // 返回第 i 个元素的引用
}
 
// 要调用上面定义函数的主函数
int main ()
{
 
   cout &lt;&lt; &quot;改变前的值&quot; &lt;&lt; endl;
   for ( int i = 0; i &lt; 5; i++ )
   {
       cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
       cout &lt;&lt; vals[i] &lt;&lt; endl;
   }
 
   setValues(1) = 20.23; // 改变第 2 个元素
   setValues(3) = 70.8;  // 改变第 4 个元素
 
   cout &lt;&lt; &quot;改变后的值&quot; &lt;&lt; endl;
   for ( int i = 0; i &lt; 5; i++ )
   {
       cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
       cout &lt;&lt; vals[i] &lt;&lt; endl;
   }
   return 0;
}
//输出结果
改变前的值
vals[0] = 10.1
vals[1] = 12.6
vals[2] = 33.1
vals[3] = 24.1
vals[4] = 50
改变后的值
vals[0] = 10.1
vals[1] = 20.23
vals[2] = 33.1
vals[3] = 70.8
vals[4] = 50
</code></pre>
<p><strong>当返回一个引用时，要注意被引用的对象不能超出作用域</strong>。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。</p>
<pre><code class="language-C++">int&amp; func() {
   int q;
   //! return q; // 在编译时发生错误
   static int x;
   return x;     // 安全，x 在函数作用域外依然是有效的
}
</code></pre>
<h2 id="a-name100c-基本的输入输出aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name100c-基本的输入输出aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="100">C++ 基本的输入输出</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做<strong>输入操作</strong>。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做<strong>输出操作</strong>。</p>
<h4 id="a-name1011io-库头文件aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name1011io-库头文件aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="101">1、I/O 库头文件</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>下列的头文件在 C++ 编程中很重要。</p>
<table><thead><tr><th align="left">头文件</th><th align="left">函数和描述</th></tr></thead><tbody>
<tr><td align="left"><iostream></td><td align="left">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td></tr>
<tr><td align="left"><iomanip></td><td align="left">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I/O 有用的服务。</td></tr>
<tr><td align="left"><fstream></td><td align="left">该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</td></tr>
</tbody></table>
<h4 id="a-name1022标准输出流coutaa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name1022标准输出流coutaa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="102">2、标准输出流（cout）</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>预定义的对象 <strong>cout</strong> 是 <strong>ostream</strong> 类的一个实例。cout 对象&quot;连接&quot;到标准输出设备，通常是显示屏。<strong>cout</strong> 是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main( )
{
   char str[] = &quot;Hello C++&quot;;
   cout &lt;&lt; &quot;Value of str is : &quot; &lt;&lt; str &lt;&lt; endl; 
} 
</code></pre>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code class="language-C++">Value of str is : Hello C++
</code></pre>
<p>C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。</p>
<p>==流插入运算符 &lt;&lt;== 在一个语句中可以多次使用，如上面实例中所示，<strong>endl</strong> 用于在行末添加一个换行符。</p>
<h4 id="a-name1033标准输入流cinaa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name1033标准输入流cinaa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="103">3、标准输入流（cin)</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>预定义的对象 <strong>cin</strong> 是 <strong>istream</strong> 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。<strong>cin</strong> 是与==流提取运算符 &gt;&gt;== 结合使用的，如下所示：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main( )
{
    char name[50];
    int age;
    cout &lt;&lt; &quot;请输入您的名称： &quot;;
    cin &gt;&gt; name;
    cout &lt;&lt; &quot;您的名称是： &quot; &lt;&lt; name &lt;&lt; endl;   
    cout &lt;&lt;&quot;请输入年龄&quot;;
    cin &gt;&gt; age;
    if (age &gt; 10){
      cout &lt;&lt; &quot;your age is older than 10&quot;;
    }else{
      cout &lt;&lt; &quot;your are so young&quot;;
    }
} 
</code></pre>
<p>C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。</p>
<p>流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：</p>
<pre><code class="language-C++">cin &gt;&gt; name &gt;&gt; age;
</code></pre>
<p>这相当于下面两个语句：</p>
<pre><code class="language-c++">cin &gt;&gt; name;
cin &gt;&gt; age;
</code></pre>
<h4 id="a-name1044标准错误流cerraa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name1044标准错误流cerraa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="104">4、标准错误流（cerr)</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>预定义的对象 <strong>cerr</strong> 是 <strong>ostream</strong> 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 <strong>cerr</strong> 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</p>
<p><strong>cerr</strong> 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main( )
{
   char str[] = &quot;Unable to read....&quot;;
   cerr &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl; 
} 
</code></pre>
<h4 id="a-name1055标准日志流clogaa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name1055标准日志流clogaa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="105">5、标准日志流（clog)</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>预定义的对象 <strong>clog</strong> 是 <strong>ostream</strong> 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 <strong>clog</strong> 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区中，直到缓冲填满或者缓冲区刷新时才会输出。</p>
<p><strong>clog</strong> 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
int main( )
{
   char str[] = &quot;Unable to read....&quot;;
   clog &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl;
} 
</code></pre>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code class="language-C++">Error message : Unable to read....
</code></pre>
<h2 id="a-name106c-数据结构aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name106c-数据结构aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="106">C++ 数据结构</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h2>
<p>C/C++ 数组允许定义可存储相同类型数据项的变量，但是<strong>结构是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</strong></p>
<p>结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：</p>
<ul>
<li>Title</li>
<li>Author</li>
<li>Subject</li>
<li>Book ID</li>
</ul>
<h4 id="a-name1071数据结构的定义aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name1071数据结构的定义aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="107">1、数据结构的定义</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>为了定义结构，您必须使用 <strong>struct</strong> 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>
<pre><code class="language-C++">struct [structure tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more structure variables];  
</code></pre>
<p><strong>structure tag</strong> 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明 Book 结构的方式：</p>
<pre><code class="language-C++">struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
}book; //分号必不可少
// 这里的book相当于在定义struct的同时就默认初始化了一个变量book
</code></pre>
<blockquote>
<p>感觉类似于python中的创建一个空的类 用于储存数据一样</p>
</blockquote>
<p>对结构变量可以在定义时初始化。方法是：
在花括号中顺序填入结构中的（数据）成员的初始值：</p>
<pre><code class="language-C++">Books book1 = {&quot;bookname&quot;,&quot;me&quot;,&quot;science&quot;,&quot;1000101&quot;}
</code></pre>
<p>此外值得注意：</p>
<pre><code class="language-C++">//该结构可以嵌套
struct mail
{
       char address[30] ; //地址
       long int zip ; //邮政编码
       long int telenum ; //电话号码
};
 
struct employee
{
       char name[25] ; //员工姓名
       mail addinfo ; //结构变量作为成员，嵌套
       double salary ; //工资
};
//访问结构变量的结构成员的方法：用连续点号来访问结构变量的结构成员。例如有程序段：
employee emp1={“朱明”,“四牌楼2号”,210096,83792666,2430.0};//因为存在结构嵌套，因此多了好几个初始化需要添加的参数
cout&lt;&lt;emp1.addinfo.telenum&lt;&lt;endl;
</code></pre>
<h4 id="a-name1082访问结构成员aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name1082访问结构成员aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="108">2、访问结构成员</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>为了访问结构的成员，我们使用<strong>成员访问运算符（.）</strong>。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 <strong>struct</strong> 关键字来定义结构类型的变量。下面的实例演示了结构的用法：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
 
using namespace std;
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
int main( )
{
   struct Books Book1;        // 声明 Book1，类型为 Book
   struct Books Book2;        // 声明 Book2，类型为 Book
 
   // Book1 详述
   strcpy( Book1.title, &quot;Learn C++ Programming&quot;);
   strcpy( Book1.author, &quot;Chand Miyan&quot;); 
   strcpy( Book1.subject, &quot;C++ Programming&quot;);
   Book1.book_id = 6495407;

   // Book2 详述
   strcpy( Book2.title, &quot;Telecom Billing&quot;);
   strcpy( Book2.author, &quot;Yakit Singha&quot;);
   strcpy( Book2.subject, &quot;Telecom&quot;);
   Book2.book_id = 6495700;
 
   // 输出 Book1 信息
   cout &lt;&lt; &quot;Book 1 title : &quot; &lt;&lt; Book1.title &lt;&lt;endl;
   cout &lt;&lt; &quot;Book 1 author : &quot; &lt;&lt; Book1.author &lt;&lt;endl;
   cout &lt;&lt; &quot;Book 1 subject : &quot; &lt;&lt; Book1.subject &lt;&lt;endl;
   cout &lt;&lt; &quot;Book 1 id : &quot; &lt;&lt; Book1.book_id &lt;&lt;endl;

   // 输出 Book2 信息
   cout &lt;&lt; &quot;Book 2 title : &quot; &lt;&lt; Book2.title &lt;&lt;endl;
   cout &lt;&lt; &quot;Book 2 author : &quot; &lt;&lt; Book2.author &lt;&lt;endl;
   cout &lt;&lt; &quot;Book 2 subject : &quot; &lt;&lt; Book2.subject &lt;&lt;endl;
   cout &lt;&lt; &quot;Book 2 id : &quot; &lt;&lt; Book2.book_id &lt;&lt;endl;

   return 0;
}
</code></pre>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code>Book 1 title : Learn C++ Programming
Book 1 author : Chand Miyan
Book 1 subject : C++ Programming
Book 1 id : 6495407
Book 2 title : Telecom Billing
Book 2 author : Yakit Singha
Book 2 subject : Telecom
Book 2 id : 6495700
</code></pre>
<h4 id="a-name1093结构作为函数参数aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name1093结构作为函数参数aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="109">3、结构作为函数参数</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
 
using namespace std;
void printBook( struct Books book );

struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
int main( )
{
   struct Books Book1;        // 声明 Book1，类型为 Book
   struct Books Book2;        // 声明 Book2，类型为 Book
 
   // Book1 详述
   strcpy( Book1.title, &quot;Learn C++ Programming&quot;);
   strcpy( Book1.author, &quot;Chand Miyan&quot;); 
   strcpy( Book1.subject, &quot;C++ Programming&quot;);
   Book1.book_id = 6495407;

   // Book2 详述
   strcpy( Book2.title, &quot;Telecom Billing&quot;);
   strcpy( Book2.author, &quot;Yakit Singha&quot;);
   strcpy( Book2.subject, &quot;Telecom&quot;);
   Book2.book_id = 6495700;
 
   // 输出 Book1 信息
   printBook( Book1 );

   // 输出 Book2 信息
   printBook( Book2 );

   return 0;
}
void printBook( struct Books book )
{
   cout &lt;&lt; &quot;Book title : &quot; &lt;&lt; book.title &lt;&lt;endl;
   cout &lt;&lt; &quot;Book author : &quot; &lt;&lt; book.author &lt;&lt;endl;
   cout &lt;&lt; &quot;Book subject : &quot; &lt;&lt; book.subject &lt;&lt;endl;
   cout &lt;&lt; &quot;Book id : &quot; &lt;&lt; book.book_id &lt;&lt;endl;
}
</code></pre>
<h4 id="a-name1104指向结构的指针aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name1104指向结构的指针aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="110">4、指向结构的指针</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</p>
<pre><code class="language-C++">struct Books *struct_pointer;
</code></pre>
<p>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</p>
<pre><code class="language-c++">struct_pointer = &amp;Book1;
</code></pre>
<p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：</p>
<pre><code class="language-c++">struct_pointer -&gt; title;
</code></pre>
<p>一个具体的例子🌰：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
 
using namespace std;
void printBook( struct Books *book );

struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
int main( )
{
   struct Books Book1;        // 声明 Book1，类型为 Book
   struct Books Book2;        // 声明 Book2，类型为 Book */
 
   // Book1 详述
   strcpy( Book1.title, &quot;Learn C++ Programming&quot;);
   strcpy( Book1.author, &quot;Chand Miyan&quot;); 
   strcpy( Book1.subject, &quot;C++ Programming&quot;);
   Book1.book_id = 6495407;

   // Book2 详述
   strcpy( Book2.title, &quot;Telecom Billing&quot;);
   strcpy( Book2.author, &quot;Yakit Singha&quot;);
   strcpy( Book2.subject, &quot;Telecom&quot;);
   Book2.book_id = 6495700;
 
   // 通过传 Book1 的地址来输出 Book1 信息
   printBook( &amp;Book1 ); //就相当于在函数定义时在此处声明了一个指针，然后在函数调用的时候直接将地址值赋给这个指针。

   // 通过传 Book2 的地址来输出 Book2 信息
   printBook( &amp;Book2 );

   return 0;
}
// 该函数以结构指针作为参数
void printBook( struct Books *book )
{
   cout &lt;&lt; &quot;Book title : &quot; &lt;&lt; book-&gt;title &lt;&lt;endl;
   cout &lt;&lt; &quot;Book author : &quot; &lt;&lt; book-&gt;author &lt;&lt;endl;
   cout &lt;&lt; &quot;Book subject : &quot; &lt;&lt; book-&gt;subject &lt;&lt;endl;
   cout &lt;&lt; &quot;Book id : &quot; &lt;&lt; book-&gt;book_id &lt;&lt;endl;
} 
</code></pre>
<h4 id="a-name1115typedef关键字aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a class="header" href="#a-name1115typedef关键字aa-stylefloatrighttext-decorationnone-hrefc学习c基础带目录htmlindextopa"><a name="111">5、typedef关键字</a><a style="float:right;text-decoration:none;" href="C++学习/C++基础带目录.html#index">[Top]</a></a></h4>
<p>下面是一种更简单的定义结构的方式，您可以为创建的类型取一个&quot;别名&quot;。例如：</p>
<pre><code class="language-c++">typedef struct
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
}Books;
</code></pre>
<p>现在，您可以直接使用 <em>Books</em> 来定义 <em>Books</em> 类型的变量，而不需要使用 struct 关键字。下面是实例：</p>
<pre><code class="language-c++">Books Book1, Book2;
</code></pre>
<p>您可以使用 <strong>typedef</strong> 关键字来定义非结构类型，如下所示：</p>
<pre><code class="language-c++">typedef long int *pint32;
 
pint32 x, y, z;
</code></pre>
<p>x, y 和 z 都是指向长整型 long int 的指针。</p>
<div style="break-before: page; page-break-before: always;"></div><p><a name="index"><strong>Index</strong></a>
<a href="C++学习/C++进阶带目录.html#0">C++ 类 &amp; 对象</a><br />
  <a href="C++学习/C++进阶带目录.html#1">一、C++类的定义</a><br />
  <a href="C++学习/C++进阶带目录.html#2">二、C++定义对象（类似于python中的类的实例化）</a><br />
   <a href="C++学习/C++进阶带目录.html#3">访问数据成员</a><br />
  <a href="C++学习/C++进阶带目录.html#4">三、类 &amp; 对象详解</a><br />
   <a href="C++学习/C++进阶带目录.html#5">1、类的成员函数</a><br />
   <a href="C++学习/C++进阶带目录.html#6">2、类访问修饰符</a><br />
   <a href="C++学习/C++进阶带目录.html#7"># 3、构造函数与析构函数</a><br />
   <a href="C++学习/C++进阶带目录.html#8"># 3、C++拷贝构造函数</a><br />
   <a href="C++学习/C++进阶带目录.html#9"># 4、C++友元函数(相当于给开后门，给某些函数特定权利可以访问私有资源)</a><br />
   <a href="C++学习/C++进阶带目录.html#10"># 5、内联函数</a><br />
   <a href="C++学习/C++进阶带目录.html#11"># 6、C++ this指针</a><br />
   <a href="C++学习/C++进阶带目录.html#12"># 7、指向类的指针</a><br />
   <a href="C++学习/C++进阶带目录.html#13"># 8、C++类的静态成员</a><br />
   <a href="C++学习/C++进阶带目录.html#14"># 9、静态函数成员</a><br />
  <a href="C++学习/C++进阶带目录.html#15">四、C++继承</a><br />
   <a href="C++学习/C++进阶带目录.html#16">1、基类&amp;派生类</a><br />
   <a href="C++学习/C++进阶带目录.html#17">2、访问控制和继承</a><br />
   <a href="C++学习/C++进阶带目录.html#18">3、多继承</a><br />
  <a href="C++学习/C++进阶带目录.html#19">五、C++重载运算符和重载函数</a><br />
   <a href="C++学习/C++进阶带目录.html#20">1、函数的重载</a><br />
   <a href="C++学习/C++进阶带目录.html#21">2、运算符重载</a><br />
  <a href="C++学习/C++进阶带目录.html#22">六、重载运算符实例</a><br />
   <a href="C++学习/C++进阶带目录.html#23"><strong>1、一元运算符重载</strong>（也就是只有一个数字参与运算的情况）</a><br />
   <a href="C++学习/C++进阶带目录.html#24">2、二元运算符重载</a><br />
   <a href="C++学习/C++进阶带目录.html#25">3、关系运算符重载</a><br />
   <a href="C++学习/C++进阶带目录.html#26">4、输入/输出运算符重载</a><br />
   <a href="C++学习/C++进阶带目录.html#27">4、赋值运算符重载</a><br />
   <a href="C++学习/C++进阶带目录.html#28">5、函数调用运算符 () 重载</a><br />
  <a href="C++学习/C++进阶带目录.html#29">七、C++类的多态</a></p>
<h1 id="a-name0c-类--对象aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name0c-类--对象aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="0">C++ 类 &amp; 对象</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h1>
<p>C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。</p>
<p>类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类被称为类的成员。</p>
<h3 id="a-name1一c类的定义aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name1一c类的定义aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="1">一、C++类的定义</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h3>
<p>类定义是以关键字 <strong>class</strong> 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 <strong>class</strong> 定义 Box 数据类型，如下所示：</p>
<pre><code class="language-C++">class Box
{
   public:
      double length;   // Length of a box
      double breadth;  // Breadth of a box
      double height;   // Height of a box
};
</code></pre>
<p>关键字 <strong>public</strong> 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 <strong>private</strong> 或 <strong>protected</strong>，这个后面会展开介绍。</p>
<h3 id="a-name2二c定义对象类似于python中的类的实例化aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name2二c定义对象类似于python中的类的实例化aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="2">二、C++定义对象（类似于python中的类的实例化）</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h3>
<p>类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：</p>
<pre><code class="language-C++">Box Box1;          // 声明 Box1，类型为 Box
Box Box2;          // 声明 Box2，类型为 Box
</code></pre>
<p>Box1和Box2都有属于他们各自的数据成员</p>
<h4 id="a-name3访问数据成员aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name3访问数据成员aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="3">访问数据成员</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>类的对象的公共数据成员可以使用<strong>直接成员访问运算符 (.)</strong> 来访问。为了更好地理解这些概念，让我们尝试一下下面的实例：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;

class Box
{
   public:
      double length;   // 长度
      double breadth;  // 宽度
      double height;   // 高度
};

int main( )
{
   Box Box1;        // 声明 Box1，类型为 Box
   Box Box2;        // 声明 Box2，类型为 Box
   double volume = 0.0;     // 用于存储体积
 
   // box 1 详述
   Box1.height = 5.0; 
   Box1.length = 6.0; 
   Box1.breadth = 7.0;

   // box 2 详述
   Box2.height = 10.0;
   Box2.length = 12.0;
   Box2.breadth = 13.0;

   // box 1 的体积
   volume = Box1.height * Box1.length * Box1.breadth;
   cout &lt;&lt; &quot;Box1 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;

   // box 2 的体积
   volume = Box2.height * Box2.length * Box2.breadth;
   cout &lt;&lt; &quot;Box2 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;
   return 0;
}
</code></pre>
<p><strong>需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。</strong></p>
<h3 id="a-name4三类--对象详解aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name4三类--对象详解aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="4">三、类 &amp; 对象详解</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h3>
<p>到目前为止，我们已经对 C++ 的类和对象有了基本的了解。下面的列表中还列出了其他一些 C++ 类和对象相关的概念，可以点击相应的链接进行学习。</p>
<table><thead><tr><th align="left">概念</th><th align="left">描述</th></tr></thead><tbody>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-class-member-functions.html">类成员函数</a></td><td align="left">类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-class-access-modifiers.html">类访问修饰符</a></td><td align="left">类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-constructor-destructor.html">构造函数 &amp; 析构函数</a></td><td align="left">类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-copy-constructor.html">C++ 拷贝构造函数</a></td><td align="left">拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-friend-functions.html">C++ 友元函数</a></td><td align="left"><strong>友元函数</strong>可以访问类的 private 和 protected 成员。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-inline-functions.html">C++ 内联函数</a></td><td align="left">通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-this-pointer.html">C++ 中的 this 指针</a></td><td align="left">每个对象都有一个特殊的指针 <strong>this</strong>，它指向对象本身。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-pointer-to-class.html">C++ 中指向类的指针</a></td><td align="left">指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。</td></tr>
<tr><td align="left"><a href="https://www.w3cschool.cn/cpp/cpp-static-members.html">C++ 类的静态成员</a></td><td align="left">类的数据成员和函数成员都可以被声明为静态的。</td></tr>
</tbody></table>
<h4 id="a-name51类的成员函数aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name51类的成员函数aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="5">1、类的成员函数</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>​	类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。</p>
<p><strong>类的成员函数有两种定义方式：</strong></p>
<ul>
<li>
<p>直接在定义类的时候在类的内部定义</p>
<pre><code class="language-C++">class Box
{
   public:
      double length;      // 长度
      double breadth;     // 宽度
      double height;      // 高度
   
      double getVolume(void)
      {
         return length * breadth * height;
      }
};
</code></pre>
</li>
<li>
<p>此外，成员函数也可以在类的外部定义，此时需要在定义类的时候在类的内部首先对函数进行声明，然后再用**::**（<strong>范围解析运算符</strong>）来定义，</p>
<pre><code class="language-C++">class Box
{
   public:
      double length;         // 长度
      double breadth;        // 宽度
      double height;         // 高度
      double getVolume(void);// 返回体积
};
double Box::getVolume(void)
{
	return length *breadth*height;
}
</code></pre>
</li>
</ul>
<blockquote>
<p>这里需要强调的是，范围解析运算符（::）需要跟在类名的后面</p>
<p>而点运算符（.）则需要跟在对象名称后面</p>
</blockquote>
<pre><code class="language-C++">Box myBox;          // 创建一个对象

myBox.getVolume();  // 调用该对象的成员函数
</code></pre>
<p>一个例子🌰：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;

class Box
{
   public:
      double length;         // 长度
      double breadth;        // 宽度
      double height;         // 高度

      // 成员函数声明
      double getVolume(void);
      void setLength( double len );
      void setBreadth( double bre );
      void setHeight( double hei );
};

// 成员函数定义
double Box::getVolume(void)
{
    return length * breadth * height;
}

void Box::setLength( double len )
{
    length = len;
}

void Box::setBreadth( double bre )
{
    breadth = bre;
}

void Box::setHeight( double hei )
{
    height = hei;
}

// 程序的主函数
int main( )
{
   Box Box1;                // 声明 Box1，类型为 Box
   Box Box2;                // 声明 Box2，类型为 Box
   double volume = 0.0;     // 用于存储体积
 
   // box 1 详述
   Box1.setLength(6.0); 
   Box1.setBreadth(7.0); 
   Box1.setHeight(5.0);

   // box 2 详述
   Box2.setLength(12.0); 
   Box2.setBreadth(13.0); 
   Box2.setHeight(10.0);

   // box 1 的体积
   volume = Box1.getVolume();
   cout &lt;&lt; &quot;Box1 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;

   // box 2 的体积
   volume = Box2.getVolume();
   cout &lt;&lt; &quot;Box2 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;
   return 0;
}
</code></pre>
<h4 id="a-name62类访问修饰符aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name62类访问修饰符aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="6">2、类访问修饰符</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>​	数据隐藏是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 <strong>public、private、protected</strong> 来指定的。关键字 public、private、protected 称为访问说明符。</p>
<p>一个类可以有多个 public、protected 或 private 标记区域。<strong>每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的</strong>。<strong>成员和类的默认访问修饰符是 private。</strong></p>
<pre><code class="language-C++">class Base{
	public:
	//public members go here
	
	protected:
	//protected members go here
	
	private:
	//private members go here
};
</code></pre>
<ul>
<li>
<p>公有（public）成员</p>
<p><strong>公有成员</strong>是在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值，如下所示：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
 
using namespace std;
 
class Line
{
   public:
      double length;
      void setLength( double len );
      double getLength( void );
};
 
// 成员函数定义
double Line::getLength(void)
{
    return length ;
}
 
void Line::setLength( double len )
{
    length = len;
}
 
// 程序的主函数
int main( )
{
   Line line;
 
   // 设置长度
   line.setLength(6.0); 
   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;
 
   // 不使用成员函数设置长度⭐️
   line.length = 10.0; // OK: 因为 length 是公有的
   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.length &lt;&lt;endl;
   return 0;
}
//运行结果
Length of line : 6
Length of line : 10
</code></pre>
</li>
<li>
<p>私有（private)成员</p>
<p><strong>私有</strong>成员变量或函数在类的外部是不可访问的，甚至是不可查看的。<strong>只有类和友元函数可以访问私有成员。</strong></p>
<p>默认情况下，类的所有成员都是私有的。例如在下面的类中，<strong>width</strong> 是一个私有成员，这意味着，如果您没有使用任何访问修饰符，类的成员将被假定为私有成员：</p>
<p>一个例子🌰：	</p>
<pre><code class="language-C++">class Box
{
 double width;
 public:
    double length;
    void setWidth( double wid );
    double getWidth( void );
};
</code></pre>
<p>实际操作中，我们一般会在私有区域定义数据，然后在公有区域定义相关函数，以便类可以在外部调用这些函数用来获取以及修改类的私有变量及函数。</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
 
using namespace std;
 
class Box
{
   public:
      double length;
      void setWidth( double wid );
      double getWidth( void );
 
   private:
      double width;
};
 
// 成员函数定义
double Box::getWidth(void)
{
    return width ;
}
 
void Box::setWidth( double wid )
{
    width = wid;
}
 
// 程序的主函数
int main( )
{
   Box box;
 
   // 不使用成员函数设置长度
   box.length = 10.0; // OK: 因为 length 是公有的
   cout &lt;&lt; &quot;Length of box : &quot; &lt;&lt; box.length &lt;&lt;endl;
 
   // 不使用成员函数设置宽度
   // box.width = 10.0; // Error: 因为 width 是私有的
   box.setWidth(10.0);  // 使用成员函数设置宽度
   cout &lt;&lt; &quot;Width of box : &quot; &lt;&lt; box.getWidth() &lt;&lt;endl;
 
   return 0;
}
</code></pre>
</li>
<li>
<p>保护（protected）成员</p>
<p>保护成员变量与私有成员很相似，但有一点不同的是，保护成员的参数可以通过类的派生类（子类）访问，而私有成员的则不可以。</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
using namespace std;
 
class Box
{
   protected:
      double width;
};
 
class SmallBox:Box // SmallBox 是派生类
{
   public:
      void setSmallWidth( double wid );
      double getSmallWidth( void );
};
 
// 子类的成员函数
double SmallBox::getSmallWidth(void)
{
    return width ;
}
 
void SmallBox::setSmallWidth( double wid )
{
    width = wid;
}
 
// 程序的主函数
int main( )
{
   SmallBox box;
 
   // 使用成员函数设置宽度
   box.setSmallWidth(5.0);
   cout &lt;&lt; &quot;Width of box : &quot;&lt;&lt; box.getSmallWidth() &lt;&lt; endl;
 
   return 0;
}
</code></pre>
<h4 id="a-name73构造函数与析构函数aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name73构造函数与析构函数aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="7">3、构造函数与析构函数</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p><strong>类的构造函数：<strong>类的</strong>构造函数</strong>是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。✅（在这里可以类比与python中的init函数</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
 
using namespace std;
 
class Line
{
   public:
      void setLength( double len );
      double getLength( void );
      Line();  // 这是构造函数
 
   private:
      double length;
};
 
// 成员函数定义，包括构造函数
Line::Line(void)
{
    cout &lt;&lt; &quot;Object is being created&quot; &lt;&lt; endl;
}
 
void Line::setLength( double len )
{
    length = len;
}
 
double Line::getLength( void )
{
    return length;
}
// 程序的主函数
int main( )
{
   Line line;
 
   // 设置长度
   line.setLength(6.0); 
   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;
 
   return 0;
}
//输出结果
Object is being created
Length of line : 6
</code></pre>
<p>**带有参数的构造参数：**默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值，如下面的例子所示:（✅：就可以当成带有参数的init函数，在初始化的时候需要带参数使用）</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
 
using namespace std;
 
class Line
{
   public:
      void setLength( double len );
      double getLength( void );
      Line(double len);  // 这是构造函数
 
   private:
      double length;
};
 
// 成员函数定义，包括构造函数
Line::Line( double len)
{
    cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl;
    length = len;
}
 
void Line::setLength( double len )
{
    length = len;
}
 
double Line::getLength( void )
{
    return length;
}
// 程序的主函数
int main( )
{
   Line line(10.0);
 
   // 获取默认设置的长度
   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;
   // 再次设置长度
   line.setLength(6.0); 
   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;
 
   return 0;
}

</code></pre>
<p><strong>使用初始化列表来初始化字段</strong></p>
<p>假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示：</p>
<pre><code class="language-C++">C::C( double a, double b, double c): X(a), Y(b), Z(c)
{
  ....
}
</code></pre>
<p>使用初始化列表来初始化字段：</p>
<pre><code class="language-C++">Line::Line( double len): length(len)
{
    cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl;
}
</code></pre>
<p>上面的语法等同于如下语法：</p>
<pre><code class="language-C++">Line::Line( double len)
{
    cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl;
    length = len;
}
</code></pre>
<p><strong>类的析构函数</strong>（作用于类的构造函数刚好相反）：类的<strong>析构函数</strong>是类的一种特殊的成员函数，它会在<strong>每次删除所创建的对象时执</strong>行。析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。<strong>析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</strong></p>
<pre><code class="language-C++">#include &lt;iostream&gt;
 
using namespace std;
 
class Line
{
   public:
      void setLength( double len );
      double getLength( void );
      Line();   // 这是构造函数声明
      ~Line();  // 这是析构函数声明
 
   private:
      double length;
};
 
// 成员函数定义，包括构造函数
Line::Line(void)
{
    cout &lt;&lt; &quot;Object is being created&quot; &lt;&lt; endl;
}
Line::~Line(void)
{
    cout &lt;&lt; &quot;Object is being deleted&quot; &lt;&lt; endl;
}
 
void Line::setLength( double len )
{
    length = len;
}
 
double Line::getLength( void )
{
    return length;
}
// 程序的主函数
int main( )
{
   Line line;
 
   // 设置长度
   line.setLength(6.0); 
   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;
 
   return 0;
}
//输出结果
Object is being created
Length of line : 6
Object is being deleted

</code></pre>
<h4 id="a-name83c拷贝构造函数aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name83c拷贝构造函数aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="8">3、C++拷贝构造函数</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>问题？(O_O)?  什么是拷贝构造函数？？？？</p>
<p>首先对于普通类型的对象来说，它们之间的复制是很简单的，例如：</p>
<pre><code class="language-cpp">int a = 100;
int b = a; 
</code></pre>
<p>类的乱七八糟看不懂，跳过回头填坑</p>
<h4 id="a-name94c友元函数相当于给开后门给某些函数特定权利可以访问私有资源aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name94c友元函数相当于给开后门给某些函数特定权利可以访问私有资源aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="9">4、C++友元函数(相当于给开后门，给某些函数特定权利可以访问私有资源)</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>**类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。**尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</p>
<p>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。</p>
<p>==如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 <strong>friend</strong>，如下所示：==</p>
<pre><code class="language-cpp">class Box
{
   double width;
public:
   double length;
   friend void printWidth( Box box );
   void setWidth( double wid );
};
//同样的，声明类ClassTwo的所有成员函数作为类ClassOne的友元，需要在类ClassOne的定义中放置如下声明：
friend class ClassTwo;
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
 
using namespace std;
 
class Box
{
   double width;
public:
   friend void printWidth( Box box );
   void setWidth( double wid );
};

// 成员函数定义
void Box::setWidth( double wid )
{
    width = wid;
}

// 请注意：printWidth() 不是任何类的成员函数
void printWidth( Box box )
{
   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */
   cout &lt;&lt; &quot;Width of box : &quot; &lt;&lt; box.width &lt;&lt;endl;
}
 
// 程序的主函数
int main( )
{
   Box box;
 
   // 使用成员函数设置宽度
   box.setWidth(10.0);
   
   // 使用友元函数输出宽度
   printWidth( box );
 
   return 0;
}

</code></pre>
<h4 id="a-name105内联函数aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name105内联函数aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="10">5、内联函数</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>一般的函数有一个潜在的缺点：调用函数比求解等价表达式要慢得多。在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行。</p>
<p>在C++中可以使用**内联函数，<strong>其目的是为了提高函数的执行效率</strong>，**通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。</p>
<p>对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。</p>
<p>如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 <strong>inline</strong>，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。</p>
<p>在类定义中的定义的函数都是内联函数，即使没有使用 <strong>inline</strong> 说明符。</p>
<p>下面是使用内联函数来返回两个数中的最大值：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

inline int Max(int x, int y)
{
   return (x &gt; y)? x : y;
}

// 程序的主函数
int main( )
{

   cout &lt;&lt; &quot;Max (20,10): &quot; &lt;&lt; Max(20,10) &lt;&lt; endl;
   cout &lt;&lt; &quot;Max (0,200): &quot; &lt;&lt; Max(0,200) &lt;&lt; endl;
   cout &lt;&lt; &quot;Max (100,1010): &quot; &lt;&lt; Max(100,1010) &lt;&lt; endl;
   return 0;
}
//输出结果
Max (20,10): 20
Max (0,200): 200
Max (100,1010): 1010
</code></pre>
<p>有了内联函数，就能像调用一个函数那样方便地重复使用一段代码，而不需要付出执行函数调用的额外开销。很显然，使用内联函数会是最终可执行程序的体积增加。以空间换取时间，或消耗时间来增加空间，这是计算机学科中常用的方法。</p>
<p>内联函数中的代码应该只是很简单、执行很快的几条语句。如果一个函数较为复杂，它执行的时间可能上万倍于函数调用的额外开销，那么将其作为内联函数处理的结果是付出让代码体积增加不少的代价，却只使速度提高了万分之一，这显然是不划算的，而且有些函数即使声明为内联的也不一定会被编译器内联。</p>
<p>有时函数看上去很简单，例如只有一个包含一两条语句的循环，但该循环的执行次数可能很多，要消耗大量时间，那么这种情况也不适合将其实现为内联函数。</p>
<p>另外需要注意的是，调用内联函数的语句前必须已经出现内联函数的定义（即整个函数体），而不能只出现内联函数的声明。</p>
<p>✅：<strong>也就是说内敛函数相当于是对传统函数的改造，在定义时需要在其开头位置添加inline符号，该类函数在执行过程中相当于不需要像传统函数使用时老需要寄存调用，直接将代码复制到各个需要调用的地方</strong></p>
<h4 id="a-name116c-this指针aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name116c-this指针aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="11">6、C++ this指针</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>在 C++ 中，每一个对象都能通过 <strong>this</strong> 指针来访问自己的地址。<strong>this</strong> 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p>
<p>友元函数没有 <strong>this</strong> 指针，因为友元不是类的成员。只有成员函数才有 <strong>this</strong> 指针。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
 
using namespace std;

class Box
{
   public:
      // 构造函数定义
      Box(double l=2.0, double b=2.0, double h=2.0)
      {
         cout &lt;&lt;&quot;Constructor called.&quot; &lt;&lt; endl;
         length = l;
         breadth = b;
         height = h;
      }
      double Volume()
      {
         return length * breadth * height;
      }
      int compare(Box box)
      {
         return this-&gt;Volume() &gt; box.Volume();//这个地方的this就是指向的Box这个类的本身
      }
   private:
      double length;     // Length of a box
      double breadth;    // Breadth of a box
      double height;     // Height of a box
};

int main(void)
{
   Box Box1(3.3, 1.2, 1.5);    // Declare box1
   Box Box2(8.5, 6.0, 2.0);    // Declare box2

   if(Box1.compare(Box2))
   {
      cout &lt;&lt; &quot;Box2 is smaller than Box1&quot; &lt;&lt;endl;
   }
   else
   {
      cout &lt;&lt; &quot;Box2 is equal to or larger than Box1&quot; &lt;&lt;endl;
   }
   return 0;
}
//输出结果
Constructor called.
Constructor called.
Box2 is equal to or larger than Box1
</code></pre>
<h4 id="a-name127指向类的指针aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name127指向类的指针aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="12">7、指向类的指针</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 <strong>-&gt;</strong>，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。</p>
<pre><code class="language-CPP">#include &lt;iostream&gt;
 
using namespace std;

class Box
{
   public:
      // 构造函数定义
      Box(double l=2.0, double b=2.0, double h=2.0)
      {
         cout &lt;&lt;&quot;Constructor called.&quot; &lt;&lt; endl;
         length = l;
         breadth = b;
         height = h;
      }
      double Volume()
      {
         return length * breadth * height;
      }
   private:
      double length;     // Length of a box
      double breadth;    // Breadth of a box
      double height;     // Height of a box
};

int main(void)
{
   Box Box1(3.3, 1.2, 1.5);    // Declare box1
   Box Box2(8.5, 6.0, 2.0);    // Declare box2
   Box *ptrBox;                // Declare pointer to a class.

   // 保存第一个对象的地址
   ptrBox = &amp;Box1;

   // 现在尝试使用成员访问运算符来访问成员
   cout &lt;&lt; &quot;Volume of Box1: &quot; &lt;&lt; ptrBox-&gt;Volume() &lt;&lt; endl;

   // 保存第二个对象的地址
   ptrBox = &amp;Box2;

   // 现在尝试使用成员访问运算符来访问成员
   cout &lt;&lt; &quot;Volume of Box2: &quot; &lt;&lt; ptrBox-&gt;Volume() &lt;&lt; endl;
  
   return 0;
}
//输出结果
Constructor called.
Constructor called.
Volume of Box1: 5.94
Volume of Box2: 102
</code></pre>
<h4 id="a-name138c类的静态成员aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name138c类的静态成员aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="13">8、C++类的静态成员</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>我们可以使用 <strong>static</strong> 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。</p>
<p><strong>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零</strong>。我们不能把静态成员放置在类的定义中，但是可以在类的外部通过使用==范围解析运算符 <strong>::</strong> 来重新声明静态变量==从而对它进行初始化，如下面的实例所示。</p>
<p>下面的实例有助于更好地理解静态数据成员的概念：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
 
using namespace std;

class Box
{
   public:
      static int objectCount;
      // 构造函数定义
      Box(double l=2.0, double b=2.0, double h=2.0)
      {
         cout &lt;&lt;&quot;Constructor called.&quot; &lt;&lt; endl;
         length = l;
         breadth = b;
         height = h;
         // 每次创建对象时增加 1
         objectCount++;
      }
      double Volume()
      {
         return length * breadth * height;
      }
   private:
      double length;     // 长度
      double breadth;    // 宽度
      double height;     // 高度
};

// 初始化类 Box 的静态成员
int Box::objectCount = 0;
‼️‼️ //在访问这种静态参数时，这里的访问符号不再是. 而是变成了::
int main(void)
{
   Box Box1(3.3, 1.2, 1.5);    // 声明 box1
   Box Box2(8.5, 6.0, 2.0);    // 声明 box2

   // 输出对象的总数
   cout &lt;&lt; &quot;Total objects: &quot; &lt;&lt; Box::objectCount &lt;&lt; endl;

   return 0;
}
//输出结果
Constructor called.
Constructor called.
Total objects: 2
//这里static的意思就是不管怎么搞，怎么实例化，大家各个实例之间都是用同一个参数，也就是说他不属于任何一个特定的个体实例化，而是级别更高直属于类本身的，所以访问符号也从.变为了::
</code></pre>
<h4 id="a-name149静态函数成员aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name149静态函数成员aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="14">9、静态函数成员</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，<strong>静态函数</strong>只要使用类名加范围解析运算符 <strong>::</strong> 就可以访问。</p>
<p>静态成员函数只能访问静态数据成员，不能访问其他静态成员函数和类外部的其他函数。</p>
<p>静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
 
using namespace std;

class Box
{
   public:
      static int objectCount;
      // 构造函数定义
      Box(double l=2.0, double b=2.0, double h=2.0)
      {
         cout &lt;&lt;&quot;Constructor called.&quot; &lt;&lt; endl;
         length = l;
         breadth = b;
         height = h;
         // 每次创建对象时增加 1
         objectCount++;
      }
      double Volume()
      {
         return length * breadth * height;
      }
      static int getCount()
      {
         return objectCount;
      }
   private:
      double length;     // 长度
      double breadth;    // 宽度
      double height;     // 高度
};

// 初始化类 Box 的静态成员
int Box::objectCount = 0;

int main(void)
{
  
  
  ‼️‼️ //注意，这种静态参数（变量及函数）的调用需要使用::而不是跟以往一样使用的是单点号，这里需要注意
    
    
   // 在创建对象之前输出对象的总数
   cout &lt;&lt; &quot;Inital Stage Count: &quot; &lt;&lt; Box::getCount() &lt;&lt; endl;

   Box Box1(3.3, 1.2, 1.5);    // 声明 box1
   Box Box2(8.5, 6.0, 2.0);    // 声明 box2

   // 在创建对象之后输出对象的总数
   cout &lt;&lt; &quot;Final Stage Count: &quot; &lt;&lt; Box::getCount() &lt;&lt; endl;

   return 0;
}
//输出结果
Inital Stage Count: 0
Constructor called.
Constructor called.
Final Stage Count: 2
</code></pre>
</li>
</ul>
<h3 id="a-name15四c继承aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name15四c继承aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="15">四、C++继承</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h3>
<p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果</p>
<p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p>
<h4 id="a-name161基类派生类aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name161基类派生类aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="16">1、基类&amp;派生类</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p>
<pre><code class="language-C++">class derived-class: access-specifier base-class
</code></pre>
<p>其中，访问修饰符 access-specifier 是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p>
<p>假设有一个基类 <strong>Shape</strong>，<strong>Rectangle</strong> 是它的派生类，如下所示：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
 
using namespace std;

// 基类
class Shape 
{
   public:
      void setWidth(int w)
      {
         width = w;
      }
      void setHeight(int h)
      {
         height = h;
      }
   protected:
      int width;
      int height;
};

// 派生类
class Rectangle: public Shape
{
   public:
      int getArea()
      { 
         return (width * height); 
      }
};

int main(void)
{
   Rectangle Rect;
 
   Rect.setWidth(5);
   Rect.setHeight(7);

   // 输出对象的面积
   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;

   return 0;
} 
//输出结果
Total area: 35
</code></pre>
<h4 id="a-name172访问控制和继承aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name172访问控制和继承aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="17">2、访问控制和继承</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p>
<p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p>
<table><thead><tr><th align="left">访问</th><th align="left">public</th><th align="left">protected</th><th align="left">private</th></tr></thead><tbody>
<tr><td align="left">同一个类</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr>
<tr><td align="left">派生类</td><td align="left">yes</td><td align="left">yes</td><td align="left">no</td></tr>
<tr><td align="left">外部的类</td><td align="left">yes</td><td align="left">no</td><td align="left">no</td></tr>
</tbody></table>
<p>当一个类派生自基类，该基类可以被继承为 <strong>public、protected</strong> 或 <strong>private</strong> 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>
<p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p>
<ul>
<li><strong>公有继承（public）：<strong>当一个类派生自</strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li>
<li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li>
<li><strong>私有继承（private）：<strong>当一个类派生自</strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li>
</ul>
<blockquote>
<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>
</blockquote>
<blockquote>
<ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
</ul>
</blockquote>
<h4 id="a-name183多继承aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name183多继承aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="18">3、多继承</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p>
<p>C++ 类可以从多个类继承成员，语法如下：</p>
<pre><code>class &lt;派生类名&gt;: &lt;继承方式1&gt; &lt;基类名1&gt;, &lt;继承方式2&gt; &lt;基类名2&gt;
{
……
}；
</code></pre>
<p>其中，访问修饰符 access 是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：</p>
<pre><code class="language-C++">#include &lt;iostream&gt;
 
using namespace std;

// 基类 Shape
class Shape 
{
   public:
      void setWidth(int w)
      {
         width = w;
      }
      void setHeight(int h)
      {
         height = h;
      }
   protected:
      int width;
      int height;
};

// 基类 PaintCost
class PaintCost 
{
   public:
      int getCost(int area)
      {
         return area * 70;
      }
};

// 派生类
class Rectangle: public Shape, public PaintCost
{
   public:
      int getArea()
      { 
         return (width * height); 
      }
};

int main(void)
{
   Rectangle Rect;
   int area;
 
   Rect.setWidth(5);
   Rect.setHeight(7);

   area = Rect.getArea();
   
   // 输出对象的面积
   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;

   // 输出总花费
   cout &lt;&lt; &quot;Total paint cost: $&quot; &lt;&lt; Rect.getCost(area) &lt;&lt; endl;

   return 0;
}
</code></pre>
<h3 id="a-name19五c重载运算符和重载函数aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name19五c重载运算符和重载函数aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="19">五、C++重载运算符和重载函数</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h3>
<p>==C++ 允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义==，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p>
<p>==重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。==</p>
<p>当您调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为<strong>重载决策</strong>。</p>
<h4 id="a-name201函数的重载aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name201函数的重载aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="20">1、函数的重载</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。</p>
<p>下面的实例中，同名函数 <strong>print()</strong> 被用于输出不同的数据类型：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 
class printData 
{
   public:
      void print(int i) {
        cout &lt;&lt; &quot;Printing int: &quot; &lt;&lt; i &lt;&lt; endl;
      }

      void print(double  f) {
        cout &lt;&lt; &quot;Printing float: &quot; &lt;&lt; f &lt;&lt; endl;
      }

      void print(char* c) {
        cout &lt;&lt; &quot;Printing character: &quot; &lt;&lt; c &lt;&lt; endl;
      }
};

int main(void)
{
   printData pd;
 
   // Call print to print integer
   pd.print(5);
   // Call print to print float
   pd.print(500.263);
   // Call print to print character
   pd.print(&quot;Hello C++&quot;);
 
   return 0;
}
//输出结果 ：就是定义了一堆重名函数，但是他们的输入是不一样的，再以此来区分他们之间的区别
Printing int: 5
Printing float: 500.263
Printing character: Hello C++
</code></pre>
<h4 id="a-name212运算符重载aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name212运算符重载aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="21">2、运算符重载</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p><strong>重载的运算符是带有特殊名称的函数</strong>，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<pre><code class="language-cpp">//作为成员函数时的定义方法
Box operator+(const Box&amp;);
</code></pre>
<p>==声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示==：</p>
<p>补充:⁉️: <strong>区分类的成员函数与类的非成员函数</strong> 举一个例子🌰：</p>
<pre><code class="language-cpp">////////////原始的类//////////////
class People{
        public:
            ...
            void Getup( );
            void Washing( );
            void eating( );
            ...
        }
////////////成员函数//////////////
class People
{
  			public:
  			……
          void morningAction(){ //在这里，morningAction函数也就是成员函数
          	void Getup( );
            void Washing( );
            void eating( );  
        }
        		
}
////////////非成员函数//////////////
void moringAction(People&amp; p)//在这里，将函数定义在类的外部，将类作为输入参数并操作类中的函数及变量的方法，此时这个函数被称作非成员函数
        {
                p.Getup( );
                p.Washing( );
                p.eating( );
        }
</code></pre>
<p>如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p>
<pre><code class="language-cpp">//作为非成员函数时定义重载符的语句
Box operator+(const Box&amp;, const Box&amp;);
</code></pre>
<p>下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 <strong>this</strong> 运算符进行访问，</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Box
{
   public:

      double getVolume(void)
      {
         return length * breadth * height;
      }
      void setLength( double len )
      {
          length = len;
      }

      void setBreadth( double bre )
      {
          breadth = bre;
      }

      void setHeight( double hei )
      {
          height = hei;
      }
      // 重载 + 运算符，用于把两个 Box 对象相加
      Box operator+(const Box&amp; b) //相当于检测到有BOX类跟+连用时，就会自动重载
      {
         Box box;
         box.length = this-&gt;length + b.length;
         box.breadth = this-&gt;breadth + b.breadth;
         box.height = this-&gt;height + b.height;
         return box;
      }
   private:
      double length;      // 长度
      double breadth;     // 宽度
      double height;      // 高度
};
// 程序的主函数
int main( )
{
   Box Box1;                // 声明 Box1，类型为 Box
   Box Box2;                // 声明 Box2，类型为 Box
   Box Box3;                // 声明 Box3，类型为 Box
   double volume = 0.0;     // 把体积存储在该变量中
 
   // Box1 详述
   Box1.setLength(6.0); 
   Box1.setBreadth(7.0); 
   Box1.setHeight(5.0);
 
   // Box2 详述
   Box2.setLength(12.0); 
   Box2.setBreadth(13.0); 
   Box2.setHeight(10.0);
 
   // Box1 的体积
   volume = Box1.getVolume();
   cout &lt;&lt; &quot;Volume of Box1 : &quot; &lt;&lt; volume &lt;&lt;endl;
 
   // Box2 的体积
   volume = Box2.getVolume();
   cout &lt;&lt; &quot;Volume of Box2 : &quot; &lt;&lt; volume &lt;&lt;endl;

   // 把两个对象相加，得到 Box3
   Box3 = Box1 + Box2; //此处自动重载加号运算符

   // Box3 的体积
   volume = Box3.getVolume();
   cout &lt;&lt; &quot;Volume of Box3 : &quot; &lt;&lt; volume &lt;&lt;endl;

   return 0;
}
//输出结果
Volume of Box1 : 210
Volume of Box2 : 1560
Volume of Box3 : 5400
</code></pre>
<p>下面是可重载的运算符列表：</p>
<table><thead><tr><th>+</th><th>-</th><th>*</th><th>/</th><th>%</th><th>^</th></tr></thead><tbody>
<tr><td>&amp;</td><td>|</td><td>~</td><td>!</td><td>,</td><td>=</td></tr>
<tr><td>&lt;</td><td>&gt;</td><td>&lt;=</td><td>&gt;=</td><td>++</td><td>--</td></tr>
<tr><td>&lt;&lt;</td><td>&gt;&gt;</td><td>==</td><td>!=</td><td>&amp;&amp;</td><td>||</td></tr>
<tr><td>+=</td><td>-=</td><td>/=</td><td>%=</td><td>^=</td><td>&amp;=</td></tr>
<tr><td>|=</td><td>*=</td><td>&lt;&lt;=</td><td>&gt;&gt;=</td><td>[]</td><td>()</td></tr>
<tr><td>-&gt;</td><td>-&gt;*</td><td>new</td><td>new []</td><td>delete</td><td>delete []</td></tr>
</tbody></table>
<p>下面是不可重载的运算符列表：</p>
<table><thead><tr><th>::</th><th>.*</th><th>.</th><th>?:</th></tr></thead><tbody>
</tbody></table>
<h3 id="a-name22六重载运算符实例aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name22六重载运算符实例aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="22">六、重载运算符实例</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h3>
<h4 id="a-name231一元运算符重载也就是只有一个数字参与运算的情况aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name231一元运算符重载也就是只有一个数字参与运算的情况aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="23"><strong>1、一元运算符重载</strong>（也就是只有一个数字参与运算的情况）</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>一元运算符只对一个操作数进行操作，下面是一元运算符的实例：</p>
<ul>
<li><a href="https://www.w3cschool.cn/cpp/increment-decrement-operators-overloading.html">递增运算符（ ++ ）和递减运算符（ -- ）</a></li>
<li>一元减运算符，即负号（ - ）</li>
<li>逻辑非运算符（ ! ）</li>
</ul>
<p>一元运算符通常出现在它们所操作的对象的左边，比如 !obj、-obj 和 ++obj，但有时它们也可以作为后缀，比如 obj++ 或 obj--。</p>
<p>例子1：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 
class Distance
{
   private:
      int feet;             // 0 到无穷
      int inches;           // 0 到 12
   public:
      // 所需的构造函数
      Distance(){
         feet = 0;
         inches = 0;
      }
      Distance(int f, int i){
         feet = f;
         inches = i;
      }
      // 显示距离的方法
      void displayDistance()
      {
         cout &lt;&lt; &quot;F: &quot; &lt;&lt; feet &lt;&lt; &quot; I:&quot; &lt;&lt; inches &lt;&lt;endl;
      }
      // 重载负运算符（ - ）
      Distance operator- ()//因为这里是前缀一元运算符，不用其他参数，所以这里的参数输入位置可以是空的
      {
         feet = -feet;
         inches = -inches;
         return Distance(feet, inches);//构造函数
      }
};
int main()
{
   Distance D1(11, 10), D2(-5, 11);
 
   -D1;                     // 取相反数
   D1.displayDistance();    // 距离 D1

   -D2;                     // 取相反数
   D2.displayDistance();    // 距离 D2

   return 0;
}
//返回结果
F: -11 I:-10
F: 5 I:-11
</code></pre>
<p>例子2：⭐️很重要，区分运算符是前缀还是后缀的</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 
class Time
{
   private:
      int hours;             // 0 到 23
      int minutes;           // 0 到 59
   public:
      // 所需的构造函数
      Time(){
         hours = 0;
         minutes = 0;
      }
      Time(int h, int m){
         hours = h;
         minutes = m;
      }
      // 显示时间的方法
      void displayTime()
      {
         cout &lt;&lt; &quot;H: &quot; &lt;&lt; hours &lt;&lt; &quot; M:&quot; &lt;&lt; minutes &lt;&lt;endl;
      }
      // 重载前缀递增运算符（ ++ ）
      Time operator++ ()  
      {
         ++minutes;          // 对象加 1
         if(minutes &gt;= 60)  
         {
            ++hours;
            minutes -= 60;
         }
         return Time(hours, minutes); //这里返回的相当于是构造函数，将对象重新初始化了
      }
      // 重载后缀递增运算符（ ++ ）
      Time operator++( int )         
      {
         // 保存原始值
         Time T(hours, minutes);
         // 对象加 1
         ++minutes;                    
         if(minutes &gt;= 60)
         {
            ++hours;
            minutes -= 60;
         }
         // 返回旧的原始值
         return T; 
      }
};
int main()
{
   Time T1(11, 59), T2(10,40);
 
   ++T1;                    // T1 加 1
   T1.displayTime();        // 显示 T1
   ++T1;                    // T1 再加 1
   T1.displayTime();        // 显示 T1
 
   T2++;                    // T2 加 1
   T2.displayTime();        // 显示 T2
   T2++;                    // T2 再加 1
   T2.displayTime();        // 显示 T2
   return 0;
}
//输出结果
H: 12 M:0
H: 12 M:1
H: 10 M:41
H: 10 M:42
</code></pre>
<h4 id="a-name242二元运算符重载aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name242二元运算符重载aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="24">2、二元运算符重载</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>二元运算符需要两个参数，下面是二元运算符的实例。我们平常使用的加运算符（ + ）、减运算符（ - ）、乘运算符（ * ）和除运算符（ / ）都属于二元运算符。就像加(+)运算符。</p>
<p>下面的实例演示了如何重载加运算符（ + ）。类似地，您也可以尝试重载减运算符（ - ）和除运算符（ / ）。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 
class Box
{
   double length;      // 长度
   double breadth;     // 宽度
   double height;      // 高度
public:
 
   double getVolume(void)
   {
      return length * breadth * height;
   }
   void setLength( double len )
   {
       length = len;
   }
 
   void setBreadth( double bre )
   {
       breadth = bre;
   }
 
   void setHeight( double hei )
   {
       height = hei;
   }
   // 重载 + 运算符，用于把两个 Box 对象相加
   Box operator+(const Box&amp; b)
   {
      Box box;
      box.length = this-&gt;length + b.length;
      box.breadth = this-&gt;breadth + b.breadth;
      box.height = this-&gt;height + b.height;
      return box;
   }
};
// 程序的主函数
int main( )
{
   Box Box1;                // 声明 Box1，类型为 Box
   Box Box2;                // 声明 Box2，类型为 Box
   Box Box3;                // 声明 Box3，类型为 Box
   double volume = 0.0;     // 把体积存储在该变量中
 
   // Box1 详述
   Box1.setLength(6.0); 
   Box1.setBreadth(7.0); 
   Box1.setHeight(5.0);
 
   // Box2 详述
   Box2.setLength(12.0); 
   Box2.setBreadth(13.0); 
   Box2.setHeight(10.0);
 
   // Box1 的体积
   volume = Box1.getVolume();
   cout &lt;&lt; &quot;Volume of Box1 : &quot; &lt;&lt; volume &lt;&lt;endl;
 
   // Box2 的体积
   volume = Box2.getVolume();
   cout &lt;&lt; &quot;Volume of Box2 : &quot; &lt;&lt; volume &lt;&lt;endl;
 
   // 把两个对象相加，得到 Box3
   Box3 = Box1 + Box2;
 
   // Box3 的体积
   volume = Box3.getVolume();
   cout &lt;&lt; &quot;Volume of Box3 : &quot; &lt;&lt; volume &lt;&lt;endl;
 
   return 0;
}
//输出结果
Volume of Box1 : 210
Volume of Box2 : 1560
Volume of Box3 : 5400
</code></pre>
<h4 id="a-name253关系运算符重载aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name253关系运算符重载aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="25">3、关系运算符重载</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>C++ 语言支持各种关系运算符（ &lt; 、 &gt; 、 &lt;= 、 &gt;= 、 == 等等），它们可用于比较 C++ 内置的数据类型。</p>
<p>您可以重载任何一个关系运算符，重载后的关系运算符可用于比较类的对象。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 
class Distance
{
   private:
      int feet;             // 0 到无穷
      int inches;           // 0 到 12
   public:
      // 所需的构造函数
      Distance(){
         feet = 0;
         inches = 0;
      }
      Distance(int f, int i){
         feet = f;
         inches = i;
      }
      // 显示距离的方法
      void displayDistance()
      {
         cout &lt;&lt; &quot;F: &quot; &lt;&lt; feet &lt;&lt; &quot; I:&quot; &lt;&lt; inches &lt;&lt;endl;
      }
      // 重载负运算符（ - ）//一元运算符
      Distance operator- ()  
      {
         feet = -feet;
         inches = -inches;
         return Distance(feet, inches);
      }
      // 重载小于运算符（ &lt; ）
      bool operator &lt;(const Distance&amp; d) //这里用的时布尔值
      {
         if(feet &lt; d.feet)
         {
            return true;
         }
         if(feet == d.feet &amp;&amp; inches &lt; d.inches)
         {
            return true;
         }
         return false;
        //只会返回一个return 也就是就没走到上面两个return时默认返回false
      }
};
int main()
{
   Distance D1(11, 10), D2(5, 11);
 
   if( D1 &lt; D2 )
   {
      cout &lt;&lt; &quot;D1 is less than D2 &quot; &lt;&lt; endl;
   }
   else
   {
      cout &lt;&lt; &quot;D2 is less than D1 &quot; &lt;&lt; endl;
   }
   return 0;
}
//输出结果
D2 is less than D1
</code></pre>
<h4 id="a-name264输入输出运算符重载aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name264输入输出运算符重载aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="26">4、输入/输出运算符重载</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>C++ 能够使用流提取运算符 &gt;&gt; 和流插入运算符 &lt;&lt; 来输入和输出内置的数据类型。您可以重载流提取运算符和流插入运算符来操作对象等用户自定义的数据类型。</p>
<p>在这里，有一点很重要，我们需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数。</p>
<p><strong>重载输入运算符&gt;&gt;</strong></p>
<p>下面我们以全局函数的形式重载<code>&gt;&gt;</code>，使它能够读入两个 double 类型的数据，并分别赋值给复数的实部和虚部：</p>
<pre><code class="language-cpp">istream &amp; operator&gt;&gt;(istream &amp;in, complex &amp;A){
    in &gt;&gt; A.m_real &gt;&gt; A.m_imag;
    return in;
}
</code></pre>
<p>istream 表示输入流，cin 是 istream 类的对象，只不过这个对象是在标准库中定义的。之所以返回 istream 类对象的引用，是为了能够连续读取复数，让代码书写更加漂亮，例如：</p>
<pre><code class="language-cpp">complex c1, c2;cin&gt;&gt;c1&gt;&gt;c2;
</code></pre>
<p>如果不返回引用，那就只能一个一个地读取了：</p>
<pre><code class="language-cpp">complex c1, c2;cin&gt;&gt;c1;cin&gt;&gt;c2;
</code></pre>
<p>另外，运算符重载函数中用到了 complex 类的 private 成员变量，必须在 complex 类中将该函数声明为友元函数：</p>
<pre><code class="language-cpp">friend istream &amp; operator&gt;&gt;(istream &amp; in , complex &amp;a);
</code></pre>
<p><code>&gt;&gt;</code>运算符可以按照下面的方式使用：</p>
<pre><code class="language-cpp">complex c;
cin&gt;&gt;c;
</code></pre>
<p>当输入<code>1.45 2.34</code>后，这两个小数就分别成为对象 c 的实部和虚部了。<code>cin&gt;&gt; c;</code>这一语句其实可以理解为：</p>
<pre><code class="language-cpp">operator &gt;&gt; (cin, c3)
</code></pre>
<p>调用函数时，形参in成为cin的引用，形参A成为c3的引用，因此调用函数的过程变为：</p>
<pre><code class="language-cpp">cin &gt;&gt; c3.m_real &gt;&gt; c3.m_imag; return cin
</code></pre>
<p><strong>重载输出运算符 &lt;&lt;</strong></p>
<p>同样地，我们也可以模仿上面的形式对输出运算符<code>&gt;&gt;</code>进行重载，让它能够输出复数，请看下面的代码：</p>
<pre><code class="language-cpp">ostream &amp; operator&lt;&lt;(ostream &amp;out, complex &amp;A){
    out &lt;&lt; A.m_real &lt;&lt;&quot; + &quot;&lt;&lt; A.m_imag &lt;&lt;&quot; i &quot;;
    return out;
}
</code></pre>
<p>ostream 表示输出流，cout 是 ostream 类的对象。由于采用了引用的方式进行参数传递，并且也返回了对象的引用，所以重载后的运算符可以实现连续输出。
为了能够直接访问 complex 类的 private 成员变量，同样需要将该函数声明为 complex 类的友元函数：（只有静态函数才能不经创建直接访问）</p>
<pre><code class="language-cpp">friend ostream &amp; operator&lt;&lt;(ostream &amp;out, complex &amp;A);
</code></pre>
<p>一个例子🌰：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 
class Distance
{
   private:
      int feet;             // 0 到无穷
      int inches;           // 0 到 12
   public:
      // 所需的构造函数
      Distance(){
         feet = 0;
         inches = 0;
      }
      Distance(int f, int i){
         feet = f;
         inches = i;
      }
      friend ostream &amp;operator&lt;&lt;( ostream &amp;output, 
                                       const Distance &amp;D )
      { 
         output &lt;&lt; &quot;F : &quot; &lt;&lt; D.feet &lt;&lt; &quot; I : &quot; &lt;&lt; D.inches;
         return output;            
      }

      friend istream &amp;operator&gt;&gt;( istream  &amp;input, Distance &amp;D )
      { 
         input &gt;&gt; D.feet &gt;&gt; D.inches;
         return input;            
      }
};
int main()
{
   Distance D1(11, 10), D2(5, 11), D3;

   cout &lt;&lt; &quot;Enter the value of object : &quot; &lt;&lt; endl;
   cin &gt;&gt; D3;
   cout &lt;&lt; &quot;First Distance : &quot; &lt;&lt; D1 &lt;&lt; endl;
   cout &lt;&lt; &quot;Second Distance :&quot; &lt;&lt; D2 &lt;&lt; endl;
   cout &lt;&lt; &quot;Third Distance :&quot; &lt;&lt; D3 &lt;&lt; endl;


   return 0;
}
//输出结果
$./a.out
Enter the value of object :
70
10
First Distance : F : 11 I : 10
Second Distance :F : 5 I : 11
Third Distance :F : 70 I : 10
</code></pre>
<h4 id="a-name274赋值运算符重载aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name274赋值运算符重载aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="27">4、赋值运算符重载</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>就像其他运算符一样，您可以重载赋值运算符（ = ），用于创建一个对象，比如拷贝构造函数。</p>
<p>下面的实例演示了如何重载赋值运算符。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 
class Distance
{
   private:
      int feet;             // 0 到无穷
      int inches;           // 0 到 12
   public:
      // 所需的构造函数
      Distance(){
         feet = 0;
         inches = 0;
      }
      Distance(int f, int i){
         feet = f;
         inches = i;
      }
      void operator=(const Distance &amp;D )
      { 
         feet = D.feet;
         inches = D.inches;
      }
      // 显示距离的方法
      void displayDistance()
      {
         cout &lt;&lt; &quot;F: &quot; &lt;&lt; feet &lt;&lt;  &quot; I:&quot; &lt;&lt;  inches &lt;&lt; endl;
      }
      
};
int main()
{
   Distance D1(11, 10), D2(5, 11);

   cout &lt;&lt; &quot;First Distance : &quot;; 
   D1.displayDistance();
   cout &lt;&lt; &quot;Second Distance :&quot;; 
   D2.displayDistance();

   // 使用赋值运算符
   D1 = D2;
   cout &lt;&lt; &quot;First Distance :&quot;; 
   D1.displayDistance();

   return 0;
}
//输出结果
First Distance : F: 11 I:10
Second Distance :F: 5 I:11
First Distance :F: 5 I:11
</code></pre>
<h4 id="a-name285函数调用运算符--重载aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name285函数调用运算符--重载aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="28">5、函数调用运算符 () 重载</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h4>
<p>函数调用运算符 () 可以被重载用于类的对象。当重载 () 时，您不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 
class Distance
{
   private:
      int feet;             // 0 到无穷
      int inches;           // 0 到 12
   public:
      // 所需的构造函数
      Distance(){
         feet = 0;
         inches = 0;
      }
      Distance(int f, int i){
         feet = f;
         inches = i;
      }
      // 重载函数调用运算符
      Distance operator()(int a, int b, int c)
      {
         Distance D;
         // 进行随机计算
         D.feet = a + c + 10;
         D.inches = b + c + 100 ;
         return D;
      }
      // 显示距离的方法
      void displayDistance()
      {
         cout &lt;&lt; &quot;F: &quot; &lt;&lt; feet &lt;&lt;  &quot; I:&quot; &lt;&lt;  inches &lt;&lt; endl;
      }
      
};
int main()
{
   Distance D1(11, 10), D2;

   cout &lt;&lt; &quot;First Distance : &quot;; 
   D1.displayDistance();

   D2 = D1(10, 10, 10); // invoke operator()只要检测到（）内变为三个了，证明就激发了这个重载，就会进行内部定义的运算。
   cout &lt;&lt; &quot;Second Distance :&quot;; 
   D2.displayDistance();

   return 0;
}
//输出结果
First Distance : F: 11 I:10
Second Distance :F: 30 I:120
</code></pre>
<h3 id="a-name29七c类的多态aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a class="header" href="#a-name29七c类的多态aa-stylefloatrighttext-decorationnone-hrefc学习c进阶带目录htmlindextopa"><a name="29">七、C++类的多态</a><a style="float:right;text-decoration:none;" href="C++学习/C++进阶带目录.html#index">[Top]</a></a></h3>
<p><strong>多态</strong>按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p>
<p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数</p>
<pre><code class="language-cpp">#include &lt;iostream&gt; 
using namespace std;
 
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      int area()
      {
         cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl;
         return 0;
      }
};
class Rectangle: public Shape{
   public:
      Rectangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout &lt;&lt; &quot;Rectangle class area :&quot; &lt;&lt;endl;
         return (width * height); 
      }
};
class Triangle: public Shape{
   public:
      Triangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout &lt;&lt; &quot;Triangle class area :&quot; &lt;&lt;endl;
         return (width * height / 2); 
      }
};
// 程序的主函数
int main( )
{
   Shape *shape;
   Rectangle rec(10,7);
   Triangle  tri(10,5);

   // 存储矩形的地址
   shape = &amp;rec;
   // 调用矩形的求面积函数 area
   shape-&gt;area();

   // 存储三角形的地址
   shape = &amp;tri;
   // 调用三角形的求面积函数 area
   shape-&gt;area();
   
   return 0;
}
//输出结果
Parent class area
Parent class area
❌：不对啊，我希望输出的结果是两个的子类的，但是这里只有父类area函数的调用
</code></pre>
<blockquote>
<p>导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的<strong>静态多态</strong>，或<strong>静态链接</strong> - 函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area() 函数在程序编译期间就已经设置好了。</p>
</blockquote>
<p>为了克服上述问题，我直接在父类定义的需要被重写的函数之前佳哥virtual，然后后续编译器在运行的时候就会自动使用子类中的定义方法。</p>
<pre><code class="language-cpp">class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      virtual int area()
      {
         cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl;
         return 0;
      }
};
//输出结果
//Rectangle class area
//Triangle class area
</code></pre>
<p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。</p>
<p>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是<strong>多态</strong>的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的</p>
<blockquote>
<p>❌：在这里，这个带有virtual定义的函数就叫做虚函数</p>
</blockquote>
<p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>
<p>==我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定==</strong>。</p>
<p><strong>纯虚函数</strong></p>
<p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p>
<p>我们可以把基类中的虚函数 area() 改写如下：</p>
<pre><code class="language-cpp">class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      // pure virtual function
      virtual int area() = 0; //在这里，也就是不定义函数内容，直接给他赋值成0
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="navigation"><a class="header" href="#navigation">Navigation</a></h3>
<ul>
<li><a href="C++%E5%AD%A6%E4%B9%A0/index.html">tech.bitvijays.com</a> »</li>
</ul>
<h3 id="a-hrefce5ada6e4b9a0indexhtmltable-of-contentsa"><a class="header" href="#a-hrefce5ada6e4b9a0indexhtmltable-of-contentsa"><a href="C++%E5%AD%A6%E4%B9%A0/index.html">Table Of Contents</a></a></h3>
<ul>
<li>Infrastructure PenTest Series : Part 1 - Intelligence Gathering
<ul>
<li>Scenarios
<ul>
<li>Outside - External</li>
<li>Inside - Internal
<ul>
<li>Wired LAN</li>
<li>Wireless LAN</li>
<li>Responder/ Inveigh</li>
<li>NTLM/ NTLMv1/v2 / Net-NTLMv1/v2</li>
</ul>
</li>
</ul>
</li>
<li>Fingerprinting</li>
<li>Passive Fingerprinting:
<ul>
<li>Whois</li>
<li>ASN Number
<ul>
<li>Recon-ng</li>
<li>The Harvester</li>
</ul>
</li>
<li>Enumeration with Domain Name (e.g. example.com) using external websites
<ul>
<li>DNS Dumpster API</li>
<li>Google Dorks (search operators)</li>
<li>Other Tools</li>
<li>Publicly available scans of IP Addresses</li>
</ul>
</li>
<li>Reverse DNS Lookup using External Websites
<ul>
<li>DomainTools Reverse IP Lookup</li>
<li>PassiveTotal</li>
<li>Server-Sniff</li>
<li>Robtex</li>
</ul>
</li>
</ul>
</li>
<li>Active Fingerprinting
<ul>
<li>Finding DNS, MX, AAAA, A using
<ul>
<li>host</li>
<li>nslookup</li>
</ul>
</li>
<li>DNS Zone Transfer
<ul>
<li>host</li>
<li>Dig</li>
<li>dnsrecon</li>
<li>DNSEnum</li>
<li>SRV Records</li>
</ul>
</li>
</ul>
</li>
<li>Internal Infrastructure Mapping
<ul>
<li>Internal Network Range Identification
<ul>
<li>Ping Gateway IP Addresses</li>
<li>DNS Enumeration</li>
<li>Internal Portal Links</li>
<li>Reverse DNS Lookup</li>
</ul>
</li>
<li>Identifying Alive IP Addresses</li>
<li>Port Scanning
<ul>
<li>Identifying service versions</li>
<li>Performance</li>
<li>Nmap Scripts</li>
<li>Output Options</li>
</ul>
</li>
<li>Exploring the Network Further
<ul>
<li>Gathering Screenshots for http* services</li>
<li>Information Gathering for http* Services</li>
<li>NetBIOS Service</li>
<li>NBTSCAN</li>
<li>enum4linux</li>
<li>SNMP Enumeration</li>
</ul>
</li>
</ul>
</li>
<li>Attack Surface Area - Reconnaissance Tools
<ul>
<li>Aquatone: A tool for domain flyovers</li>
<li>DataSploit</li>
<li>Spiderfoot</li>
<li>Intrigue.io</li>
</ul>
</li>
<li>Appendix-I : Interesting Stories
<ul>
<li>Initial Compromise</li>
</ul>
</li>
<li>Changelog</li>
</ul>
</li>
</ul>
<h3 id="this-page"><a class="header" href="#this-page">This Page</a></h3>
<ul>
<li><a href="C++%E5%AD%A6%E4%B9%A0/_sources/LFF-IPS-P1-IntelligenceGathering.rst.txt">Show Source</a></li>
<li><a href="https://github.com/bitvijays/bitvijays.github.io-sphinx/blob/master/docs/LFF-IPS-P1-IntelligenceGathering.rst">Show on GitHub</a></li>
<li><a href="https://github.com/bitvijays/bitvijays.github.io-sphinx/edit/master/docs/LFF-IPS-P1-IntelligenceGathering.rst">Edit on GitHub</a></li>
</ul>
<h3 id="quick-search"><a class="header" href="#quick-search">Quick search</a></h3>
<h1 id="infrastructure-pentest-series--part-1---intelligence-gathering"><a class="header" href="#infrastructure-pentest-series--part-1---intelligence-gathering">Infrastructure PenTest Series : Part 1 - Intelligence Gathering¶</a></h1>
<p>This post (always Work in Progress) lists technical steps which one can follow
while gathering information about an organization.</p>
<p>Suppose, we are tasked with an external/ internal penetration test of a big
organization with DMZ, Data centers, Telecom network etc. Moreover, the only
information that we know at this moment is the company name and/or it’s domain
name such as example.com</p>
<p><strong>Shout-outs (thanks) to the Vulnhub-ctf team, bonsaiviking, recrudesce,
Rajesh and Tanoy</strong></p>
<h2 id="scenarios"><a class="header" href="#scenarios">Scenarios¶</a></h2>
<p>Mostly, there are only two scenarios either we are outside/ inside the
organization.</p>
<h3 id="outside---external"><a class="header" href="#outside---external">Outside - External¶</a></h3>
<p>If we are outside or doing an external pentest. We need to figure out the
attack surface area first.</p>
<p>The could be achieved by answering the following questions:</p>
<p>What are the</p>
<ul>
<li>Domain/ subdomains present? (like example.com – domain; ftp.example.com – subdomain)</li>
<li>IP Addresses/ Network ranges/ ASN Number(s) assigned?</li>
<li>Different Services (open ports) running on those IP Addresses?</li>
<li>Email addresses or People working for the organization?</li>
<li>Different Operating Systems/ Software used in the organization?</li>
</ul>
<p>Additionally it is also interesting to know if there have been any security
breaches in the past.</p>
<p>We might be able to compromise user credential(s) or running vulnerable
service(s) and get inside the internal network of the organization.</p>
<h3 id="inside---internal"><a class="header" href="#inside---internal">Inside - Internal¶</a></h3>
<p>When we are inside the organization (let’s say physically) there are two
common situations:</p>
<ul>
<li>Potentially, posing as an employee (already having access to the internal network).</li>
<li>External consultant (with no internal network access as of now).</li>
</ul>
<p>Let’s first explore what options we have as external consultant sitting in a
conference room.</p>
<h4 id="wired-lan"><a class="header" href="#wired-lan">Wired LAN¶</a></h4>
<p>If there’s a LAN cable laying around and we (obviously) plug it in our
computer, the following situations can occur:</p>
<ul>
<li>DHCP (Dynamic Host Configuration Protocol) is enabled and your machine is provided with an IP Address.</li>
<li>DHCP is disabled; however the LAN cable is working. In this case, we might be able to sniff the network and figure out the near-by IP Address, netmask and default gateway and configure our device to use a static IP.</li>
<li>Network Access Control is enabled, then probably we would need to search for</li>
</ul>
<blockquote>
<ul>
<li>A device (such as printers) attached to network, clone it’s MAC address
and try again) or</li>
<li>IP Phones or any Hub or</li>
<li>Connect USB to LAN device to any already connected machine.</li>
</ul>
</blockquote>
<ul>
<li>LAN port is disabled (We can’t do much here! Can we?).</li>
</ul>
<p>Todo</p>
<p>explain how to clone a mac</p>
<h4 id="wireless-lan"><a class="header" href="#wireless-lan">Wireless LAN¶</a></h4>
<ul>
<li>Check for Open/ Guest Wi-Fi - If you are connected somehow try to access the internal network range(s). Most probably, the organization would have segregated the network properly. However, sometimes DNS Names can be resolved.</li>
<li>Check if any WEP/ WPA2 networks are present. If so, we can try to crack them.</li>
</ul>
<h2 id="once-you-are-inside-we-need-to-find-answers-to-the-above-questions"><a class="header" href="#once-you-are-inside-we-need-to-find-answers-to-the-above-questions">Once you are inside, we need to find answers to the above questions</a></h2>
<p>(Outside - External section).</p>
<p>Note</p>
<p>Fingerprinting can be done from both Internal/ External of the organization</p>
<p>Todo</p>
<p>explain how to crack WEP/WPA2</p>
<h4 id="responder-inveigh"><a class="header" href="#responder-inveigh">Responder/ Inveigh¶</a></h4>
<p>Once, you are inside, probably the first thing would be to utilize
<strong>Responder</strong> or <strong>Inveigh</strong> in <strong>Analyze mode</strong>.</p>
<ul>
<li><a href="https://github.com/lgandx/Responder">Responder</a> : Responder is a LLMNR, NBT-NS and MDNS poisoner, with built-in HTTP/ SMB/ MSSQL/ FTP/ LDAP rogue authentication server supporting NTLMv1/ NTLMv2/ LMv2, Extended Security NTLMSSP and Basic HTTP authentication. It is very important to understand LLMNR, NBT-NS. Understand the basics by reading the <a href="https://www.sternsecurity.com/blog/local-network-attacks-llmnr-and-nbt-ns-poisoning">Local Network Attacks: LLMNR and NBT-NS Poisoning</a>, <a href="https://pentest.blog/what-is-llmnr-wpad-and-how-to-abuse-them-during-pentest/">What is LLMNR &amp; WPAD and How to Abuse Them During Pentest ?</a> and <a href="https://www.pentestpartners.com/security-blog/how-to-get-windows-to-give-you-credentials-through-llmnr/">How to get Windows to give you credentials through LLMNR</a></li>
</ul>
<blockquote>
<p>Basically it’s like this</p>
<ul>
<li>A user wants to access a file server named “NAS001” by \NAS001, however,
mistakenly types \NAS01.</li>
<li>The query goes to the DNS server to resolve the IP address of NAS01.
However, as it’s not a valid hostname, DNS Server responds to the user
saying that it doesn’t know that host.</li>
<li>The user broadcasts on the local network and asks if anyone knows who is
\NAS01</li>
<li>The attacker (if on the same network) seizing the opportunity says “I am
NAS01 here is my IP Address”</li>
<li>The user believes the attacker and sends its own username and NTMLv2
hash to the attacker.</li>
<li>The attacker gathers all the hashes and cracks them (offline) to gain
password.</li>
</ul>
</blockquote>
<blockquote>
<p>Recently, Responder also got the functionality to act as a Multi-relay,
which allows you to relay the NTLMv1/2 authentication to a specific target
and possibly execute code (during a successful attack) on the target node.
NotSoSecure has written a detailed blog on this technique: [Pwning with
Responder – A Pentester’s Guide](https://www.notsosecure.com/pwning-with-
responder-a-pentesters-guide/)</p>
<p>Similar to Python Responder, there is Inveigh</p>
</blockquote>
<ul>
<li><a href="https://github.com/Kevin-Robertson/Inveigh">Inveigh</a> is a PowerShell LLMNR/ mDNS/ NBNS spoofer and man-in-the-middle tool designed to assist penetration testers and red teamers that find themselves limited to a Windows system.</li>
</ul>
<p>Todo</p>
<p>eloborate on Inveigh?</p>
<h4 id="ntlm-ntlmv1v2--net-ntlmv1v2"><a class="header" href="#ntlm-ntlmv1v2--net-ntlmv1v2">NTLM/ NTLMv1/v2 / Net-NTLMv1/v2¶</a></h4>
<p>The Responder/ Inveigh tools and the hashes NTLM/ NTLMv1/v2 / Net-NTLMv1/v2
are Windows environment specific.</p>
<p><em>Probably, we should cover this in Exploitation phase. However as we have just
mentioned Responder/ Inveigh here, it makes sense to include this here</em></p>
<ul>
<li>NTLM: NTLM hashes are stored in the Security Account Manager (SAM) database and in the Domain Controller’s NTDS.dit database.</li>
</ul>
<blockquote>
<pre><code>aad3b435b51404eeaad3b435b51404ee:e19ccf75ee54e06b06a5907af13cef42
</code></pre>
<p>The LM hash is the one before the semicolon (:) and the NT hash is the one
after the semicolon. Starting with Windows Vista and Windows Server 2008, by
default, only the NT hash is stored.</p>
</blockquote>
<ul>
<li>NTLMv1/v2 / Net-NTLMv1/v2 : Net-NTLM hashes are used for network authentication (they are derived from a challenge/response algorithm and are based on the user’s NT hash). Here is an example of a Net-NTLMv2 (a.k.a NTLMv2) hash:</li>
</ul>
<blockquote>
<p>admin::N46iSNekpT:08ca45b7d7ea58ee:88dcbe4446168966a153a0064958dac6:5c7830315c7830310000000000000b45c67103d07d7b95acd12ffa11230e0000000052920b85f78d013c31cdb3b92f5d765c783030</p>
</blockquote>
<p>From a pentesting perspective:</p>
<ul>
<li>You CAN perform Pass-The-Hash attacks with NTLM hashes.</li>
<li>You CANNOT perform Pass-The-Hash attacks with Net-NTLM hashes.</li>
</ul>
<p>Todo</p>
<p>so Net-NTLM needs to be cracked, how?</p>
<p>The above has been taken from [Practical guide to NTLM Relaying in 2017 (A.K.A
getting a foothold in under 5
minutes)](https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-
in-2017-aka-getting-a-foothold-in-under-5-minutes.html) He has explained it
very well and also showed how to own the network using relaying the hashes
from Responder to get a system shell. Another good blog to understand this is
[SMB Relay Demystified and NTLMv2 Pwnage with Python](https://pen-
testing.sans.org/blog/pen-testing/2013/04/25/smb-relay-demystified-and-
ntlmv2-pwnage-with-python)</p>
<h2 id="fingerprinting"><a class="header" href="#fingerprinting">Fingerprinting¶</a></h2>
<p>We can either do <strong>Passive fingerprinting</strong> (learning more about the company,
without them knowing it) or <strong>Active fingerprinting</strong> (process of transmitting
packets to a remote host and analysing corresponding replies (which very
likely will be logged)).</p>
<p><strong>Passive fingerprinting</strong> and <strong>Active fingerprinting</strong> can be done by using
various methods such as:</p>
<table><thead><tr><th>Passive Fingerprinting</th><th>Active Fingerprinting</th></tr></thead><tbody>
</tbody></table>
<ul>
<li>whois</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>* Finding DNS, MX, AAAA, A</td></tr>
</tbody></table>
<ul>
<li>ASN Number</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>* DNS Zone Transfer(s)</td></tr>
</tbody></table>
<ul>
<li>Enumeration with Domain Name</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>* SRV Records</td></tr>
</tbody></table>
<ul>
<li>Publicly available scans of IP Addresses</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>* Port Scanning</td></tr>
</tbody></table>
<ul>
<li>Reverse DNS Lookup using External Websites</li>
</ul>
<table><thead><tr></tr></thead><tbody>
<tr><td>Do you remember from earlier? We need to find answers to</td></tr>
</tbody></table>
<table><thead><tr><th>Questions (What are the)</th><th>Answer</th></tr></thead><tbody>
<tr><td>Different domain/ subdomains present?</td><td>whois, DNS-MX/AAAA/A/SRV, Enumeration</td></tr>
<tr><td>with Domain Name</td><td></td></tr>
<tr><td>Different IP Address/ Network ranges/ ASN Number assigned?</td><td>DNS, ASN-Number,</td></tr>
<tr><td>DNS-Zone-Transfer</td><td></td></tr>
<tr><td>Different Services/ Ports running on those IP Addresses?</td><td>Public Scans of IP/</td></tr>
<tr><td>Port Scanning</td><td></td></tr>
<tr><td>Email addresses or People working in the organization?</td><td>harvestor, LinkedIn</td></tr>
<tr><td>What are the different Operating Systems/ Software used?</td><td>FOCA</td></tr>
<tr><td>Any breaches which happened in the organization?</td><td></td></tr>
</tbody></table>
<p>The active and passive fingerprinting would help us to get those answers!</p>
<h2 id="passive-fingerprinting"><a class="header" href="#passive-fingerprinting">Passive Fingerprinting:¶</a></h2>
<h3 id="whois"><a class="header" href="#whois">Whois¶</a></h3>
<p>Whois provides information about the registered users or assignees of an
Internet resource, such as a Domain name, an IP address block, or an
autonomous system.</p>
<p>whois acts differently when given an IP address then a domain name.</p>
<ul>
<li>
<p>For a Domain name, it just provides registrar name etc.</p>
</li>
<li>
<p>For a IP address, it provides the net-block, ASN Number etc.</p>
<p>whois &lt;Domain Name/ IP Address&gt;
-H Do not display the legal disclaimers some registries like to show you.</p>
</li>
</ul>
<p>Googling for</p>
<pre><code>&quot;Registrant Organization&quot; inurl: domaintools
</code></pre>
<p>Also helps for to search for new domains registered by the same organization.
“Registrant Organization” is present in the output of whois. This technique
was used by person who compromised FinFisher in his
<a href="http://pastebin.com/raw/cRYvK4jb">writeup</a>.</p>
<p>Todo</p>
<p>Add example so people don’t have to (re)read or skim through the pastebin
article</p>
<h3 id="asn-number"><a class="header" href="#asn-number">ASN Number¶</a></h3>
<p>We could find the AS Number that participates in the Border Gateway Protocol
(BGP) used by particular organization which could further inform about the IP
address ranges used by the organization. An ASN Number could be found by using
Team CMRU whois service</p>
<pre><code>whois -h whois.cymru.com &quot; -v 216.90.108.31&quot;                         |
</code></pre>
<p>If you want to do bulk queries refer @ <a href="http://www.team-cymru.org/IP-ASN-mapping.html">IP-ASN-Mapping-Team-
CYMRU</a></p>
<p>Hurricane Electric Internet Services also provide a website
<a href="http://bgp.he.net">BGPToolkit</a> which provides your IP Address ASN or search
function by Name, IP address etc. It also provides AS Peers which might help
in gathering more information about the company in terms of its neighbors.</p>
<p>Todo</p>
<p>Commandline checking of subnet and making whois query efficient.</p>
<h4 id="recon-ng"><a class="header" href="#recon-ng">Recon-ng¶</a></h4>
<p>Todo</p>
<p>Add the following line to unconfuse people?</p>
<p>Todo</p>
<p>Note that is this context hosts are subdomains</p>
<ul>
<li>use recon/domains-hosts/bing_domain_web : Harvests hosts from Bing.com by using the site search operator.</li>
<li>use recon/domains-hosts/google_site_web : Harvests hosts from google.com by using the site search operator.</li>
<li>use recon/domains-hosts/brute_hosts : Brute forces host names using DNS.</li>
<li>use recon/hosts-hosts/resolve : Resolves the IP address for a host.</li>
<li>use reporting/csv : Creates a CSV file containing the specified harvested data.</li>
</ul>
<p>Jason Haddix has created a dynamic resource script for sub-domain discovery
which is available <a href="https://github.com/jhaddix/domain">here</a>. Simply provide
the domain name and it runs the necessary modules, creates a new workspace and
save the report.</p>
<p>Todo</p>
<p>Check API option too, why google_site_web is failing, add a module to add ASN
Info and Location Info too.</p>
<h4 id="the-harvester"><a class="header" href="#the-harvester">The Harvester¶</a></h4>
<p>The harvester provides email addresses, virtual hosts, different domains,
shodan results etc. for the domain. It provides really good results,
especially if you combine with shodan results as it may provide server
versions and what’s OS is running on a provided IP address.</p>
<pre><code>Usage: theharvester options
   -d: Domain to search or company name
   -b: data source: google, googleCSE, bing, bingapi, pgp
                    linkedin, google-profiles, people123, jigsaw,
                    twitter, googleplus, all
   -v: Verify host name via dns resolution and search for virtual hosts                              |
   -f: Save the results into an HTML and XML file
   -c: Perform a DNS brute force for the domain name
   -t: Perform a DNS TLD expansion discovery
   -e: Use this DNS server
   -h: use SHODAN database to query discovered hosts             |
</code></pre>
<p>Todo</p>
<p>Combine these results with recon-ng and DNS Dumpsters and create one csv with
all results.</p>
<h3 id="enumeration-with-domain-name-eg-examplecom-using-external-websites"><a class="header" href="#enumeration-with-domain-name-eg-examplecom-using-external-websites">Enumeration with Domain Name (e.g. example.com) using external websites¶</a></h3>
<p>If you have domain name you could use</p>
<h4 id="dns-dumpster-api"><a class="header" href="#dns-dumpster-api">DNS Dumpster API¶</a></h4>
<p>We can utilize DNS Dumpster’s API to know the various sub-domain related to a
domain.</p>
<pre><code>curl -s http://api.hackertarget.com/hostsearch/?q=example.com &gt; hostsearch
</code></pre>
<p>and the various dns queries by</p>
<pre><code>curl -s http://api.hackertarget.com/dnslookup/?q=example.com &gt; dnslookup
</code></pre>
<h4 id="google-dorks-search-operators"><a class="header" href="#google-dorks-search-operators">Google Dorks (search operators)¶</a></h4>
<ul>
<li><strong>site</strong> : Get results from certain sites or domains.</li>
<li><strong>filetype:suffix</strong> : Limits results to pages whose names end in suffix. The suffix is anything following the last period in the file name of the web page. For example: filetype:pdf</li>
<li><strong>allinurl/ inurl</strong> : Restricts results to those containing all the query terms you specify in the URL. For example, [ allinurl: google faq ] will return only documents that contain the words “google” and “faq” in the URL, such as “www.google.com/help/faq.html”.</li>
<li><strong>allintitle/ intitle</strong> : Restricts results to those containing all the query terms you specify in the title.</li>
</ul>
<p>Three good places to refer are <a href="https://support.google.com/websearch/answer/2466433">Search
Operators</a>, [Advanced
Operators](https://sites.google.com/site/gwebsearcheducation/advanced-
operators) and [Google Hacking Database](https://www.exploit-db.com/google-
hacking-database/).</p>
<h4 id="other-tools"><a class="header" href="#other-tools">Other Tools¶</a></h4>
<ul>
<li><a href="http://www.mcafee.com/in/downloads/free-tools/sitedigger.aspx">Mcafee Site Digger</a> searches Google’s cache to look for vulnerabilities, errors, configuration issues,proprietary information, and interesting security nuggets on web sites.</li>
<li><a href="http://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/">SearchDiggityv3</a> is Bishop Fox’s MS Windows GUI application that serves as a front-end to the most recent versions of our Diggity tools: GoogleDiggity, BingDiggity, Bing, LinkFromDomainDiggity, CodeSearchDiggity, DLPDiggity, FlashDiggity, MalwareDiggity, PortScanDiggity, SHODANDiggity, BingBinaryMalwareSearch, and NotInMyBackYard Diggity.</li>
</ul>
<h4 id="publicly-available-scans-of-ip-addresses"><a class="header" href="#publicly-available-scans-of-ip-addresses">Publicly available scans of IP Addresses¶</a></h4>
<ul>
<li><a href="https://exfiltrated.com/">Exfiltrated</a> provides the scans from the 2012 Internet Census. It would provide the IP address and the port number running at the time of scan in the year 2012.</li>
<li><a href="https://www.shodan.io/">Shodan</a>: provides the same results may be with recent scans. You need to be logged-in. Shodan CLI is available at <a href="https://cli.shodan.io/">Shodan Command-Line Interface</a></li>
</ul>
<p>Shodan Queries</p>
<pre><code>title   : Search the content scraped from the HTML tag
html    : Search the full HTML content of the returned page
product : Search the name of the software or product identified in the banner
net     : Search a given netblock (example: 204.51.94.79/18)
version : Search the version of the product
port    : Search for a specific port or ports
os      : Search for a specific operating system name
country : Search for results in a given country (2-letter code)
city    : Search for results in a given city
</code></pre>
<p>Todo</p>
<p>Learn how to access Shodan with API</p>
<ul>
<li><a href="https://censys.io/">Censys</a> is a search engine that allows computer scientists to ask questions about the devices and networks that compose the Internet. Driven by Internet-wide scanning, Censys lets researchers find specific hosts and create aggregate reports on how devices, websites, and certificates are configured and deployed. A good feature is the Query metadata which tells the number of Http, https and other protocols found in the IP network range.</li>
</ul>
<blockquote>
<p>Censys.io queries</p>
<pre><code>ip:192.168.0.0/24 -- CIDR notation
</code></pre>
</blockquote>
<h3 id="reverse-dns-lookup-using-external-websites"><a class="header" href="#reverse-dns-lookup-using-external-websites">Reverse DNS Lookup using External Websites¶</a></h3>
<p>Even after doing the above, sometimes we miss few of the domain name. Example:
Recently, In one of our engagement, the domain name was example.com and the
asn netblock was 192.168.0.0/24. We did recon-ng, theharvester, DNS reverse-
lookup via nmap. Still, we missed few of the websites hosted on same netblock
but with different domain such as example.in. We can find such entries by
using ReverseIP lookup by</p>
<h4 id="domaintools-reverse-ip-lookup"><a class="header" href="#domaintools-reverse-ip-lookup">DomainTools Reverse IP Lookup¶</a></h4>
<p><a href="http://reverseip.domaintools.com">Reverse IP Lookup by Domaintools</a>: Domain
name search tool that allows a wildcard search, monitoring of WHOIS record
changes and history caching, as well as Reverse IP queries.</p>
<h4 id="passivetotal"><a class="header" href="#passivetotal">PassiveTotal¶</a></h4>
<p><a href="https://www.passivetotal.org/">Passive Total</a> : A threat-analysis platform
created for analysts, by analysts.</p>
<h4 id="server-sniff"><a class="header" href="#server-sniff">Server-Sniff¶</a></h4>
<p><a href="http://serversniff.net.ipaddress.com/">Server Sniff</a> : A website providing IP
Lookup, Reverse IP services.</p>
<h4 id="robtex"><a class="header" href="#robtex">Robtex¶</a></h4>
<p><a href="https://www.robtex.com/">Robtex</a> : Robtex is one of the world’s largest
network tools. At robtex.com, you will find everything you need to know about
domains, DNS, IP, Routes, Autonomous Systems, etc. There’s a nmap nse [http-
robtex-reverse-ip](https://nmap.org/nsedoc/scripts/http-robtex-reverse-
ip.html) which can be used to find the domain/ website hosted on that ip.</p>
<pre><code>nmap --script http-robtex-reverse-ip --script-args http-robtex-reverse-ip.host='XX.XX.78.214'
Starting Nmap 7.01 ( https://nmap.org ) at 2016-04-20 21:39 IST
Pre-scan script results:
| http-robtex-reverse-ip:
|   xxxxxxindian.com
|_  www.xxxxxindian.com
</code></pre>
<h2 id="active-fingerprinting"><a class="header" href="#active-fingerprinting">Active Fingerprinting¶</a></h2>
<p>Most probably by now we have gathered all the public available information
without interacting with the client’s infrastructure. Next, we can use <strong>DNS
enumeration</strong> to gather more information about the client. The below
information could be gathered externally as well as internally. However, the
amount of information gathered from internal network would definitely be more
than when done externally.</p>
<h3 id="finding-dns-mx-aaaa-a-using"><a class="header" href="#finding-dns-mx-aaaa-a-using">Finding DNS, MX, AAAA, A using¶</a></h3>
<h4 id="host"><a class="header" href="#host">host¶</a></h4>
<pre><code>host &lt;domain&gt; &lt;optional_name_server&gt;
host -t ns &lt;domain&gt;           -- Name Servers
host -t a &lt;domain&gt;            -- Address
host -t aaaa &lt;domain&gt;         -- AAAA record points a domain or subdomain to an IPv6 address
host -t mx &lt;domain&gt;           -- Mail Servers
host -t soa &lt;domain&gt;          -- Start of Authority
host &lt;IP&gt;                     -- Reverse Lookup
</code></pre>
<p>Example:</p>
<pre><code>host -t ns zonetransfer.me
zonetransfer.me name server nsztm1.digi.ninja.
zonetransfer.me name server nsztm2.digi.ninja.
</code></pre>
<h4 id="nslookup"><a class="header" href="#nslookup">nslookup¶</a></h4>
<pre><code>nslookup - &lt;optional_name_server&gt;
set type=mx
set type=ns
</code></pre>
<h3 id="dns-zone-transfer"><a class="header" href="#dns-zone-transfer">DNS Zone Transfer¶</a></h3>
<p>If a DNS server is badly configured it might be possible to get a hold of all
of it records. This is interesting because if gives us an overview of what IP
to hostname translations the DNS server is aware off.</p>
<p>DNS Zone Transfer can be done with:</p>
<h4 id="host-1"><a class="header" href="#host-1">host¶</a></h4>
<pre><code>host -l &lt;Domain Name&gt; &lt;DNS Server&gt;
</code></pre>
<p>Try zonetransfer using host for zonetransfer.me using their name servers.</p>
<h4 id="dig"><a class="header" href="#dig">Dig¶</a></h4>
<pre><code>dig axfr &lt;domain_name&gt; @nameserver
</code></pre>
<p>Try zonetransfer using dig for zonetransfer.me using their name servers.</p>
<h4 id="dnsrecon"><a class="header" href="#dnsrecon">dnsrecon¶</a></h4>
<pre><code>dnsrecon -d &lt;domain&gt; -t axfr
</code></pre>
<p>dnsrecon could also be used for other purposes such as finding nameservers,
mailserver, forward reverse lookup</p>
<pre><code>-d, --domain      &lt;domain&gt;          Domain to Target for enumeration.
-r, --range       &lt;range&gt;           IP Range for reverse look-up brute force in formats (first-last) or in (range/bitmask).
-n, --name_server &lt;name&gt;            Domain server to use, if none is given the SOA of the target will be used
</code></pre>
<h4 id="dnsenum"><a class="header" href="#dnsenum">DNSEnum¶</a></h4>
<p>DNS Enumeration tool</p>
<pre><code>dnsenum &lt;domain&gt;
</code></pre>
<h4 id="srv-records"><a class="header" href="#srv-records">SRV Records¶</a></h4>
<p>Service record (SRV record) is a specification for data in the Domain Name
System defining the location, i.e. the hostname and port number, of servers
for specified services. An SRV record has the following form:</p>
<p>** _service._proto.name. TTL class SRV priority weight port target. **</p>
<ul>
<li><strong>Retrieving an SRV record:</strong></li>
</ul>
<blockquote>
<pre><code>$ dig _sip._tls.example.com SRV

$ host -t SRV _sip._tls.example.com

$ nslookup -querytype=srv _sip._tls.example.com

$ nslookup
 &gt; set querytype=srv
 &gt; _sip._tls.example.com
</code></pre>
</blockquote>
<ul>
<li><strong>Usage:</strong></li>
</ul>
<blockquote>
<p>SRV records are used by the below standardized communication protocols:</p>
<pre><code>Teamspeak 3 (since version 3.0.8 - Neither priority nor weight is taken
</code></pre>
<p>into consideration. The client appears to choose an SRV record at random for
a connection attempt.[1])
Minecraft (since version 1.3.1, _minecraft._tcp)
CalDAV and CardDAV
Client SMTP Authorization
DNS Service Discovery (DNS-SD)
IMPS
Kerberos
LDAP
Puppet
SIP
XMPP
Mail submission, Post Office Protocol, and Internet Message Access
Protocol
Libravatar uses SRV records to locate avatar image servers
Microsoft Lync
Citrix Receiver</p>
<p>Checkout the brute_srv function in dnsrecon tool script to get familiar with
the different SRV names and services.</p>
</blockquote>
<h2 id="internal-infrastructure-mapping"><a class="header" href="#internal-infrastructure-mapping">Internal Infrastructure Mapping¶</a></h2>
<p>All the steps active-fingerprinting which are DNS related recon could also be
performed during an internal penetration testing provided we have access to
the internal DNS Server. After, we have gathered all the information from DNS
enumeration. We haven’t enumerated the internal infrastructure. We apply the
below methods to enumerate further.</p>
<h3 id="internal-network-range-identification"><a class="header" href="#internal-network-range-identification">Internal Network Range Identification¶</a></h3>
<p>In many instances, we are provided or expected to find vulnerabilities in a
10.0.0.0/8 network which would contain around 16 million IP Addresses.
Scanning 16 million IP address in a considerable time is difficult. In which
case, we need faster and targeted result. So, how do we find out the IP
range(s)?</p>
<h4 id="ping-gateway-ip-addresses"><a class="header" href="#ping-gateway-ip-addresses">Ping Gateway IP Addresses¶</a></h4>
<p>Let’s say internally, we got an IP address 192.168.56.101 netmask
255.255.255.0 with a default gateway of 192.168.56.1. It is a high probability
that the rest of the network ranges would have been defined as /24 CIDR as
well. In that case, a ping sweep for the range of 192.168.*.1 with a watch on
the TTL would possibly reveal what the other network ranges are.</p>
<pre><code>nmap -sn -v -PE 192.168.*.1
</code></pre>
<p>Todo</p>
<p>Provide output example?</p>
<h4 id="dns-enumeration"><a class="header" href="#dns-enumeration">DNS Enumeration¶</a></h4>
<p>If you are connected to a internal dns server, you may query it with</p>
<pre><code>dig -t any &lt;domainname&gt;
</code></pre>
<p>which should result in an output containing different name servers, mail
servers, A, AAAA, SOA records which would possibly give you a inner scenario
how the network has been designed as there can be different nameservers,
domain controllers for different locations, internal departments etc.</p>
<p>Todo</p>
<p>Convert dig output directly into hostname, ip address format.</p>
<h4 id="internal-portal-links"><a class="header" href="#internal-portal-links">Internal Portal Links¶</a></h4>
<p>Most of the organizations have internal portals which serves as a one-stop
spot with links to every possible portal link. This could also result in some
internal range exposure.</p>
<p>Todo</p>
<p>Write the script for grep and printing host and IP address and combine it with
DNS Enumeration.</p>
<h4 id="reverse-dns-lookup"><a class="header" href="#reverse-dns-lookup">Reverse DNS Lookup¶</a></h4>
<p>Nmap provides a List scan option which does the reverse lookup. It provides
the hostnames of the IP Address</p>
<pre><code>nmap -sL 10.0.0.0/8
</code></pre>
<p>It can also be used with the below options:</p>
<pre><code>--randomize-hosts  : make the scans less obvious to various network monitoring systems
--dns-servers server1,server2 : By default, it would use the dns servers which are listed in resolve.conf (if you haven't used --system-dns option). We can also list custom servers using these options.
</code></pre>
<p>Example:</p>
<pre><code>nmap -sL 45.33.32.156

Starting Nmap 7.60 ( https://nmap.org ) at 2018-01-21 12:29 CET
Nmap scan report for scanme.nmap.org (45.33.32.156)
Nmap done: 1 IP address (0 hosts up) scanned in 0.23 seconds
</code></pre>
<h3 id="identifying-alive-ip-addresses"><a class="header" href="#identifying-alive-ip-addresses">Identifying Alive IP Addresses¶</a></h3>
<p>Nmap by default provides a -sn Ping scan option. Default host discovery is
done with -sn which consists of an ICMP echo request, TCP SYN to port 443, TCP
ACK to port 80, and an ICMP timestamp request by default. This works as if
ICMP echo request is blocked, nmap would know if a host is alive if it
receives any response from port 443 or 80 or timestamp reply.</p>
<p>Let’s see what nmap does when we do a ping scan.</p>
<pre><code>nmap -sn -n 10.0.0.230
#My IP is 10.0.0.1
</code></pre>
<p>It is very important to mention that the -n option (No DNS resolution) should
be used going forward as we have already did DNS resolution while using nmap’s
List scan. Since DNS can be slow even with Nmap’s built-in parallel stub
resolver, this option can slash scanning times. TCP Dump output is presented
here. As both the IP addresses are in the same subnet, nmap would use ARP Ping
scan to find the alive IP Address.</p>
<pre><code>22:11:27.292054 ARP, Request who-has 10.0.0.230 (Broadcast) tell 10.0.0.1, length 28
22:11:27.361100 ARP, Reply 10.0.0.230 is-at 8c:64:22:3b:2b:2d (oui Unknown), length 28
</code></pre>
<p>However, this behaviour can be changed using –disable-arp-ping.</p>
<pre><code>nmap -sn 10.0.0.230 --disable-arp-ping
</code></pre>
<p>TCPdump output is as below One ICMP Echo Request, SYN to Port 443, ACK to Port
80 and a time stamp request.</p>
<pre><code>22:14:02.742180 IP 10.0.0.1 &gt; 10.0.0.230: ICMP echo request, id 45066, seq 0, length 8
22:14:02.742222 IP 10.0.0.1.59246 &gt; 10.0.0.230.https: Flags [S], seq 3994420539, win 1024, options [mss 1460], length 0
22:14:02.742234 IP 10.0.0.1.59246 &gt; 10.0.0.230.http: Flags [.], ack 3994420539, win 1024, length 0
22:14:02.742241 IP 10.0.0.1 &gt; 10.0.0.230: ICMP time stamp query id 38635 seq 0, length 20
22:14:02.801243 IP 10.0.0.230 &gt; 10.0.0.1: ICMP echo reply, id 45066, seq 0, length 8
22:14:02.801930 IP 10.0.0.230.https &gt; 10.0.0.1.59246: Flags [R.], seq 0, ack 3994420540, win 0, length 0
22:14:02.805083 IP 10.0.0.230.http &gt; 10.0.0.1.59246: Flags [R], seq 3994420539, win 0, length 0
22:14:02.805930 IP 10.0.0.230 &gt; 10.0.0.1: ICMP time stamp reply id 38635 seq 0: org 00:00:00.000, recv 16:40:52.731, xmit 16:40:52.731, length 20
</code></pre>
<p>If you use the –reason option, nmap will tell why it thinks the host is alive.
In the below case (received echo-reply).</p>
<pre><code>Nmap scan report for 10.0.0.230
Host is up, received echo-reply (0.073s latency).
</code></pre>
<p>If we only want to send an ICMP Ping query (as if the host replies to it, the
other three packets (SYN 443, ACK 80 and Timestamp) are an extra burden. (I
may be wrong here). We can use</p>
<pre><code>nmap -n -sn -PE --disable-arp-ping 10.0.0.230
</code></pre>
<p>TCP Dump output:</p>
<pre><code>22:30:20.768525 IP 10.0.0.1 &gt; 10.0.0.230: ICMP echo request, id 39366, seq 0, length 8
22:30:20.826098 IP 10.0.0.230 &gt; 10.0.0.1: ICMP echo reply, id 39366, seq 0, length 8
</code></pre>
<p>Please note that this ICMP scan would miss all the hosts which are alive but
where the firewall is dropping the ICMP echo request packet. However, if you
want to find more hosts, it would be advisable to separate the list of IPs
which responded to ICMP from the IP address scan range and run the scan again
(may be) with a SYN to 443 and an ACK to 80 using PA, PS options.</p>
<p>Please also note Nmap’s ICMP ping, by default, sends zero data as part of the
ping. Nmap typically pings the host via ICMP if the user has root privileges,
and uses a tcp-ping otherwise. This is easily detected by Snort’s IDS Rule
1-469 <a href="https://www.snort.org/rule_docs/1-469">SID 1-469</a>.</p>
<p>This could be evaded by using</p>
<pre><code>--data &lt;hex string&gt; (Append custom binary data to sent packets)
--data-string &lt;string&gt; (Append custom string to sent packets)
--data-length &lt;number&gt; (Append random data to sent packets)
</code></pre>
<p>Please note that you should use these options only on ICMP Echo Request for
IDS Evasion as the data gets appended to every packet (ex. port scan packets).
Designing the ideal combinations of probes as suggested in the Nmap Book is</p>
<pre><code>-PE -PA -PS 21,22,23,25,80,113,31339 -PA 80,113,443,10042
 Adding --source-port 53 might also help
</code></pre>
<p>The above combination would find more hosts than just the ping scan, however
it also gonna cost a decent amount of time. Normal Time vs. Accuracy trade
off.</p>
<p>-PE, -PA and -PS send respectively a ICMP request, TCP ACK, and TCP SYN probe.</p>
<p>Todo</p>
<p>replace section above with nping after comparing results?</p>
<p>Todo</p>
<p><a href="https://linux.die.net/man/1/nping">https://linux.die.net/man/1/nping</a></p>
<p>Todo</p>
<p>using -PA twice seems odd</p>
<h3 id="port-scanning"><a class="header" href="#port-scanning">Port Scanning¶</a></h3>
<p>Once you have the list of IP Addresses which are alive, we can perform
portscanning on them. Nmap provides multiple options such as</p>
<pre><code>-sS TCP SYN Stealth : Half Open SYN Scan : Nmap sends the SYN packet, Server would send SYN/ACK, System would send RST.
-sT TCP Connect Scan : Nmap uses system to send the SYN scan : Connect full TCP Handshake
-sU UDP Scan
-sA ACK Scan : Ack scan is generally used to map out firewall rule sets. (Whether a firewall is stateful or not)
</code></pre>
<p>Please note p0f recognizes Nmap’s SYN scan because of the TCP Options such as
the TCP window size which is a multiple of 1024, and only the MSS option
supported with a value of 1460 (Check the tcpdump output of Ping scan above,
SYN Packet). Recently, a IRC user was getting filtered port while using SYN
Scan whereas he was getting OPEN ports when using telnet or TCP Connect Scan.
Also, A patch to allow a user to override the TCP Window size in SYN scan was
posted to the [Nmap Development List](http://seclists.org/nmap-
dev/2015/q3/52).</p>
<p>By default, nmap scans the 1000 most popular ports of each protocol (gathered
by scanning million of IP address). Scanning 1000 ports in an unknown
environment with 16 million IP Address could be challenging. Nmap also
provides a Fast scan (-F) option which scans the 100 most common ports for
each protocol. Otherwise it also provides –top-ports to specify an arbitrary
number of ports. So, How do we know what are the ports scanned with –top-ports
option? This could be figured out for respectively the top 1000 and top 100
ports by running the following commands:</p>
<pre><code>nmap -sT -oG - -v | grep '^# Ports'
</code></pre>
<p>or</p>
<pre><code>nmap localhost -F -oX - | grep '^&lt;scaninfo'
</code></pre>
<p>Nmap needs an nmap-services file with frequency information in order to know
which ports are the most common. See the section called <a href="http://seclists.org/nmap-dev/2015/q3/52">Well Known Port List:
nmap-services</a> : for more information
about port frequencies. We could provide ports to nmap by using -p option
also, for example</p>
<pre><code>-p 22 : Scan single port
-p 22,25,80 : Scan multiple ports with comma separated values. If -sS is specified TCP ports would be scanned (syn). If -sU UDP Scan is specified, UDP Ports would be scanned.
-p 80-85, 443, 8000-8005 : Scan port with ranges.
-p- : Scan all the ports excluding 0.
-pT:21,22,25,U:53,111,161 : Scan TCP 21,22,25 and UDP Ports 53,111,161. -sU must also be specified.
-p http* : wild cards may be used for ports with similar names. This would match nine ports including 80,280,443,591,593,8000,8008,8080,8443.
</code></pre>
<p>Port scanning via <strong>netcat</strong> : Netcat might not be the best tool to use for
port scanning, but can be used quickly. netcat scans TCP ports by default, but
we can perform UDP scans as well.</p>
<p>For a TCP scan, the format is</p>
<pre><code>nc -vvn -z xxx.xxx.xxx.xxx startport-endport
   -z flag is Zero-I/O mode (used for scanning)
   -vv will provide verbose information about the results
   -n flag allows to skip the DNS lookup
</code></pre>
<p>For a UDP Port Scan, we need to add -u flag which makes the format</p>
<pre><code>nc -vvn -u -z xxx.xxx.xxx.xxx startport-endport
</code></pre>
<p>If we have windows machine without nmap, we can use
<a href="https://www.powershellgallery.com/packages/PSnmap/">PSnmap</a></p>
<h4 id="identifying-service-versions"><a class="header" href="#identifying-service-versions">Identifying service versions¶</a></h4>
<p>Ideally, we can use -sV to probe the ports to find the running version of a
service. When performing a version scan (-sV), Nmap sends a series of probes,
each of which is assigned a rarity value in regards to correctly identifying a
service. However, high intensity scans or in other words sending many probes
takes longer. The intensity must be between 0 and 9. The default is 7.</p>
<p>Ideally, to avoid IDS Detection, we should avoid using the -sV option.
However, we can keep the noise less by using –version intensity by which we
can control the number of probes sent to determine the service. Setting this
option to 0 will send only the Null probe (connect and wait for banner) and
any probes that have been specifically listed as pertaining to the scanned
port in nmap-service-probes. The other available options are provided below:</p>
<pre><code>--version-light (Enable light mode) : Alias for --version-intensity 2.
--version-all (Try every single probe) : An alias for --version-intensity 9
--version-trace (Trace version scan activity) : Print debugging information.
</code></pre>
<p>Also, when -sV is specified apart from the probes, all the scripts in the
<a href="https://nmap.org/nsedoc/categories/version.html">Version</a> category are
executed. These scripts could be prevented from running by removing them from
the script.db catalog or by building Nmap without NSE support (./configure
–without-liblua). However, if –version-intensity option is less than 7, those
scripts won’t be executed (I might be a little wrong here).</p>
<p>So our scan would become approx</p>
<pre><code>nmap &lt;IP_Address_Range&gt; -n --top-ports &lt;number&gt;/-p &lt;Custom Port List&gt; -sV --version-intensity 0/ (No -sV)
</code></pre>
<h4 id="performance"><a class="header" href="#performance">Performance¶</a></h4>
<p>So, how can we improve the performance of our nmap scan, so that result could
be achieved faster. As always we will have Time Vs Accuracy Trade off.</p>
<pre><code>-T&lt;0-5&gt;: Set timing template (higher is faster)
--min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout &lt;time&gt;: Specifies probe round trip time.
--max-retries &lt;tries&gt;: Caps number of port scan probe retransmissions.
--host-timeout &lt;time&gt;: Give up on target after this long
--scan-delay/--max-scan-delay &lt;time&gt;: Adjust delay between probes
--min-rate &lt;number&gt;: Send packets no slower than &lt;number&gt; per second
--max-rate &lt;number&gt;: Send packets no faster than &lt;number&gt; per second
</code></pre>
<p>T0, T1, T2 is specifically for IDS Evasion. T3 is the default. We can set max-
retries to a lower value such as 2. Currently it’s 10 for T0, T1, T2, T3; 6
for T4 and 2 for T5.</p>
<h4 id="nmap-scripts"><a class="header" href="#nmap-scripts">Nmap Scripts¶</a></h4>
<p>As bonsaiviking says in <a href="http://blog.bonsaiviking.com/2015/07/they-see-me-scannin-part-2.html">They See Me Scanning Part
2</a> If
you are wild enough to try NSE scripts against an IDS-protected target, you
should know how to read Lua, since the script sources are the final authority
on what data is sent. But if you’re just looking to get a little better at
blending in, these tips should help:</p>
<ul>
<li>Use –script-args-file to pass script arguments to Nmap from a file. This will keep your command line clean and make it harder to accidentally miss one of the options you choose</li>
<li>Obviously avoid dos, intrusive, and exploit category scripts.</li>
<li>Use scripts by name instead of by category, so that you know exactly what will be run.</li>
<li>Thoroughly read the documentation for each script you intend to use. Set http.useragent to something believable that blends in. Currently, the HTTP scripts all use a User-Agent header that identifies as “Nmap Scripting Engine.”</li>
</ul>
<p>Note</p>
<p>Nmap scripts are stored in /usr/share/nmap/scripts</p>
<h4 id="output-options"><a class="header" href="#output-options">Output Options¶</a></h4>
<pre><code>-oN/-oX/-oS/-oG &lt;file&gt;: Output scan in normal, XML, s|&lt;rIpt kIddi3, and Grepable format, respectively.
-oA &lt;basename&gt;: Output in the three major formats at once
--reason: Display the reason a port is in a particular state
--open: Only show open (or possibly open) ports
--packet-trace: Show all packets sent and received
--resume &lt;filename&gt;: Resume an aborted scan: Filename should be .nmap or .gnmap
</code></pre>
<p>At this point, it’s good to find what are the most common ports open in the
scan we just performed by</p>
<pre><code>grep &quot;^[0-9]\+&quot; &lt;nmap file .nmap extension&gt; | grep &quot;\ open\ &quot; | sort | uniq -c | sort -rn | awk '{print &quot;\&quot;&quot;$1&quot;\&quot;,\&quot;&quot;$2&quot;\&quot;,\&quot;&quot;$3&quot;\&quot;,\&quot;&quot;$4&quot;\&quot;,\&quot;&quot;$5&quot; &quot;$6&quot; &quot;$7&quot; &quot;$8&quot; &quot;$9&quot; &quot;$10&quot; &quot;$11&quot; &quot;$12&quot; &quot;$13&quot;\&quot;&quot;}' &gt; test.csv
</code></pre>
<p>or</p>
<pre><code>xmlstarlet sel -t -m '//port/state[@state=&quot;open&quot;]/parent::port' -v 'ancestor::host/address/@addr' -o : -v './@portid' -n nmap-output.xml
</code></pre>
<h3 id="exploring-the-network-further"><a class="header" href="#exploring-the-network-further">Exploring the Network Further¶</a></h3>
<p>By now, we would have information about what ports are open and possibly what
services are running on them. Further, we need to explore the various options
by which we can get more information.</p>
<h4 id="gathering-screenshots-for-http-services"><a class="header" href="#gathering-screenshots-for-http-services">Gathering Screenshots for http* services¶</a></h4>
<p>There are four ways (in my knowledge to do this):</p>
<ul>
<li><strong>http-screenshot NSE</strong> : Nmap has a NSE script <a href="https://github.com/SpiderLabs/Nmap-Tools/blob/master/NSE/http-screenshot.nse">http-screenshot</a> This could be executed while running nmap. It uses the wkhtml2image tool. Sometimes, you may find that running this script takes a long time. It might be a good idea to gather the http* running IP, Port and provide this information to wkhtml2image directly via scripting. You do have to install wkhtml2image and test with javascript disabled and other available options.</li>
<li><strong>httpscreenshot</strong> from breenmachine: <a href="https://github.com/breenmachine/httpscreenshot">httpscreenshot</a> is a tool for grabbing screenshots and HTML of large numbers of websites. The goal is for it to be both thorough and fast which can sometimes oppose each other.</li>
<li><strong>Eyewitness</strong> from Chris Truncer: <a href="https://github.com/ChrisTruncer/EyeWitness">EyeWitness</a> is designed to take screenshots of websites, provide some server header info, and identify default credentials if possible.</li>
<li>Another method is to use <a href="https://code.google.com/p/java-html2image/">html2image</a> which is a simple Java library which converts plain HTML markup to an image and provides client-side image-maps using html element.</li>
<li><strong>RAWR: Rapid Assessment of Web Resources</strong> : <a href="https://bitbucket.org/al14s/rawr/wiki/Home">RAWR</a> provides with a customizable CSV containing ordered information gathered for each host, with a field for making notes/etc.; An elegant, searchable, JQuery-driven HTML report that shows screenshots, diagrams, and other information. A report on relevant security headers. In short, it provides a landscape of your webapplications. It takes input from multiple formats such as Nmap, Nessus, OpenVAS etc.</li>
</ul>
<h4 id="information-gathering-for-http-services"><a class="header" href="#information-gathering-for-http-services">Information Gathering for http* Services¶</a></h4>
<ul>
<li><a href="http://www.morningstarsecurity.com/research/whatweb">WhatWeb</a> recognises web technologies including content management systems (CMS), blogging platforms, statistic/analytics packages, JavaScript libraries, web servers, and embedded device. <a href="https://www.aldeid.com/wiki/Tellmeweb">Tellmeweb</a> is a ruby script which reads a Nmap Gnmap file and runs whatweb against all identified open http and https ports. A <a href="https://github.com/stevecoward/whatweb-parser">WhatWeb Result Parser</a> has also been written which converts the results to CSV format. More information about advanced usage can be found at <a href="https://github.com/urbanadventurer/WhatWeb/wiki/Advanced-Usage">Whatweb Advance Usage</a>.</li>
<li><a href="http://wappalyzer.com">Wapplyzer</a> is a Firefox plug-in. There are four ways (in my knowledge to do this) be loaded on browser. It works completely at the browser level and gives results in the form of icons.</li>
<li><a href="http://w3techs.com/">W3Tech</a> is another Chrome plug-in which provides information about the usage of various types technologies on the web. It tells which web technologies are being used based on the crawling it has done. So example.com, x1.example.com, x2.example.com will show the same technologies as the domain is same (which is not correct).</li>
<li><a href="https://github.com/justjavac/ChromeSnifferPlus">ChromeSnifferPlus</a> is another chrome extension which identifies the different web-technologies used by a website.</li>
<li><a href="http://builtwith.com/">BuiltWith</a> is another website which provides a good amount of information about the different technologies used by website.</li>
</ul>
<h4 id="netbios-service"><a class="header" href="#netbios-service">NetBIOS Service¶</a></h4>
<p>Netbios listens on TCP Port 139, 445 and UDP Port 137. We can use grep to
identify machines we ran nmap against earlier on which these three ports or a
combination of them are open. The idea is the filter those IP’s out and feed
them to nbtscan and/or enum4linux</p>
<pre><code>:Grep for UDP port 137 which is required for nbtscan
grep -E &quot;^Host.*[ ]137/open/udp&quot; &lt;Nmap .gnmap file&gt;
grep -E &quot;^Host.*[ ]139/open/tcp&quot; &lt;Nmap .gnmap file&gt;

:Grep for TCP 139 and 445 to be able to run enum4linux
grep -E &quot;^Host.*[ ]139/open/tcp&quot; &lt;Nmap .gnmap file&gt; | grep -E &quot;^Host.*[ ]445/open/tcp&quot;                 &lt;Nmap .gnmap file&gt;

.. Todo:: validate which ports are required for enum4linux
.. Todo:: in previous example, grep TCP 135 and 445 port were mentioned as prerequisitis to run enum4linux

#If we want that tcp port 139 or 445 must be open
grep -E &quot;^Host.*[ ]139/open/tcp|[ ]443/open/tcp&quot; &lt;Nmap .gnmap file&gt;
</code></pre>
<h4 id="nbtscan"><a class="header" href="#nbtscan">NBTSCAN¶</a></h4>
<pre><code>nbtscan
    -v              Verbose output. Print all names received from each host.
    -f filename     Take IP addresses to scan from file &quot;filename&quot;
</code></pre>
<h4 id="enum4linux"><a class="header" href="#enum4linux">enum4linux¶</a></h4>
<p>A Linux alternative to enum.exe to enumerate data from Windows and Samba
hosts. It is basically a wrapper around the Samba tools smbclient, rpclient,
net and nmblookup. A very good usage guide is
<a href="https://labs.portcullis.co.uk/tools/enum4linux/">enum4linux</a></p>
<h4 id="snmp-enumeration"><a class="header" href="#snmp-enumeration">SNMP Enumeration¶</a></h4>
<p>For SNMP Enumeration, UDP Port 161 should be open. To gather more information
we can use:</p>
<ul>
<li><strong>snmpcheck:</strong></li>
</ul>
<blockquote>
<pre><code>snmpcheck -t &lt;IP address&gt;
     -c : SNMP community; default is public
     -v : SNMP version (1,2); default is 1
     -w : detect write access (separate action by enumeration)
</code></pre>
</blockquote>
<ul>
<li><strong>snmpwalk:</strong></li>
</ul>
<p>Also allows us to interact with the SNMP version 3 and extract particular
nodes of a MIB tree.</p>
<blockquote>
<pre><code>snmpwalk -­c public ­‐v1 &lt;IP Address&gt;  : Enumerates the Entire MIB Tree
snmpwalk -­c public ­‐v1 &lt;IP Address&gt;  &lt;MIB Tree Number&gt; : Enumerates a
</code></pre>
<p>particular node
-v 1|2c|3     specifies SNMP version to use
-c COMMUNITY  set the community string</p>
</blockquote>
<ul>
<li><strong>OneSixtyOne:</strong></li>
</ul>
<p>Onesixtyone allows you to brute force the community strings</p>
<p>Todo</p>
<p>give example?</p>
<h2 id="attack-surface-area---reconnaissance-tools"><a class="header" href="#attack-surface-area---reconnaissance-tools">Attack Surface Area - Reconnaissance Tools¶</a></h2>
<h3 id="aquatone-a-tool-for-domain-flyovers"><a class="header" href="#aquatone-a-tool-for-domain-flyovers">Aquatone: A tool for domain flyovers¶</a></h3>
<p><a href="https://github.com/michenriksen/aquatone">Aquatone</a> is a set of tools for
performing reconnaissance on domain names. It can discover subdomains on a
given domain by using open sources as well as the more common subdomain
dictionary brute force approach. After subdomain(s) discovery, AQUATONE can
scan the identified hosts (subdomains) for common web ports and HTTP headers,
HTML bodies and screenshots can be gathered and consolidated into a report for
easy analysis of the attack surface. A detailed blog is available at
[AQUATONE: A tool for domain flyovers](http://michenriksen.com/blog/aquatone-
tool-for-domain-flyovers/)</p>
<p>Todo</p>
<p>move the earlier mention recon-ng, dnsenum, dnsrecon section?</p>
<p>Todo</p>
<p>provide an example?</p>
<h3 id="datasploit"><a class="header" href="#datasploit">DataSploit¶</a></h3>
<p>The <a href="https://github.com/DataSploit/datasploit">Datasploit</a> tool performs
various OSINT techniques, aggregates all the raw data, and returns the
gathered data in multiple formats.</p>
<p>Functional Overview:</p>
<ul>
<li>Performs OSINT on a domain / email / username / phone and find out information from different sources.</li>
<li>Correlates and collaborate the results, shows them in a consolidated manner.</li>
<li>Tries to figure out credentials, api-keys, tokens, subdomains, domain history, legacy portals, etc. related to the target.</li>
<li>Use specific script/ launch automated OSINT to consolidate data.</li>
<li>Performs Active Scans on collected data.</li>
<li>Generates HTML, JSON reports along with text files.</li>
</ul>
<h3 id="spiderfoot"><a class="header" href="#spiderfoot">Spiderfoot¶</a></h3>
<p><a href="http://www.spiderfoot.net/">SpiderFoot</a> is an open source intelligence
automation tool. Its goal is to automate the process of gathering intelligence
about a given target, which may be an IP address, domain name, hostname or
network subnet. SpiderFoot can be used offensively, i.e. as part of a black-
box penetration test to gather information about the target or defensively to
identify what information your organization is freely providing for attackers
to use against you.</p>
<p>Todo</p>
<p>add example?</p>
<h3 id="intrigueio"><a class="header" href="#intrigueio">Intrigue.io¶</a></h3>
<p><a href="https://github.com/intrigueio/intrigue-core">Intrigue</a> makes it easy to
discover information about the attack surface connected to the Internet.
Intrigue utilizes common OSINT sources via “tasks” to create “entities”. Each
discovered entity can be used to discover more information, either
automatically or manually.</p>
<p>Todo</p>
<p>to the Internet &gt; about the attacker surface of a given domain/host connected
to the Internet?</p>
<p>Todo</p>
<p>demo?</p>
<h2 id="appendix-i--interesting-stories"><a class="header" href="#appendix-i--interesting-stories">Appendix-I : Interesting Stories¶</a></h2>
<h3 id="initial-compromise"><a class="header" href="#initial-compromise">Initial Compromise¶</a></h3>
<ul>
<li><a href="http://threat.tevora.com/apache-and-java-information-disclosures-lead-to-shells/">Apache and Java Information Disclosures Lead to Shells</a> : Richard De La Cruz talks about a recent Red-Team engagement, where a series of information disclosures were discovered on a site allowing the team to go from zero access to full compromise in a matter of hours.</li>
</ul>
<p>Summary:</p>
<blockquote>
<ul>
<li>Information disclosures in Apache HTTP servers with mod_status enabled
allowed our team to discover .jar files, hosted on the site.</li>
<li>Static values within the exposed .jar files allowed our team to extract
the client’s code signing certificate and sign malicious Java executables as
the client.</li>
<li>These malicious .jar files were used in a successful social engineering
campaign against the client.</li>
</ul>
</blockquote>
<p>Todo</p>
<p>A lot of tools are being mentioned in this blog article. It might therefore be
interesting to give a run down. Which might be highly situationals</p>
<h2 id="changelog"><a class="header" href="#changelog">Changelog¶</a></h2>
<ul>
<li><strong>Added Open-Ports via XML</strong> by <em>bitvijays</em></li>
</ul>
<h3 id="navigation-1"><a class="header" href="#navigation-1">Navigation</a></h3>
<ul>
<li><a href="C++%E5%AD%A6%E4%B9%A0/index.html">tech.bitvijays.com</a> »</li>
</ul>
<p>(C) Copyright 2017, Vijay Kumar.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
